<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试题</title>
      <link href="/2023/04/06/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/04/06/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="jvm篇"><a href="#jvm篇" class="headerlink" title="jvm篇"></a>jvm篇</h1><h2 id="1、JVM的运行时数据区"><a href="#1、JVM的运行时数据区" class="headerlink" title="1、JVM的运行时数据区"></a>1、JVM的运行时数据区</h2><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220220161522429.png" alt="image-20220220161522429"></p><p>1、一般将.java后缀的文件，使用javac编译成.class文件，然后通过我们的类加载器将我们的字节码文件记载到我们的运行时数据区中。</p><p>2、运行时数据区主要分为方法区、虚拟机栈、本地方法栈、堆、程序计数器</p><p>3、程序计数器是线程私有的，也就是每个线程都拥有一个程序计数器，主要用于记录当前线程执行的字节码的文件的行数。为什么需要程序计数器就是因为我们的java的多线程是通过不断的切换的cpu的时间片来进行实现。所以会发生执行线程会不断的进行切换。所以我们需要一个程序计数器，来记录当前线程执行到的位置。程序计数器是jvm规范中唯一没有规定任何规范的的区域。</p><p>3、虚拟栈也是线程私有的，当我们的方法被执行时。创建一个栈帧，这个栈帧主要存储的是我们的局部变量、基本数据类型、返回地址等，将这个栈帧进行压栈操作。当我们的执行完方法后，会将虚拟机栈中的栈帧进行弹栈操作。当我们的请求的栈的深度大于我们的默认的栈的深度时，会抛出<strong>StackOverflowError异常</strong>。当我们的请求创建栈帧的时候，内存空间不足以创建时，会抛出<strong>OutOfMemoryError异常错误</strong>。-Xss来进行调控，但是最好不要调的过大。因为会导致我们的创建的线程变少。</p><p>4、方法区，是线程共享的区域，它主要用于存储的类相关的信息，比如说常量、静态变量、类型信息、常量池、即使编译器编译的代码信息等都会存储在我们的方法区中。方法区是jvm的规范，但是的具体的实现不同，在jdk1.6的时候，采用永久带进行的实现，在jdk1.8的时候，采用的元空间MateSpace来进行实现。然后将我们的永久带中的Stringtable进行了移除，然后将我们的字符常量池放入到了我们的堆中。在jdk1.8的时候采用的元空间来进行实现。可以使用我们的-XX:MatespaceSize来进行调控。当我们的方法区无法满足新的内存分配时，就会抛出异常OutOfMoneryError错误。</p><p>5、堆，是线程共享的内存区域，它主要用于存储的java中的所有的对象，都会在我们的java堆中的进行内存的分配。所以堆中的对象都需要考虑的线程安全的问题。存在垃圾回收。堆内存溢出会抛我们的OutOfMoneryError错误。</p><blockquote><p>对象的创建:对象的创建我们是通过java的new关键字来进行创建，但是在jvm层面的创建过程是通过字节码new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被记载、解析和初始化过。如果没有，先将这个类进行类加载。类记载通过之后，会heap堆中分配内存空间.然后会根据我们的堆空闲的内存是否规整，来选择不同的方式去分配我们的内存空间。堆中的内存空间是否规整主要取决于我们选择何种的垃圾收集器，比如说seriel、Parnew等代压缩整理收集器的话，我们可以采用指针碰撞的方式来分配堆中的空间。如果是采用cms这种基于我们的垃圾清除算法的收集器的话，会产生我们的内存碎片，所以我们需要使用的空闲列表的方式来分陪堆中的内存空闲。</p></blockquote><p>因为我们的java堆是线程共享的，所以会存在线程安全的问题。所以我们的创建的对象的过程中，也会出现线程安全的问题。jvm 主要采用了两种方式来实现我们的创建对象的线程安全。1、采用乐观锁的机制，也就是cas加上失败重试来保证我们的线程安全。2、采用ZlAB本地线程分配缓存来保证我们的线程安全。线程隔离的方式来实现线程安全的。</p><p>扩展点:</p><p>java对象的内存布局:对象头(8个字节)、实例数据、对其填充。</p><ul><li>用于存储对象自身的运行时数据,如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程id、偏向时间戳等。(Mark world)</li><li>类型指针,即对象指向它的类型元数据等指针,java虚拟机通过这个指针来确定改对象是那个类的实例。</li></ul><p>对象的访问定位:</p><ul><li>句柄:java堆中可能会划出一块内存作为句柄池，这样我们找对象只需要通过我们的句柄池来进行查找。</li><li>直接指针:就是直接使用指针去关联这块内存地址。就直接通过访问我们的指针就可以拿到对象了。</li></ul><h2 id="2、JVM中如何判断对象可以回收"><a href="#2、JVM中如何判断对象可以回收" class="headerlink" title="2、JVM中如何判断对象可以回收"></a>2、JVM中如何判断对象可以回收</h2><p><font color="red">1. 引用计数法</font></p><p>只要有一个对象被其他对象所引用，就会让这个对象的计数器加1，没有引用就会减一，直到这个计数为0，那么这个对象就会被判定为垃圾对象。</p><p>缺点:如果两个对象互相引用，就会导致我们这两个对象计数器，永远都不会为0，这两个对象引用不会被回收。</p><p><font color="red">2、可达性分析</font></p><p>可达性分析算法首先会确定一系列的根对象(确定不会当作垃圾回收的对象被称为根对象),然后沿着我们的根对象进行遍历，如果一个对象直接或者间接被我们的根对象进行引用的话，那么就不是垃圾对象。如果没有引用的话，那么就是垃圾对象。</p><h2 id="3、可以被当作GCRoots的对象"><a href="#3、可以被当作GCRoots的对象" class="headerlink" title="3、可以被当作GCRoots的对象"></a>3、可以被当作GCRoots的对象</h2><ul><li>java虚拟机栈中引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中的常量引用对象</li><li>本地方法栈中的native修饰的对象</li><li>加锁的一些对象，也可以作为GCRoot</li></ul><h2 id="4、java中的引用"><a href="#4、java中的引用" class="headerlink" title="4、java中的引用:"></a>4、java中的引用:</h2><p>1、强引用:常用的引用复制给一个对象，这就是强引用，jvm不会回收强引用对象。</p><p>2、弱引用:就是弱一点的对象，可以使用sortReference来进行修饰，将对象装饰成一个弱对象，就是当我们的堆内存中的不足的时候，会去回收。当我们的java的内存空间不足的时候，不会去进行回收。</p><p>3、软引用:就是更软一点的对象，可以使用我们的workReference来进行修饰。将对象装饰成一个软引用对象。只要发现垃圾回收，就会将我们的软引用进行回收。</p><p>4、虚引用相当于没有引用，只能搭配我们的引用队列来进行使用，ReferenceQueue。主要是来解决我们的当我们的对象被回收做一些通知操作。</p><h2 id="5、怎么去遍历这个可达性分析算法的。"><a href="#5、怎么去遍历这个可达性分析算法的。" class="headerlink" title="5、怎么去遍历这个可达性分析算法的。"></a>5、怎么去遍历这个可达性分析算法的。</h2><p>1、因为的可达性分析算法必须先确定我们的一系列的根对象，所以我们在确定这些根对象时，必须暂定用户线程也就是我们的常说的stw。stop the world。</p><p>为什么减少这个stw的时间，使用了三色标记作为工具辅导推导。按照是否访问过的这个条件标记成以下三种颜色。</p><ul><li>白色:表示该对象尚未被垃圾收集器访问过。</li><li>黑色:表示被遍历过，存活的对象。</li><li>灰色:表示中间地带。就是已经被垃圾收集器访问过，但是这个对象至少存在一个引用还没有扫描过。</li></ul><p>从三色标记这里可以知道,为什么垃圾收集器在枚举GCRoots的时候，需要将其他用户线程进行冻结。</p><p>如果垃圾收集线程在工作,用户线程是并发工作的，收集器在对象图上标记颜色,同时用户线程在修改引用关系-即修改对象图的结构,这可以会出现两种问题:</p><ul><li>把原本消亡的对象错误标记为存活，这是可以容忍的,下次垃圾收集器在工作时，就可以回收这些浮动垃圾。</li><li>把原本存活的对象错误标记为已消亡，这是不能忍受的错误。程序出现错误。</li></ul><p>一下两个条件同时满足时,会产生对象消失问题,即原本应该是黑色的对象被误标为白色:</p><ul><li>赋值器插入了一条或多条从黑色对象到白色对象到新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象到直接或间接引用</li></ul><p>增量更新:当黑色对象插入新的指向白色对象的引用关系时，就将这个关系记录下来，等并发扫描过后，再将这些记录的引用关系，重新扫描一次。</p><p>原始快照:当灰色对象要删除指向白色对象时的引用时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p><h2 id="6、垃圾回收算法"><a href="#6、垃圾回收算法" class="headerlink" title="6、垃圾回收算法"></a>6、垃圾回收算法</h2><p>主要分为三种:</p><p>1、标记-清除算法。沿着GCRoot对象的引用链去找,扫描堆中的空间,找出所有不被GCRoot直接或者间接引用的对象,然后进行标记。标记完成之后,会把这些标记完的对象进行清除，清除只是将空间的起始地址进行了一个记录,放入到了空间列表，下一次有对象来就直接使用这个空闲列表里面的空间直接进行覆盖即可。</p><p>缺点:会产生我们的垃圾碎片。他只是清除我们的垃圾对象，它并没有对我们的空间进行规整。我们的空间肯定是乱的啊。</p><p>优点：速度相对较快，因为它没有真正意义上对空间进行清除。</p><p>2、标记-整理算法:沿着GCRoot对象的引用链去找,扫描堆中的空间,找出所有不被GCRoot直接或者间接引用的对象,然后进行标记。标记完成之后,会把这些标记完的对象进行清理，然后会将标记对象空间后面的空间往前进行移动整理.可以解决内存碎片问题。</p><p>优点:不会产生内存碎片</p><p>缺点:就是会移动我们的内存空间，速度会慢一点。stw</p><p>3、复制算法:复制算法会开辟一个一摸一样大小的空间。然后在原有空间的基础上做垃圾标记，也是使用沿着GCRoot的引用链，找到所有被GCRoot直接或间接引用的对象，然后做出标记。然后在被GCRoot引用的对象放入到to(新的空间)里面,将form中的空间进行清除。清除完后,将to和from进行替换操作。to变成了from,from变成了to。</p><p>优点：不会产生内存碎片</p><p>缺点: 要使用两份的空间</p><p>所以在jvm中新生代里面采用了我们复制算法，但对其进行优化，jvm中from区和to区占比为8:1，也就是jvm认为90%的新生代对象都是早生夕死的。所以才可以设计。但是存在一个问题，就是当我们的清理垃圾不够的时候，也就是说我们的from空间的值大于to空间，那么怎么进行交换呢，就需要使用我们的分配担保，也就是当内存不足时，去使用一下其他的内存空间，一般都是老年代的空间。</p><p>什么是记忆集:</p><p>记忆集就是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p><p>主要用于解决:跨代引用时，避免去进行全表扫描非收集区域。</p><p>什么是卡表:</p><p>卡表就是我们的记忆集的一种实现方式。</p><p>卡表定义了记忆集的记录精度、与堆内存的映射关系等。</p><p>卡表本质就是一个字节数组。每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称为卡页。</p><p>主要卡页中存在一个一个跨代引用的指针，那么这个对应的卡表中的数组会变为1.这又被称为脏页。</p><h2 id="7、分带垃圾回收"><a href="#7、分带垃圾回收" class="headerlink" title="7、分带垃圾回收:"></a>7、分带垃圾回收:</h2><p>1、jvm将对中的内存分为新生代、老年代。</p><p>老年代又被分为三个小区域分别是:伊甸园区、幸存去from、幸存区to。</p><p>为什么这样划分？</p><p>主要是java中的有些对象需要长时间使用，这些长时间使用的对象放入到老年代，新声代中存放一些使用完之后，可以丢弃的对象，这样就可以根据对象的生命周期的不同来使用不同的垃圾回收算法.新生代因为要处理的都是一些朝生夕死的对象，所以发生垃圾回收的比较频繁。老年区因为存储着需要长时间需要的对象，需要发生垃圾回收不是很频繁。</p><h2 id="8、jvm堆中分配对象的流程"><a href="#8、jvm堆中分配对象的流程" class="headerlink" title="8、jvm堆中分配对象的流程"></a>8、jvm堆中分配对象的流程</h2><p>1、对象首先分配在新生代，当新生代的内存不足时，会触发minorGC，会进行一次回收</p><p>2、伊甸园区和幸存区from存活的对象使用copy算法复制到我们的to区中，存活的对象的年龄会加1.并且将我们from和to进行交换。</p><p>3、minorGC会触发stw，暂停其他用户线程，等垃圾回收结束，用户线程才会恢复运行。</p><p>4、当对象寿命超过阈值时，会晋升至老年代，最大寿命为15 4bit</p><p>5、当老年代的内存空间不足时，会先尝试触发minor gc，如果之后空间仍然不足,那么就会触发full gc，stw的时间更长。</p><p>6、老年代使用的算法有可能是标记清除也有可能是标记整理</p><p>7、大对象他会直接跳过新声代，直接放入到老年代</p><h2 id="9、JVM的重要的参数"><a href="#9、JVM的重要的参数" class="headerlink" title="9、JVM的重要的参数"></a>9、JVM的重要的参数</h2><p>1、堆初始大小:-Xms</p><p>2、栈初始大小:-Xss</p><p>3、堆中最大大小: -Xmx或-XX：MaxHeapsize</p><p>4、新生代大小: -Xmn</p><p>5、-Xms20m  堆初始大小</p><p>6、-XX:+UseSerialGC  指定我们的垃圾收集器</p><p>7、-XX:+ProintGCDetails  GC详情</p><h2 id="10、垃圾回收器"><a href="#10、垃圾回收器" class="headerlink" title="10、垃圾回收器"></a>10、垃圾回收器</h2><p>1、串行的垃圾回收器</p><p>Serial:单线程，适合堆内存较小，适合个人电脑。新生代的复制算法。</p><p>Serial old:老年代版的serial，标记整理算法。</p><p>缺点:当垃圾回收器线程启动的时候，其他的用户线程会进行暂停。</p><p>2、吞吐量优先（吞吐量是指系统在单位时间内处理请求的数量）</p><p>多线程版本(parallel)：适合堆内存较大，多核cpu。</p><p>-XX:+UseParallelGC JDk默认开启。</p><p>parallel scanvenge是新生代的收集器，会让我们的用户线程运行到我们的安全点。然后再去执行我们的垃圾回收线程。</p><p>Parallel old 老年代的收集器。</p><p>3、以响应时间优先:</p><p>cms:ConcurrentMarkSweep：并发的标记清理算法垃圾收集器，是一种以获得最短停顿时间为目标的收集器。</p><p>运行过程:初始标记、并发标记、重新标记、并发清除，收集结束后会产生大量的内存碎片。</p><blockquote><p>并发：是在统一时刻执行多个事情。</p><p>并行：是指同一时间段内执行了多个事情。</p></blockquote><p>流程:多个用户线程正在执行，到达安全点，会触发初始标记，初始标记只会标记一些根对象，初始标记完成之后，用户线程恢复运行，垃圾回收线程会执行并发标记，这时用户线程也是在运行的，所以这个时间段会产生一个浮动垃圾。因此cms会有重新标记的过程，重新标记完成之后，会触发并发清理，清除阶段是清理删除标记阶段判断已经死亡的对象，由于不需要移动存活对象，所以这个也可以与用户线程同时并发进行。</p><p>cms的缺点:</p><p>1、无法清理浮动垃圾。</p><p>2、占用cpu资源。</p><p>3、标记清理的算法，所以会出现内存碎片的问题。</p><p>G1 Garbage first</p><p>G1的目标是延迟可控的情况下获得尽可能的高的吞吐量，所以才被称为”全功能收集器”。</p><p>G1是一个并行回收器，他把堆内存分割成很多不相关的区域（region）.使用不同的region来表示Eden、幸存区from、幸存去to、老年代等。</p><p>G1有计划的规避在整个java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获的的空间大小以及所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p><p>G1的流程:</p><p>1、初始标记。</p><p>2、并发标记。</p><p>3、最终标记。</p><p>4、筛选回收。</p><h2 id="11、垃圾回收调优"><a href="#11、垃圾回收调优" class="headerlink" title="11、垃圾回收调优"></a>11、垃圾回收调优</h2><p>1、确定gc垃圾回收器</p><p>2、使用我们的工具查看一下gc的允许情况，GC比较频繁的区域在哪。然后找准问题，然后去解决这个问题。</p><p>3、先去查看一下自身代码是否出现问题，如果出现了一次性查询过多的对象、使用了Map去缓存了太多的数据，也有可能会造成内存溢出。</p><p>4、会尝试去新生代进行调优:</p><ul><li>新生代的对象都是根据我们的分带假说来的，也就是所有的新生代的对象都是朝生夕死。</li><li>所有的new操作所创建的对象都会在新生代中进行分配对象，在TLAB中进行分配，也就是线程本地分配缓存区。为了解决并发创建对象的问题。使用的是隔离的策略来解决并发的问题。</li><li>死亡对象的回收代价是零</li><li>MinorGC的时间远远低于FullGC。</li><li>基于这些特点需要对其进行优化的话，可以适当的调整一下堆堆大小。</li><li>-Xmn堆参数可以设置我们的堆内存大小。</li><li>新生代的大小要适当，如果新生代的内存过小，会导致我们minorGC会很频繁，不断出发minorGc会导致我们的stw，会暂停我们的用户线程，会导致我们的响应时间变长。如果minorGC过大，由会产生的问题，就会不变挤压你的老年代的空间。如果老年代的空间过小，那么就可能会触发我们的FullGC。所以新生代的选择一定要适当。然后我们的jvm给出的建议是在我们的堆空间的25以上，50%一下，可以适当进行调控。</li><li>合适的大小可以容纳所有的并发量*(请求-响应)的数据。</li><li>老年代的大小能保留(当前活跃对象+需要晋升对象)</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例:"></a>案例:</h2><p>1、FullGC和MinorGC频繁。可以适当的调大一下-Xmn新生代的大小。</p><p>2、就是我们的视频网站，因为采用断点续传的功能，所以需要将我们的视频切割成很多块，然后进行上传，上传之前会将我们的视频文件以IO流的形式存储在我们的服务器中，这样会造成一个问题就是。因为我们采用的jdk1.8，jdk1.8默认设置就是1000000字节，就相当于1m，那么我们的视频文件切割成文件就会以大对象的形式直接放入到我们的老年代中。这也就是我们常说的大对象会直接放入到我们的老年代中。如果一旦我们的视频上传过多，那么就有可能会出现FullGC。所以为了减少我们的FullGC我们的适当的调控了一下这个大对象的参数</p><p><font color="red">-XX:PretenureSizeThreshold&#x3D;1000000 </font></p><p>3、使用我们的arthas去查看我们的jvm相关的命令。使用dashboard查看我们系统的实时数据面板。</p><h2 id="12、内存溢出的问题"><a href="#12、内存溢出的问题" class="headerlink" title="12、内存溢出的问题"></a>12、内存溢出的问题</h2><ul><li>误用线程池导致的内存溢出 newThreadFixedThreadPool默认的是LinkedBlockingQueue的无界的任务队列，会导致我们的内存溢出。</li><li>使用线程池会导致我们的内存溢出。newCache.因为newCache里面最大线程数是integer的最大值。导致生成大量的线程。会导致内存溢出。</li><li>一次查询太多数据</li><li>类太多</li></ul><h2 id="13、类加载的过程"><a href="#13、类加载的过程" class="headerlink" title="13、类加载的过程"></a>13、类加载的过程</h2><p>1、加载:将类的字节码载入方法区中，内部采用的是c++的instanKlass描述java类。来进行初始化。如果这个类还有父类没有加载，先记载父类。</p><p>2、链接:</p><ul><li><p>验证:验证类是否符合JVM规范，安全性检查。</p></li><li><p>准备:为static变量分配空间，设置默认值。static变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在准备阶段完成。如果static变量是final的，但属于引用类型，那么赋值也会在初始化阶段完成。</p></li><li><p>解析:将常量池中的符号引用解析为直接引用。</p><ul><li>符号引用就是仅仅只是一个符号，它并不知道这个对象所处的内存地址。</li><li>解析和作用就是将这个符号引用变为直接引用，将这个符号位变成对象的内存地址。</li></ul></li></ul><p>3、初始化。</p><p>⚠️注意:</p><p>1、main方法所在的类，会首先初始化</p><p>2、首先访问这个类的静态变量或静态方法时</p><p>3、子类初始化，如果父类还没初始化，先初始化父类</p><p>4、子类访问父类的静态变量，只会触发父类的初始化</p><p>5、Class.forName</p><p>6、new 会导致初始化</p><p>不会导致类初始化的情况:</p><ul><li>访问类的static final静态变量（静本类型和字符串）不会触发初始化</li><li>类对象.class不会触发初始化</li><li>创建该类的数组不会触发初始化。</li><li>类加载的loadCLass方法</li><li>class.forname也不会导致初始化。</li></ul><h2 id="14、类加载器"><a href="#14、类加载器" class="headerlink" title="14、类加载器"></a>14、类加载器</h2><table><thead><tr><th align="left">名称</th><th align="left">加载哪都类</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Bootstrap ClassLoader</td><td align="left">JAVA_HOME&#x2F;jre&#x2F;lib</td><td align="left">无法直接访问</td></tr><tr><td align="left">Extension ClassLoader</td><td align="left">JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td align="left">上级为bootstrap,显示为null</td></tr><tr><td align="left">Application ClassLoader</td><td align="left">class path</td><td align="left">上级为Extension</td></tr><tr><td align="left">自定义类加载器</td><td align="left">自定义</td><td align="left">上级为Application</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h2 id="15、双亲委派模式"><a href="#15、双亲委派模式" class="headerlink" title="15、双亲委派模式"></a>15、双亲委派模式</h2><p>它是类记载器的加载类的一个规则。</p><p>一个类加载器查找class和resource时，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。</p><p>发现委拖时从下向上，然后具体查找过程却是自上至下。</p><p>如果找不到类的话，会抛出一个classNotfountException这个异常。</p><h2 id="16-怎么打破双亲委派机制"><a href="#16-怎么打破双亲委派机制" class="headerlink" title="16 怎么打破双亲委派机制"></a>16 怎么打破双亲委派机制</h2><p>1、使用我们的服务发现的机制,也就是我们的spi。</p><blockquote><p>SPI:ServiceLoader机制是一种服务发现机制。它会通过在classpath路径下的META-INF&#x2F;services文件夹去查找文件，自动记载文件所定义的类。</p><p>规则:jar包的META-INF&#x2F;services包下，以接口全限定名为文件，文件内容是实现类名称。</p></blockquote><p>2、使用线程上下文来进行破坏。只需要使用Thread.currentThread.getClassLoader进行加载。</p><p>3、自定义类加载器，继承classLoader类，重写loadClass方法，获取类文件的字节码。</p><h1 id="javase篇"><a href="#javase篇" class="headerlink" title="javase篇"></a>javase篇</h1><h2 id="1、java的基本数据类型"><a href="#1、java的基本数据类型" class="headerlink" title="1、java的基本数据类型"></a>1、java的基本数据类型</h2><p> 整数类型:byte、short、int、long</p><p>浮点类型:float、double</p><p>布尔类型:boolean</p><p>字符类型:char</p><p>类型转换:</p><ul><li>自动类型转换:<strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></li><li>转换从低级到高级。byte、short、char、int、long、float、double。</li><li>强制类型转换:从高转低，损失精度。byte -128～127 128最后结果是-128这就是损失了精度。</li><li>隐式类型转换:整数型会默认转换为int类型，浮点型会默认转换为我们的double。</li></ul><h2 id="2、JDK、JRE、JVM"><a href="#2、JDK、JRE、JVM" class="headerlink" title="2、JDK、JRE、JVM"></a>2、JDK、JRE、JVM</h2><p>1、JRE是java的运行环境，它包含我们的java程序运行所需的所有的环境。JRE只能运行程序，没有办法创建我们的java程序。</p><p>2、JDK是java开发的工具包，可以创建和运行我们的java程序。</p><p>3、jvm是java的虚拟机，我们将.java的源代码通过我们的javac命令将其编译成我们的字节码文件，放到jvm上进行运行。</p><p>三者之间的关系:</p><p>JRE包含JVM、JDK包含我们的JRE。</p><h2 id="3、java的进制之间的转换"><a href="#3、java的进制之间的转换" class="headerlink" title="3、java的进制之间的转换"></a>3、java的进制之间的转换</h2><p>1、在java中使用0b来表示二进制、8进制采用9来进行表示、16进制使用0x来进行表示。</p><p>2、二进制转换成十进制</p><p>底层的位数*2 的位数-1的次方</p><p>例子: 10  0*2^1-1+1*2^2-1&#x3D;2</p><p>3、8进制转换成10进制</p><p>8进制转十进制也是从低位开始，底位数*8(位数-1)的次方</p><p>例子:45<br>  5*8^1-1+4*8^2-1&#x3D;37</p><p>4、16进制转换成10进制</p><p>十六进制转十进制也是从低位开始，底位数*16(位数-1)的次方</p><p>16进制到10之后使用a、b、c、d、e、f表示</p><p>1413 十六进制是0xed</p><p>例子:13+14*16^2-1&#x3D;237  </p><p>5、十进制转换二进制</p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230403161345968.png" alt="image-20230403161345968" style="zoom:50%;" /><p>十进制转换成二进制就是不断的除以2，直到商为0，然后将每步得到的余数倒过来，就是对应的二进制数</p><p>6、十进制转8进制</p><p>十进制转换成8进制就是不断的除以8，直到商为0，然后将每步得到的余数结果倒过来即可得到8进制。</p><p>7、10进制转十六进制是一样的。</p><p>8、二进制转8进制<br>规则:从低位开始,将二进制数每三位一组，转成对应的八进制即可。<br>案例: 0b 11 010 101 转成八进制<br>101 5  010 2 11 3 所以是0325</p><h2 id="4、源码、反码、补吗"><a href="#4、源码、反码、补吗" class="headerlink" title="4、源码、反码、补吗"></a>4、源码、反码、补吗</h2><p>1、二进制的最高位是符号位:0表示正数，1表示负数</p><p>2、正数的原码、反码、补码都一样(三码合一)</p><p>3、负数的反码&#x3D;它的原码符号位不变，其他位取反</p><p>4、负数的补吗&#x3D;它的反码+1，负数的反码&#x3D;负数的补吗-1</p><p>5、0的反码，补吗都是0</p><p>6、java没有无符号位，换言之，java中的数都是有符号的</p><p>7、在计算机运算的时候，都是以补吗的方式来运算的。</p><p>8、当我们看运算结果的时候，要看他的原码。</p><h2 id="5、位运算"><a href="#5、位运算" class="headerlink" title="5、位运算"></a>5、位运算</h2><p>按位与&amp;：两边全为1，结果为1，</p><p>按位或|:两位有一个为1，结果为1，否者为0.</p><p>按位异或^：两位一个为0、一个为1，结果就为1，否者为0.</p><p>按位取反～:0-&gt;1、1&gt;0</p><p>右位运算符 &#x2F;2 2&gt;&gt;2 2&#x2F;2&#x2F;2 &#x3D;0<br>&lt;&lt; 左位运算符 <em>2 2&lt;&lt;2 2</em>2*2 8<br>3&amp;4 计算过程<br>00000000 00000000 00000000 00000011 原码 3 三码和一<br>                            &amp;<br>00000000 00000000 00000000 00000100<br>00000000 00000000 00000000 00000000  补码要转成原码 结果为0</p><h2 id="6、访问修饰符"><a href="#6、访问修饰符" class="headerlink" title="6、访问修饰符"></a>6、访问修饰符</h2><p>1、public:表示公开，可以被任意类访问。可以修饰的对象:对象、方法、属性、接口</p><p>2、private:表示私有的，只能被当前类中进行使用。使用的对象:方法、属性</p><p>3、protected:表示受保护的，只能被当前包下的类和其子类进行访问。使用的对象:方法、属性</p><p>4、default:表示默认，只能被当前包下的其他类进行访问，不实用任意的修饰符。使用对象:类、方法、接口、属性</p><h2 id="7、break、continue、return的区别及作用"><a href="#7、break、continue、return的区别及作用" class="headerlink" title="7、break、continue、return的区别及作用"></a>7、break、continue、return的区别及作用</h2><p>1、break是跳出循环</p><p>2、continue:跳出本次循环，进入下一次循环</p><p>3、return:返回，方法的返回结果。后续不再执行。</p><h2 id="8、final、finally、finalize的区别"><a href="#8、final、finally、finalize的区别" class="headerlink" title="8、final、finally、finalize的区别:"></a>8、final、finally、finalize的区别:</h2><p>final:表示最终，不可修改的。</p><p>final修饰的类，表示该类不可被继承。</p><p>final修饰的方法，表示该方法不能重写。</p><p>final如果修饰的属性，如果是基本数据类型，一旦赋值，不允许发现更改。</p><p>如果修饰的引用数据类型的话，那么一旦进行复制也会导致我们的引用不可变。但是我们的引用中的值可以改变的。</p><p>final一般和我们的static联合起来一起使用。一般我们用来修饰常量。</p><p>finally:主要和我们的try、catch联合使用。表示最终一定会执行的。不管有没有发生异常都是会被执行的。经常用于释放各种资源。</p><p>Finalize：是object中的方法，这个方法会在gc启动时，该对象被回收时进行调用。</p><h2 id="9、Object中的常用方法"><a href="#9、Object中的常用方法" class="headerlink" title="9、Object中的常用方法"></a>9、Object中的常用方法</h2><p>1、toString：将我们其他的类型转换成我们的String类型</p><p>2、equals:比较两个对象是否相等。</p><p>3、clone：克隆对象，但是时浅拷贝。</p><p>4、hashCode：是根据我们的内存地址通过hash得来的，主要用于集合中的哈希表。通过取模获取哈希桶的下标。</p><blockquote><p>HashCode和equals为什么要都进行重写:</p><p>equals因为object中的方法是直接使用的&#x3D;&#x3D;的方法来进行比较，它比较多内存地址。我们的日常的比较通常是比较两个对象是否相等。如果不重写的话，那么比较多就是内存地址。重写了才会去比较我们的对象的内容。</p><p>HashCode为什么需要重写呢，因为我们的hashCode是基于我们的对象的内存地址，然后通过我们的hash算法得来的。主要的作用hashmap会通过我们的hashcode然后取模得到我们的数组的下标。从而可以提高我们的效率。</p><p>为什么需要同时重写呢?</p><p>1、就是因为我们对比两个对象是否相等时，我们就可以先使用的我们的HashCode进行比较，如果比较的结果是true，那么就可以使用equals再次确认两个对象是否相等，如果比较的结果是true。那就相等。这样可以提高我们的比较效率。</p><p>2、set集合正常使用就是保存不同的对象，相等的对象就会被我们的set进行合并，最终留下一份独一无二的数据。如果我们的对象重写了equlas方法，当没有重写我们的hashCode方法时，就会出现一个问题就是我们的set并没有进行去重。因为我们并没有重写我们的hashCode，所以默认使用的还是我们的object中的hashCode。而Object中的hashCode方法比较的是不同引用地址的对象，所以结果是 false。那么就不会执行我们的equals方法了。</p></blockquote><p>5、wait、notifyAll主要的作用就是让当前线程去进行休眠。然后通过我们的notifyAll的进行唤醒。这样就可以起到我们的线程之间的通信。wait和notify必须和我们的synchronized一起使用。</p><p>6、finalize:当我们的垃圾回收该对象的时候，会去调用一下这个方法。这个方法主要的作用应该就是起到了一个通知的作用。但是已被标记为废弃的方法。</p><p>7、getClass，通过这个方法可以获取到对象对应的class对象。</p><h2 id="10-static关键字作用"><a href="#10-static关键字作用" class="headerlink" title="10 static关键字作用"></a>10 static关键字作用</h2><p>1、什么是static</p><p>static在我们的java程序中，被称为静态的。表示是属于我们的类的，而不是属于我们的对象的。当我们的一个属性被static进行修饰时，会在我们的类加载时，为其进行赋值操作。如果是引用的话，会在初始化阶段进行赋值。如果是基本数据类型，就会在准备阶段为其进行赋值。被我们static进行修饰的属性会被放到我们的方法区。</p><p>2、怎么用:</p><p>一般情况static和我们的final一起进行使用，用来修饰常量。还有就是在使用我们的简单工厂模式的时候，为了使用方便，会将工厂方法标注成我们的static。</p><p>可以用来修饰我们的属性、方法。修饰的属性叫做静态成员变量。修饰方法就叫做我们的静态方法。</p><blockquote><p>静态变量和我们实例变量的区别?</p><p>1、静态变量不属于我们的对象的，属于我们的类，所以在内存中只会存在一份。类记载的过程中，准备阶段会为其进行空间的分配，然后为其进行赋值操作。如果是使用final修饰的引用的话，会在初始化阶段，为其进行赋值操作。</p><p>2、实例变量是我们的对象，每次当我们去创建该对象时，jvm才会在堆内存中为其开辟空间，进行赋值操作。在java中可以存在多份的。</p></blockquote><h2 id="11、java的代码执行顺序"><a href="#11、java的代码执行顺序" class="headerlink" title="11、java的代码执行顺序"></a>11、java的代码执行顺序</h2><p>1、基本上的代码块分为:静态代码块、构造代码块、普通代码块.</p><p>2、代码块的顺序:静态代码块—&gt;构造代码块—-&gt;普通的代码块</p><p>3、继承中代码执行顺序:父类的静态代码块、子类的静态代码块、父类的代码块、父类的构造器、子类的代码块、子类的构造器。</p><h2 id="12、面向对象的特征"><a href="#12、面向对象的特征" class="headerlink" title="12、面向对象的特征"></a>12、面向对象的特征</h2><p>1、封装:将对象中的一些复杂的属性和方法进行封装，不对外界暴露一些实现细节。</p><p>作用:屏蔽复杂、暴露简单。</p><p>通常对使用：就是使用我们的private进行修饰，然后通过我们的get、set方法对外进行暴露，供外界进行操作。</p><p>2、继承:就是子类继承我们的父类，可以获取我们的父类中的属性和方法。并且父类中的方法不满足我们的需要可以对其进行重写。继承比较多作用就是可以让我们的代码进行复用。减少了一些重负代码的编写。比如说像我们的设计模式中的模版设计模式，就是使用我们的继承。通过继承我们模版抽象方法，去实现我们里面的抽象方法，而从得到我们的模版方法得到我们复用。然后对一些需要改变的方法，可以进行重写。这就是我们的继承的作用。还有一大作用就是的多态。</p><p>3、多态:同一类型的对象，执行同一个行为，在不同的状态下会表现出不同的行为特征。</p><p>多态分为:编译时多态和运行时多态</p><p>编译时多态:在编译时的时候，可以发生多种状态,一般的实现形式就是方法重载。</p><p>运行时多态:在多态中需要将子类的引用赋值给父类对象，只有这样的引用才能既可以调用父类的方法，又能调用子类的方法。</p><blockquote><p>私有方法和静态方法能被重写吗?</p><p>不能。私有方法只能在本类中进行使用，你没有办法在子类中使用父类的私有方法。</p><p>静态时属于父类的，并没有继承给子类，都没有继承，何来的重写呢？</p></blockquote><h2 id="13、重载和重写"><a href="#13、重载和重写" class="headerlink" title="13、重载和重写"></a>13、重载和重写</h2><p>方法重载：指同一个类中的多个方法具有相同的名字,但这些方法具有不同的参数列表,即参数的数量或参数类型不能完全相同<br>方法重写：存在子父类之间的,子类定义的方法与父类中的方法具有相同的方法名字,相同的参数表和相同的返回类型 </p><p>重写的规则:<br> 　1. 参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。<br> 　2. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。<br> 　3. 返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。<br> 　4. 访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</p><p>重载的规则：</p><ul><li>必须具有不同的参数列表；</li><li>可以有不责骂的返回类型，只要参数列表不同就可以了；</li><li>可以有不同的访问修饰符</li><li>可以抛出不同的异常</li></ul><blockquote><p>构造器是否可被重写<br>构造器不能被继承，因此不能被重写，但可以被重载。每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须一开始调用父类的构造函数。</p></blockquote><h2 id="14-抽象类和接口的区别是什么？"><a href="#14-抽象类和接口的区别是什么？" class="headerlink" title="14 抽象类和接口的区别是什么？"></a>14 抽象类和接口的区别是什么？</h2><p>相同点:</p><p>1、抽象类和接口都可以存在我们的抽象方法。</p><p>2、抽象类和接口都不能创建对象。</p><p>不同点:</p><p>1、抽象类中可以存在普通的成员方法、接口中载jdk1.8之后，可以存在default方法。</p><p>2、抽象可以声明成员变量，而接口中声明的成员变量都是常量。</p><p>3、接口中不能含有静态代码块以及静态方法，抽象类可以有静态代码块和静态方法。</p><p>4、一个接口可以被多次实现，一个抽象类只能被继承一次。</p><p>注意:定义抽象类就是让其他类继承，所以不能使用final进行修饰。</p><h2 id="15、java创建对象的几种方式"><a href="#15、java创建对象的几种方式" class="headerlink" title="15、java创建对象的几种方式"></a>15、java创建对象的几种方式</h2><p>1、第一中是通过我们的new关键字去进行创建。</p><p>2、使用我们Object中的clone方法进行克隆。</p><p>3、使用序列化和反序列化。使用ObjectOutputStream的流进行序列化。</p><p>4、使用我们的反射去创建我们的对象，通过class对象的newInstance静态方法调用无参的构造器创建对象。</p><h2 id="16、浅拷贝和深拷贝的区别"><a href="#16、浅拷贝和深拷贝的区别" class="headerlink" title="16、浅拷贝和深拷贝的区别"></a>16、浅拷贝和深拷贝的区别</h2><p>浅拷贝是将对象的进行拷贝，但是这个对象如果存在一些引用对象，不会进行克隆的，而是直接使用原对象的同一份数据。</p><p>深拷贝是指将对象进行克隆，但是会将这个对象中的其他引用对象，也会进行克隆。</p><blockquote><p>浅考贝的话直接使用我们实现我们的Cloneable，实现我们的方法clone方法。在里面直接使用super()调用即可完成浅拷贝。</p><p>深拷贝:要使用的我们的ObjectOutputStream来进行序列化。</p></blockquote><h2 id="17、值传递和引用传递的区别是什么"><a href="#17、值传递和引用传递的区别是什么" class="headerlink" title="17、值传递和引用传递的区别是什么"></a>17、值传递和引用传递的区别是什么</h2><p>1、值传递指的是方法调用时，传递的参数是按值的拷贝传递的，传递的值的拷贝，也就是传递后就互不相关了。</p><p>2、引用传递指的是在方法调用时，传递的参数时按引用进行传递，其实传递的是引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是传递前和传递后都指向同一个引用空间。</p><p>基本数据类型作为参数被传递肯定是值传递，引用类型做参数被传递也是我们的值传递，只不过是传递的引用所指向的内存地址。</p><h2 id="18、-x3D-x3D-和equals的区别"><a href="#18、-x3D-x3D-和equals的区别" class="headerlink" title="18、&#x3D;&#x3D;和equals的区别"></a>18、&#x3D;&#x3D;和equals的区别</h2><p>&#x3D;&#x3D;比较的基本的是基本数据类型，比较的是值，如果是比较的引用数据类型，那么比较的就是其内存地址是否相同。<br>equals,如果没有被重写，那么它底层使用的就是&#x3D;&#x3D;，如果有被重写，那么它判断就是两个对象的内容是否相等。</p><p>hashCode就是获取哈希码。也称为散列码。返回一个int整数。</p><p>hashCode和equals的关系就是:<br>如果hashCode值相等，那么这两个对象可能相同。<br>如果hashCode的值不相等，那么这两个对象肯定不相等。</p><h2 id="19、String为什么被设计成不可变"><a href="#19、String为什么被设计成不可变" class="headerlink" title="19、String为什么被设计成不可变"></a>19、String为什么被设计成不可变</h2><p>1、便于实现字符串常量池(String pool)</p><p>在java程序中，String被大量使用，如果每次声明一个String都去创建一个对象，那么将会造成极大的资源浪费。java中提出了字符常量池的概念来进行解决。就是创建一个常量池，将字符串放入其中，对已存在的字符串，直接服用即可就可以，没必要再去创建对象。</p><p>2、线程安全，因为String是不可变得。</p><p>3、避免安全问题。</p><p>因为在web开发中很多场景都使用了String做参数，比如一些url、路径地址之类都是使用String做为参数。将其设计成不可变对象，在一定程度上保证了程序的安全。</p><p>4、加快了字符串的处理速度。</p><p>由于字符串不可变，保证了HashCode的唯一性，于是在创建的对象时hashCode就可以放心的缓存了，不需要在重新计算。这也是我们map会为什么会喜欢将key选为String的原因。</p><h2 id="20、String、StringBuilder、StringBuffer"><a href="#20、String、StringBuilder、StringBuffer" class="headerlink" title="20、String、StringBuilder、StringBuffer"></a>20、String、StringBuilder、StringBuffer</h2><p>1、String是不可变的，因为其底层使用的是一个byte[]类型的数据，使用private final进行修饰。并没有提供对外进行操作的方法，所以没有办法对其进行修改。所以说String是不可变的。</p><p>2、StringBuilder和StringBuffer一个是线程不安全的，一个是线程安全的。这两个类都是用于字符串拼接的。都是使用apppend方法进行字符串拼接。但是因为我们的StringBuufer里面的方法使用的是synchronized简单的进行修饰，解决了线程安全问题，但是锁的粒度，很大。很耗费性能。</p><p>3、StringBuilder是非线程安全的。所以平常都是使用StringBuilder来拼接字符串。只能保证了在方法里面，不要超出方法的作用域，一般是不会出现线程安全的问题的。</p><h2 id="21、String的比较"><a href="#21、String的比较" class="headerlink" title="21、String的比较"></a>21、String的比较</h2><p><img src="https://cdn-a.markji.com/files/63e86bb86851df0522d3f23f_hd.png?e=1680517495782&token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:gJr3YWOwWn-4uqo2SNENRuEUqZc=" alt="img"></p><p>new String(“aaa”)与String str&#x3D;”aaa” 创建了几个对象。</p><p>new String一个对象，会在heap堆中分配空间存放新对象,同时会将”aaa”字符串放入常量池，相等于创建了两个对象。<br>String str&#x3D;”aaa”; 程序运行中会在字符常量池中查找”aaa”字符串，若没有,会将“aaa”字符串放进常量池,再将其地址赋给str.若有,将找到的”aaa”字符串的地址赋给a。</p><p>intern函数的作用是将对应的符号常量进入特殊处理，在DK1.6以前和JDK1.7以后有不同的处理；<br>在到DK1。6中，intern的处理是先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量，如果没有找到，则将该字符串常量加入到字符串常量区，也就是在字符串常量池中建立该常量；<br>在到JDKI1.7中，intern的处理是先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量，如果没有找到，说明该字符串常量在堆中，则处理是把堆区该对象的引用加入到字符串常量池中， 以后别人拿到的是该字符串常量的引用，实际存在堆中。</p><h2 id="22、包装类和基本数据类型"><a href="#22、包装类和基本数据类型" class="headerlink" title="22、包装类和基本数据类型"></a>22、包装类和基本数据类型</h2><p>1、包转类是引用数据类型，作用就是将我们的基本数据类型包转成引用数据类型，然后可以使用引用数据类型里面的方法。</p><p>2、java的容器类，只能存储我们的引用数据类型，不能存储我们的基本数据类型的。所以需要将基本数据类型转换成引用数据类型。</p><p>3、包转类型转换成基本数据类型成为拆箱，将基本数据类型转换成引用数据类型称为装箱。</p><p>4、基本数据存在默认值。而我们的包转类型的默认值是null。但是我们的数据库里的数据可能为null，如果使用基本数据类型的话，会进行拆箱操作。有可能会抛出为的NullPointException异常。</p><h2 id="23、String中常用的方法"><a href="#23、String中常用的方法" class="headerlink" title="23、String中常用的方法"></a>23、String中常用的方法</h2><p>chatAt:返回索引处的字符。参数是一个int整数、返回值是一个char类型</p><p>compareTo:比较两个字符串是否相等。参数是一个字符串</p><p>1、如果指定的数与参数相等返回0。</p><p>2、如果指定的数小于参数返回 -1。</p><p>3、如果指定的数大于参数返回 1。</p><p>equals比较的是两个字符串是否相等。</p><p>endsWith:是否以这个字符串结尾。参数是一个字符串，返回值是一个boolean类型。</p><p>startsWith:是否以这个字符串为开头，参数也是一个字符串，返回值是一个boolean类型。</p><p>equalsIgnoreCase:不区分大小的比较。</p><p>indexOf:返回第一次出现在字符串中的索引地址。</p><p>replace:替换我们的字符串对象。参数为两个char类型，一个是原字符串中的字符，一个要替换的字符。</p><p>lastIndexOf：最后一次出现在字符串中的索引位置。</p><p>subString:截取字符串。参数是一个int类型，从那开始.</p><p>Split:将字符串以某个格式进行分割，返回新的字符数组。</p><h2 id="24、类型之间的转换"><a href="#24、类型之间的转换" class="headerlink" title="24、类型之间的转换"></a>24、类型之间的转换</h2><p>Integer转换成String字符串类型:使用toString。</p><p>String类型转换成字符串使用Integer.parseInt来进行转换</p><h2 id="25、int和Integer的有什么区别"><a href="#25、int和Integer的有什么区别" class="headerlink" title="25、int和Integer的有什么区别"></a>25、int和Integer的有什么区别</h2><p>integer是int的类型的包装类，int是数据数据类型。</p><p>integer变量必须实例化才能使用，int变量不需要。</p><p>integer实际是对象的引用，指向此new的Integer对象，int是直接存储就是我们的数值。</p><p>Integer的默认值是null，int的默认值是0.</p><p>扩展:</p><p>Integer变量和int变量的对比</p><p>Integer变量和int变量比较时,只要两个变量的值是相等的，则结果为true</p><p>因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int,然后进行比较，实际上就变味了两个int变量的比较。</p><p>两个非new生成的Integer对象的对比</p><p>对于两个非new生成的Integer对象,进行比较时,如果两个变量的值在区间-128~127之间,则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p><h2 id="26、反射"><a href="#26、反射" class="headerlink" title="26、反射"></a>26、反射</h2><p>反射是在运行状态下，动态的获取任意一个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性;这种动态获取的信息以及动态调用对象的方法的功能称为java的反射。</p><p>反射的优缺点有哪些?</p><p>优点：能够运行时动态获取类的实例,提高灵活性,可与动态编译结合</p><p>缺点:使用反射性能较低,需要去解析我们的字节码文件，将内存中的对象进行解析。所以它的性能会有所降低。<br>其解决方案是:通过setAccessible(true)关闭jdk 的安全检查来提升反射速度。</p><h2 id="27、如何获取反射中的class对象"><a href="#27、如何获取反射中的class对象" class="headerlink" title="27、如何获取反射中的class对象"></a>27、如何获取反射中的class对象</h2><p>1、通过Class.forName(“类的权限定路径”)</p><p>2、第二种通过对象名.class的方式也可以获取我们的Class对象</p><p>3、可以通过我们的对象的getClass，也可以获取我们的Class对象。</p><p>4、如果是基本数据类型的包装类，可以使用包装类的TYPE属性，来获取我们的Class对象。</p><pre class=" language-java"><code class="language-java">        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"字符串/User.java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span>User<span class="token operator">></span> userClass <span class="token operator">=</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">User</span><span class="token operator">></span> aClass1 <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span>Integer<span class="token operator">></span> type <span class="token operator">=</span> Integer<span class="token punctuation">.</span>TYPE<span class="token punctuation">;</span></code></pre><h2 id="28、java中的反射api"><a href="#28、java中的反射api" class="headerlink" title="28、java中的反射api"></a>28、java中的反射api</h2><p>java反射API的有几类</p><p>1、Class类:反射的核心类,可以获取类的属性、方法等信息</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//class类，反射的核心api</span>        <span class="token comment" spellcheck="true">//第一种直接通过对象的class来获取我们的核心api</span>        Class<span class="token operator">&lt;</span>Student<span class="token operator">></span> studentClass <span class="token operator">=</span> Student<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        第二种使用我们的对象的</span>        Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Student</span><span class="token operator">></span> aClass <span class="token operator">=</span> student<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//第三种是forName来获取我们的class对象</span><span class="token comment" spellcheck="true">//        Class&lt;?> aClass1 = Class.forName("反射/Student.java");</span>        <span class="token comment" spellcheck="true">//获取它的字节码的文件名 获取的权限定路径名</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>studentClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//类载器</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>studentClass<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//</span>            <span class="token punctuation">}</span></code></pre><p>2、Field类:反射包下的类，表示类的成员变量，可以用来获取和设置类之中的属性值</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//      获取我们的成员属性</span>        Field field <span class="token operator">=</span> studentClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"stuNo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取我们的属性名</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//通过我们的newInstance来创建我们的对象</span>        Student student1 <span class="token operator">=</span> studentClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//set设置我们的成员属性</span>        field<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>student1<span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//get获取我们的成员属性</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>student1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>3、Method类:反射包下的类,表示类的方法，它可以用来获取类中的方法信息或执行方法。invoke方法，可以执行方法。</p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//获取所有的方法</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> declaredMethods <span class="token operator">=</span> studentClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Method method <span class="token operator">:</span> declaredMethods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//获取class中的方法，第一参数是方法的名称，第二个参数是我们的传入的参数类型</span>        Method method <span class="token operator">=</span> studentClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"setName"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//使用invoke执行我们的方法,第一个参数表示是那个对象，因为我们的方法和属性是属于我们对象的，必须先创建出对象，才能去调用他们。</span>        <span class="token comment" spellcheck="true">//        第二个参数，你要执行的方法，传入的参数</span>        method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>student1<span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>4、Constructor类,可以用来类的构造器方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取我们的constructor 参数是我们的构造器的参数的类型</span>        Constructor<span class="token operator">&lt;</span>Student<span class="token operator">></span> constructor <span class="token operator">=</span> studentClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//构造器的名称</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>constructor<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调用我们的构造器</span>        Student student2 <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="29、反射的作用"><a href="#29、反射的作用" class="headerlink" title="29、反射的作用"></a>29、反射的作用</h2><p>1、反射让开发人员通过外部类的全限定路径名创建对象。并使用这些类，实现一些扩展的功能。</p><p>2、反射能提高程序的灵活性。</p><p>具体的应用:</p><p>1、加载JDBC的驱动</p><p>2、Spring的Bean的加载并创建。</p><h2 id="30、java中的泛型的作用"><a href="#30、java中的泛型的作用" class="headerlink" title="30、java中的泛型的作用"></a>30、java中的泛型的作用</h2><p>什么是泛型？</p><p>泛型主要是用于规范我们的集合的类型。如果没有泛型的话，我们不管是什么类型的对象存储到集合中，都会转化为我们的Object类型。如果进行取出的话也会是Object类型。这样如果发生转化的话，就会出现一些类型转换异常。</p><p>泛型是一种语法糖，泛型这种类的基本原理就是我们的泛型擦除。java泛型基本都是在编译阶段这个层面来进行实现，也就是说:泛型只存在编译阶段，而不存在我们的运行阶段。在编译后的class文件中，是没有泛型这个概念的。</p><p>泛型擦除:使用泛型的时候加上的类型的参数，编译器在编译的时候去掉类型的参数。</p><p>泛型的作用:</p><p>1、规范我们集合的类型，在我们创建这个集合的时候，就可以根据我们的泛型去规定我们集合中的元素的类型。</p><p>2、避免我们的类型转换异常，就是如果我们不使用泛型的话，存进集合中的对象都会转换成Object类型，取出还是Object类型。如果发型类型转换，有可能会报类型转换错误。</p><p>3、增加了程序的可读性。</p><h2 id="31、泛型中的限定通配符和非限定通配符"><a href="#31、泛型中的限定通配符和非限定通配符" class="headerlink" title="31、泛型中的限定通配符和非限定通配符"></a>31、泛型中的限定通配符和非限定通配符</h2><p>1、限定通配符对类型进行了限制。有两种限定通配符，</p><p>一种是&lt;？extends T&gt;它通过确保类型必须是T的子 类来设定类型的上界。</p><p>另一种是&lt;？super T&gt;它通过确保类型必须是T的父类来设定类型的下界。</p><p>泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。</p><p>2、非限定通配符？，可以用任意类型来替代。如Lst&lt;?&gt;的意思是这个集合是一个可以持有任意类型的集合，它可以是List<A>，也可以是List<B>，或者List<C>等等。</p><h2 id="32、java的序列化和反序列化"><a href="#32、java的序列化和反序列化" class="headerlink" title="32、java的序列化和反序列化"></a>32、java的序列化和反序列化</h2><p>1、将java对象转换成字节码进行输出，这就是我们的序列化</p><p>2、反序列化是指将我们的文件转换成我们的java对像。</p><p>3、序列化:序列化是把对象转换成有序字节流,以便在网络上传输或者保存在本地文件中。</p><p>核心作用是对象的保存和重建。我们知道java中的对象都是保存在我们的heap中的，一旦java heap不存在了，那么我们的java对象也就跟着消失了，而序列化提供了我们一种机制，就是可以将java对象转换成有序字节流存储在文件中，保存到磁盘。进行持久化保存。当我们需要的时候，重新进行加载即可。</p><p>4、反序列化:客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p><h2 id="33、为什么需要序列化和反序列化"><a href="#33、为什么需要序列化和反序列化" class="headerlink" title="33、为什么需要序列化和反序列化"></a>33、为什么需要序列化和反序列化</h2><p>1、对象序列化可以实现分布式对象</p><p>2、java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据</p><p>可以使用java序列化来完成对象的深拷贝，因为java的序列化，不仅会将当前对象进行序列化，而且会将我们对象中引用的对象也进行序列化。</p><p>3、序列化可以将内存中的类写入文件或数据库中</p><p>4、对象、文件、数据有许多不同的格式，很难统一传输和保存</p><p>序列化的实现方式:</p><p>1、需要将我们序列化的对象实现我们的Serializable加上我们的版本号。</p><p>2、有一些属性不需要序列化的话，可以使用我们的Transent来进行标注。</p><p>为什么需要我们的版本号:</p><p>就是因为我们java序列化的时候，会将我们的版本号一起序列化出去，如果不写，jvm会自动帮我们生成一个序列化uid，然后与属性一起进行序列化。在反序列化的时候，会先比较我们的版本号是否一致，如果一致，进行反序列化。如果不一致会报完名的序列化不一致异常。</p><h2 id="34、Java中的异常"><a href="#34、Java中的异常" class="headerlink" title="34、Java中的异常"></a>34、Java中的异常</h2><blockquote><p> 什么是异常?</p><p>就是指java程序运行过程中出现了错误，就是发生了异常。</p><p>在java中异常是一个类的形式来表示的。</p><p>在java程序中，出现了问题，jvm会直接new出一个对应的异常类，然后打印这个异常信息到我们 控制态上。</p></blockquote><p>1、java中所有的异常都有一个共同的祖先Throwable，Throwable类下有两个重要的子类:Exception类和Error类。</p><p>2、Exception和Error二者是java异常处理的重要子类，各自包含大量子类。</p><p>3、Exception:程序本身可以处理的异常，可以通过catch来进行捕捉，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</p><p>4、Error:属于程序无法处理的错误，我们没有办法通过catch来进行捕获。例如:内存空间不足、系统崩溃等。编译器不会这这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本省无法恢复。</p><p><img src="https://img2020.cnblogs.com/blog/2057228/202007/2057228-20200706221142157-1058203780.png" alt="异常结构"></p><h2 id="35、非受检查异常和受检异常的区别是什么"><a href="#35、非受检查异常和受检异常的区别是什么" class="headerlink" title="35、非受检查异常和受检异常的区别是什么?"></a>35、非受检查异常和受检异常的区别是什么?</h2><p>1、是我们的Exception下面的子类。分为Check Exceptions和UnCheckExceptions两个类。</p><p>2、非受检查异常表示:在jvm运行期间可能会发生异常。java编译器不会检查这些异常。所以可以在编译阶段，不对其进行处理。常见的异常有:NullpointException、NumberformartException、数组下标越界、ClasscastException类型转换异常。</p><p>3、受检异常:表示jvm在运行期间一定会发生异常，所以要求我们在java编写阶段，要进行处理，使用try-catch和我们throw进行处理，都是可以的。但是一定要处理。常见的受检异常包括:SQLException、ClassNotFoundException、IOException。</p><p>4、区别:就在于是否需要在编译阶段强制要求我们进行处理，要求的就是我们的编译异常，不要求的就是非受检查异常。</p><h2 id="36、thorw和throws的区别是什么"><a href="#36、thorw和throws的区别是什么" class="headerlink" title="36、thorw和throws的区别是什么"></a>36、thorw和throws的区别是什么</h2><p>在java程序中只有两种处理异常的方式，一种使用try和catch进行捕捉，</p><p>一种是进行抛出，让它的调用者来进行处理。可以使用thorws可以使用在方法上进行抛出，throw只能在方法里面进行抛出。</p><p>throw在方法中进行抛出，但是只能抛出一种异常。thorws在方法上进行抛出，可以抛出多个异常。</p><h2 id="37、NotClassDefoundError和ClassNotFoundException的区别"><a href="#37、NotClassDefoundError和ClassNotFoundException的区别" class="headerlink" title="37、NotClassDefoundError和ClassNotFoundException的区别?"></a>37、NotClassDefoundError和ClassNotFoundException的区别?</h2><p>NotClassDefoundError是一个错误，在java程序中，错误是没有办法进行处理，必须由程序员手动的进行更改才可以。该错误的产生的原因是类加载错误，也就是jvm在尝试去加载这个类的时候，没有找到该类。那么在运行时就会抛出该错误。</p><p>ClassNotFoundException是一个异常，可以使用trycatch进行处理，或者使用throw进行抛出处理。异常产生的原因就是: 通过我们的反射去加载该类的时，没有找打该类。那么机会抛出这个异常。</p><h2 id="38、try、catch、finally那部分可以省略？"><a href="#38、try、catch、finally那部分可以省略？" class="headerlink" title="38、try、catch、finally那部分可以省略？"></a>38、try、catch、finally那部分可以省略？</h2><p>catch可以省略.更为严格的说法就是:try只适合处理运行时异常,try+catch适合处理运行时异常+普通异常。也就是说，如果你只使用处理普通异常却不加以catch处理，编译时不通过。因为编译器硬性规定，普通异常如果选择捕获，则必须加上catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以可以省略,你加上catch编译器也觉得无可厚非。</p><p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须 用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕 获以便进一步处理。<br>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾“处理。</p><p>至于加上finally，则是不管有没有捕捉异常，都要进行的扫尾处理。</p><h2 id="39、try-catch-finally中，如果catch中return了finally还会执行吗"><a href="#39、try-catch-finally中，如果catch中return了finally还会执行吗" class="headerlink" title="39、try-catch-finally中，如果catch中return了finally还会执行吗?"></a>39、try-catch-finally中，如果catch中return了finally还会执行吗?</h2><p>还是会执行的。会在return之前执行。</p><p>在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马进行返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值,然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finllay中返回或者修改返回值会对程序造成很大的困扰，java中也可以通过提升编译器的语法检查级别产生警告或错误。</p><h2 id="40、jvm如何处理异常"><a href="#40、jvm如何处理异常" class="headerlink" title="40、jvm如何处理异常?"></a>40、jvm如何处理异常?</h2><p>在一个执行过程中，如果一个方法发生了异常，就会创建一个异常对象，并转交给jvm，该异常对象包含异常名、异常信息、以及异常发生时应用程序的状态。创建异常对象并交给jvm的过程称为抛出异常。可以有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p><p>jvm会顺着调用栈去查找看是否可以处理异常的代码，如果有，则调用异常处理代码。当jvm发现可以处理异常的代码时，会把发生的异常传递给它。如果jvm没有找到可以处理该异常的代码块，jvm就会将该异常转交给默认的异常处理器，默认异常处理器打印异常信息并终止应用程序。</p><h2 id="41、Java中IO流"><a href="#41、Java中IO流" class="headerlink" title="41、Java中IO流"></a>41、Java中IO流</h2><p>1、java中的按照流的方法分为:输入(intputStream)、输出(OutputStream)</p><p>2、按照实现功能的分为:节点流(可以从或向一个特定的地方读写数据，如FilReader)和处理流(是一个以存在的流的连接和封装,通过所封装的流的功能调用实现数据读写BufferedReader)</p><p>3、按照处理数据的单位:字节流、字符流.分别是四个抽象类来表示：InputStream、OutputStream、Reader、Writer.java中其他多种多样的流都是从它们派生出来的。</p><p>字节流如何转换为字符流</p><p>字节输入流转字符输入流通过InputStreamReader实现，该类的构造函数可以传入InputStream对象。<br>字节输出流转字符输出流通过OutputStreamWriter实现，该类的构造函数可以传入OutputStream对象。</p><h2 id="42-、字符流与字节流的区别"><a href="#42-、字符流与字节流的区别" class="headerlink" title="42 、字符流与字节流的区别:"></a>42 、字符流与字节流的区别:</h2><p>读写的时候字节流是按字节读写，字符流按字符读写。</p><p>字节流适合所有类型文件的数据传输，因为计算机字节(Byte)是电脑中表示信息含义的最小单位。字符流只能够处理纯文本数据，其他类型数据不行，但是字符流处理文本要比字节流处理文本要方便。</p><p>在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流 。只是读写文件，和文件内容无关时，一般选择字节流。</p><h2 id="43、IO流中常用流"><a href="#43、IO流中常用流" class="headerlink" title="43、IO流中常用流"></a>43、IO流中常用流</h2><p>1、文件专属<br>Java.io.FileInputStream 字节输出流</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"/Users/kevintam/project/Review-Java/Day-1/src/main/java/IO流/date.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> temp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>temp<span class="token operator">=</span>fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>Java.io.FileOutputStream 字节的输出流<br>Java.io.FileReader 字符的输入流<br>Java.io.FileWrite 字符的输出流<br>2、转换流 (将字节流转换为字符流)<br>java.io.InputStreamReader 将我们的字节转换成字符流<br>java.io.OutputStreamWrite<br>3、缓存流专属<br>java.io.BufferedReder 自带换取区的流<br>java.io.BufferedWrite<br>java.io.BufferedInputStream<br>java.io.BufferedOutputStream<br>4、数据流专属<br>java.io.DataInputStream<br>java.io.DataOutputStream<br> 5、对象专属流<br>java.io.ObjectInputStream<br>java.io.ObjectOutputStream<br> 6、标志输出流<br>java.io.PrintWrite<br>java.io.PrintStream  </p><h2 id="44、什么是阻塞io、什么是非阻塞IO"><a href="#44、什么是阻塞io、什么是非阻塞IO" class="headerlink" title="44、什么是阻塞io、什么是非阻塞IO?"></a>44、什么是阻塞io、什么是非阻塞IO?</h2><p>IO操作包括:对硬盘的读写、对socket的读写以及外设的读写。</p><p>当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞O来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：</p><p>1、查看数据是否就绪<br>2、进行数据拷贝(内核将数据拷贝到用户线程)</p><p>那么阻塞(blocking IO)和非阻塞(non-blocking IO)的区别就在于第一个阶段，如果数据没有就绪， 在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。</p><p>Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。</p><blockquote><p>BIO、NIO、AIO的区别:</p><p>BIO：同步并阻塞，在服务器中实现的模式为一个连接一个线程。也就是说，客户端有连接请求<br>的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开<br>销，当然这也可以通过线程池机制改善。B1O一般适用于连接数目小且固定的架构，这种方式对<br>于服务器资源要求比较高，而且并发局限于应用中，是jDK1.4之前的唯一选择，但好在程序直观简<br>单，易理解。</p><p>NIO：同步并非阻塞，在服务器中实现的模式为一个请求一个线程，也就是说，客户端发送的连<br>接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。<br>NIO一般适用于连接数目多且连接比较短（轻操作）的架构，并发局限于应用中，编程比较复<br>杂，从jDK1.4开始支持。</p><p>AIO：异步并非阻塞，在服务器中实现的模式为一个有效请求一个线程，也就是说，客户端的1O<br>请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO一般适用于连接<br>数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从<br>DK1。7开始支持。</p></blockquote><h2 id="45-、NIO的三大组件"><a href="#45-、NIO的三大组件" class="headerlink" title="45 、NIO的三大组件"></a>45 、NIO的三大组件</h2><p>1、Channel和Buffer</p><p>channel有一点类似于stream流，他就是读写数据的双向通道，可以从channel将数据读入buffer，也可以将buffer的数据写入channel，而之前的stream要么是输入，要么是输出，channel比stream更为底层。</p><pre class=" language-mermaid"><code class="language-mermaid">graph LRchannel --> bufferbuffer --> channel</code></pre><p>常见的channel有:</p><ul><li>FileChannel</li><li>DataramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>Buffer则用来缓冲读写数据，长江的buffer有</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><p>selector的作用就是配合一个线程来管理多个channel，获取这些channel上发生的事件，这些channel工作在非阻塞模式下，不会让线程吊死在一个channel上。适合连接特别多，但流量低多场景。</p><pre class=" language-mermaid"><code class="language-mermaid">graph TDsubgraph selector 版thread --> selectorselector --> c1(channel)selector --> c2(channel)selector --> c3(channel)end</code></pre><p>调用selector的select()会阻塞直到channel发生了读写就绪事件，这些事件发生，select方法就会返回这些事件交给thread来处理。</p><h2 id="46、Java中常见的集合-5颗星🌟🌟🌟🌟🌟"><a href="#46、Java中常见的集合-5颗星🌟🌟🌟🌟🌟" class="headerlink" title="46、Java中常见的集合(5颗星🌟🌟🌟🌟🌟)"></a>46、Java中常见的集合(5颗星🌟🌟🌟🌟🌟)</h2><p>1、java中集合主要分为两种集合类型:单值集合、key-value键值对这样的类型的集合。</p><p>单值集合的父接口:Collection.键值对的父接口为Map。</p><p>Collection的类图:</p><p><img src="https://img-blog.csdnimg.cn/20200830230517798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTUxOTM4,size_16,color_FFFFFF,t_70#pic_center" alt="集合的结构图"></p><p>Collection中比较常见的集合:</p><p>Collection上面还有一个父类:iterable 可迭代的</p><p>1、list接口：表示有序可重负的集合，常用的实现类:ArrayList、Vector、LinkedList、Vector下面还有一个Stack这个集合。</p><ul><li>ArrayList的底层的数据结构是基于我们的数组的形式来进行实现的。所以可以根据我们的索引查找对应的下标。</li><li>Vector也是数组来进行实现的</li><li>LinkedList是基于我们的链表来进行实现的。</li><li>Stack是基于我们的栈的数据结构来进行实现的。</li></ul><p>2、queue接口:表示队列，表示先进先出。常见的Dqueue下面的LinkedList也是一个queue 集合。ArrayDqueue是以我们的数组的形式去实现了我们的队列。</p><p>3、set接口:表示无序不可重复。常用的实现类:HashSet、SortedSet下面有一个TreeSet集合。</p><ul><li>HashSet是基于我们的哈希表的数据结构来进行实现的。但是呢只使用了key部分，value部分没有进行使用。就是存储了一个Object对象。</li><li>TreeMap是使用我们的红黑树来进行实现。</li></ul><p>Map接口比较常见的集合:</p><p><img src="https://img-blog.csdnimg.cn/20200830230539537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTUxOTM4,size_16,color_FFFFFF,t_70#pic_center" alt="map的结构图"></p><p>1、Map是以键值对形式进行存储的，key-value形式进行存储的。可以根据我们的key去访问我们的value。</p><p>2、所有的Map集合的特点:无序不可重复。</p><p>3、map下面比较常用的集合为:HashMap、HashTable、SortedMap下面的TreeMap。</p><h2 id="47、遍历Map的集合的方式"><a href="#47、遍历Map的集合的方式" class="headerlink" title="47、遍历Map的集合的方式"></a>47、遍历Map的集合的方式</h2><p>1、第一种使用的keySet拿到所有的key的集合。然后通过我们的迭代器进行遍历。</p><p>2、使用的forEach遍历我们的集合。forEach是函数式编程，可以得到我们的key、value键值对。</p><p>3、可以使用Values()的方法拿到所有value的集合。</p><h2 id="48、线程安全的集合有哪些、有哪些是线程不安全的"><a href="#48、线程安全的集合有哪些、有哪些是线程不安全的" class="headerlink" title="48、线程安全的集合有哪些、有哪些是线程不安全的?"></a>48、线程安全的集合有哪些、有哪些是线程不安全的?</h2><p>线程安全的集合:</p><p>1、HashTable：是线程安全的，在一些的重要的方法使用的是synchronized来进行修饰。</p><p>2、ConcurrentHashMap:是一种高效但是线程安全的集合。</p><p>3、Vector:是线程的安全的，比我们的ArrayList多了个同步化的机制。</p><p>4、Stack:栈 ，也是线程安全的。继承于Vector</p><p>线程不安全的:</p><p>1、HashMap</p><p>2、ArrayList</p><p>3、LinkedList</p><p>4、HashSet</p><p>5、TreeSet</p><p>6、TreeMap</p><h2 id="49、ArrayList和LinkedList的异同点"><a href="#49、ArrayList和LinkedList的异同点" class="headerlink" title="49、ArrayList和LinkedList的异同点:"></a>49、ArrayList和LinkedList的异同点:</h2><p>相同点:</p><p>1、ArrayList和LinkedList都是线程不安全的。</p><p>不同点:</p><p>1、底层的数据结构不同:ArrayList是基于数组的、LinkedList是基于双向链表来进行实现的。</p><p>2、插入和删除的不同:ArrayList是基于数组的所以在我们的插入和删除时，需要移动我们的数组中的数据，所以会损失一定的性能。当我们插入的数据比原数组的数据要大时，还需要进行扩容的操作。在创建一个更大的数组，然后将原数组的数据，拷贝到我们的这个数组，然后将需要插入的数据放入即可。</p><p>LinkedList是基于我们的双向链表来进行实现的。所以如果扩容的话，只需要通过我们的指针进行遍历，遍历到我们的需要插入的位置即可。然后将我们的链表的后继指针指向插入的数据即可。LinkedList不管的是插入还删除时间复杂度都是o(1).</p><p>3、随机存储:因为ArrayList是数组，所以有索引下标可以进行随机访问，而LinkedList不行，必须使用一个辅助指针，遍历这个辅助指针，来找到我对应的结点进行输出。</p><p>4、内存占用:链表的结点占用肯定是比数组要大的，因为不仅需要存储我们的元素还要存储前驱指针和后继指针。</p><h2 id="50、ArrayList和Vector的区别"><a href="#50、ArrayList和Vector的区别" class="headerlink" title="50、ArrayList和Vector的区别:"></a>50、ArrayList和Vector的区别:</h2><p>1、Vector是线程安全的，ArrayList不是线程安全的。</p><p>2、Vector在一些重要的方法加入了synchronized，可以保证我们的线程安全，但是锁的粒度太大的同时也会降低集合的效率。</p><p>3、扩容大小不同:ArrayList每次扩容会扩成原来的1.5倍，而Vector是扩容为原来的2倍。</p><h2 id="51、说一下ArrayList的扩容的机制"><a href="#51、说一下ArrayList的扩容的机制" class="headerlink" title="51、说一下ArrayList的扩容的机制"></a>51、说一下ArrayList的扩容的机制</h2><p>1、ArrayList扩容的本质就是数组的扩容。数组的扩容就是需要创建一个更大空闲的数组，用于copy一下原数组，让后将数组进行放入。ArrayList的默认情况是1.5倍。</p><p>add()方法进行扩容:</p><p>判断一下我们集合是否能存储新的元素，如果可以则直接放入即可。若不能，则调用grow()方法进行扩容。然后将元素放入到数组尾即可。grow方法会获取我们的elementData的数组的长度。获取到后，进行一个位运算，进行了一个右移1位，相当于&#x2F;2，加上我们的oldCapacity，相等于扩容为原来的1.5倍。然后去创建数组，调用Arrays.copy的方法将原数组的数据，copy到新的数组中。</p><h2 id="52、ArrayList和Array有什么区别-什么时候该用Array而不是ArrayList呢"><a href="#52、ArrayList和Array有什么区别-什么时候该用Array而不是ArrayList呢" class="headerlink" title="52、ArrayList和Array有什么区别?什么时候该用Array而不是ArrayList呢"></a>52、ArrayList和Array有什么区别?什么时候该用Array而不是ArrayList呢</h2><p>1、Array是可以包含我们的基本数据类型、ArrayList不能包含基本数据类型，只能包含引用数据类型。</p><p>2、Array的大小是固定的，ArrayList是可以进行自动扩容的。</p><p>3、ArrayList提供了更多的方法和特性，比如:add()、remove()方法等。</p><h2 id="53、HashMap的底层数据结构是什么？"><a href="#53、HashMap的底层数据结构是什么？" class="headerlink" title="53、HashMap的底层数据结构是什么？"></a>53、HashMap的底层数据结构是什么？</h2><p>不管是jdk1.7还是jdk1.8都是使用Hash 表来进行实现的，只不过具体的实现方式不同。</p><p>Jdk1.7采用的数组加链表来进行实现的，JDK1.8是采用数组加上链表加上红黑树来进行实现的。</p><p>jdk1.7中，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p><p>在jdk1.8中，是有数组+链表+红黑树组成。当链表过长时，为了查询效率，将链表转换成红黑树，因为链表的查询效率时o(n).而我们的红黑树时o(logn).当我们的数组的长度大于等于64的时候，会将链表转换成红黑树。如果有一个要求没有达到，它就不会去转化成红黑树，而是先去数组进行扩容。</p><p><img src="https://cdn-a.markji.com/files/63ec50d29689ef18f9325a76_hd.png?e=1681034683550&token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:blF9F3c_k_qGYN4HFnC1M545ymU=" alt="img"></p><h2 id="54、解决Hash冲突的办法有哪些？Hash-Map用哪些？"><a href="#54、解决Hash冲突的办法有哪些？Hash-Map用哪些？" class="headerlink" title="54、解决Hash冲突的办法有哪些？Hash Map用哪些？"></a>54、解决Hash冲突的办法有哪些？Hash Map用哪些？</h2><p>解决Hash冲突方法有:开发定址法、再哈希法、链地址法、建立公共溢出区。HashMao中采用的是链地址法。</p><p>开放地址法也称为再散列法，基本思想就是，如果p&#x3D;H(key)出现冲突时，则以p为基础，再次hash，p1&#x3D;H(p),如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址p1。因此开放地址法锁需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以只能在删除的结点上做标记，而不能删除节点。</p><p>再哈希法，提供多个hash函数，当Rl&#x3D;H1(key1)发生冲突时，在计算R2&#x3D;H2(key1)，直到没有冲突为止。这样做虽然不易产生堆集，但增加了计算的时间。</p><p>链地址法(拉链法)，将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的数组中。</p><p>建立公共溢出区:将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p><h2 id="55、Hash默认加载因子是多少-为什么是0-75，不是0-6或者0-8？"><a href="#55、Hash默认加载因子是多少-为什么是0-75，不是0-6或者0-8？" class="headerlink" title="55、Hash默认加载因子是多少?为什么是0.75，不是0.6或者0.8？"></a>55、Hash默认加载因子是多少?为什么是0.75，不是0.6或者0.8？</h2><p>回答这个问题之前,我们先看下HashMap的构造函数:</p><p>int threadold;&#x2F;&#x2F;容纳键值对的最大值</p><p>final float loadFactorr;&#x2F;&#x2F;负载因子</p><p>int modCount;</p><p>int size;</p><p>Node[] table的初始化长度length(默认值是16)，loadfactor为负载因子默认值是0.75，threadold是Hashmap所能容纳键值对的最大值。threshold&#x3D;length*loadfactor.也就是说数组定义好的长度之后，负载因子越大，所能容纳的键值对个数越多。</p><p>默认的loadFactor，是0.75，0.75是对空间和时间效率的一个平衡选择，一般不要修改，除非在时间和空间比较特殊的情况下：</p><ul><li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值。</li><li>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1</li></ul><h2 id="56、为什么解决hash冲突的时候，不直接用红黑树？而是选择先用链表，在转红黑树？"><a href="#56、为什么解决hash冲突的时候，不直接用红黑树？而是选择先用链表，在转红黑树？" class="headerlink" title="56、为什么解决hash冲突的时候，不直接用红黑树？而是选择先用链表，在转红黑树？"></a>56、为什么解决hash冲突的时候，不直接用红黑树？而是选择先用链表，在转红黑树？</h2><p>因为红黑树要进行左旋、右旋、变色的操作来保证我们的红黑树之间的平衡。而链表不用。当元素小于8个时候，此时做查询操作，链表的查询会好一些。当元素大于8的时候，使用红黑树会好一些。因为红黑树的查询的时间复杂度时O(logn),而链表是o(n)。因为一开始使用红黑树结构，元素太少，而且需要进行一些变色操作等，会浪费性能。</p><h2 id="57、HashMap中key等存储索引是怎么计算的？"><a href="#57、HashMap中key等存储索引是怎么计算的？" class="headerlink" title="57、HashMap中key等存储索引是怎么计算的？"></a>57、HashMap中key等存储索引是怎么计算的？</h2><p>首先根据key的值计算出HashCode的值，然后根据HashCode计算出hash值，最后通过我们的hash&amp;(length-1)计算得到存储的位置。</p><p>jdk1.7 方法一:先计算hashCode值，然后进行取模操作。</p><p>jdk1.8 方法二：也是计算hashCode值，然后采用位运算，高位参与运行。HashCode值无符号右移16位。这样可以仅可能的减少我们的hash冲突。</p><h2 id="58、HashMap的put方法流程"><a href="#58、HashMap的put方法流程" class="headerlink" title="58、HashMap的put方法流程?"></a>58、HashMap的put方法流程?</h2><p>以jdk1.8为列:</p><p>1、首先根据key的值，计算出hashcode值，通过无符号右移16来确定该元素在数组中的下标。</p><p>2、如果数组是空的，则调用resize方法进行初始化，初始化为16</p><p>3、如果没有哈希冲突直接放在对应的数组下标里</p><p>4、如果冲突了，且key已经存在，通过调用equals来进行比较，如果相等，就覆盖掉value。</p><p>5、如果冲突后，发现该结点是红黑树，就将这个结点挂在树上。</p><p>6、如果冲突后是链表，判断该链表是否大于8，如果大于8并且数组容量小于64，就对我们的数组进行扩容；</p><p>如果链表结点大于8并且数组的容量大于64，则将这个结构转换成红黑树否则，链表插入键值对，若key存在，就覆盖掉value。</p><p><img src="https://cdn-a.markji.com/files/63ec5a673e49fef5c8bdbb85_hd.png?e=1681034683550&token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:ZP3AyOy2MEWLf-yISIh6itmHiOs=" alt="img"></p><h2 id="59、HashMap扩容方式？"><a href="#59、HashMap扩容方式？" class="headerlink" title="59、HashMap扩容方式？"></a>59、HashMap扩容方式？</h2><p>HashMap在容量超过负载因子所定义的容量之后，就会进行扩容。java里面数组是无法进行扩容的，方法是将HashMap的大小扩容为原来的两倍，并将原来的独享的数据放入到新的数组中。</p><p>jdk1.7之后:</p><p><img src="https://cdn-a.markji.com/files/63ec5b983e49fef5c8bdcc2c_hd.png?e=1681034683550&token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:UPqsZiuCsPzrjJNU0DGY5QBaxUQ=" alt="img"></p><p>JDK1.8:</p><p><img src="https://cdn-a.markji.com/files/63ec5bb19689ef18f93346ac_hd.png?e=1681047254339&token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:bEIqORoQgJT3n7SWqNenJlSKAsg=" alt="img"></p><p>⚠️注意:在jdk1.7中rehash的时候，旧链表迁移到新链表的时候，采用的头插法。jdk1.8不会倒置，使用尾插法。 所以在jdk1.7中并发下，会造成链表出现死循环。死链的产生.</p><h2 id="60、HashMap为什么线程不安全？"><a href="#60、HashMap为什么线程不安全？" class="headerlink" title="60、HashMap为什么线程不安全？"></a>60、HashMap为什么线程不安全？</h2><p>多线程下扩容死循环。jDK1.7中的HashMap使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，jDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</p><p>多线程的put可能导致元素的丢失。多线程同时执行put操作，如果计算出来的索引位置是相同的，那会造成前一个key被后一个key覆盖，从而导致元素的丢失。此问题在DK1.7和jDK1.8中都存在。</p><p>put和get并发时，可能导致get为null。线程1执行put时，因为元素个数超出thresholdi而导致 rehash，线程2此时执行get，有可能导致这个问题。此问题在DK1。7和jDK1。8中都存在。</p><h2 id="61、ConcurrentHashMap的实现原理是什么？"><a href="#61、ConcurrentHashMap的实现原理是什么？" class="headerlink" title="61、ConcurrentHashMap的实现原理是什么？"></a>61、ConcurrentHashMap的实现原理是什么？</h2><p>ConcurrentHashMap在jdk1.7和jdk1.8的实现方式是不同的。</p><p>jdk1.7中的ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成，即ConcurrentHashMap把哈希桶切分成小数组(segment),每个数组有n个HashEntry组成。</p><p><img src="https://cdn-a.markji.com/files/63ec5eae9689ef18f9336b9c_hd.png?e=1681034683550&token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:7c0B6U86j0S2Zm1pMOncaG_ls64=" alt="img"></p><p>首先将数据分为一段一段段存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段数据也能被其他线程访问，能够实现真正的并发访问。</p><p>jdk1.8:</p><p>在数据结构上，JDK1.8中的ConcurrentHashMap选择了与HashMap相同的数组+链表+红黑树结构；在锁的实现上，抛弃了原有的Segment分段锁，采用了cas+synchronized实现更加低粒度的锁。</p><p>将锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点(红黑树的根节点)，就不会影响其他的哈希桶元素的读写，大大提高了并发度。</p><p>ConcurrentHashMap的put方法执行逻辑是什么？</p><p>先来看jdk1.7</p><p>首先，会尝试获取锁，如果获取失败，利用自旋获取锁，如果自旋重试的次数超过64次，则改为阻塞获取锁。</p><p>获取锁后:</p><p>1、将当前Segment中table通过key的hashCode定位到我们的HashEntry。</p><p>2、遍历该HashEntry，如果不为空则判断传入的key和当前遍历的key是否相等，相等则覆盖旧的value。</p><p>3、不为空则需要新建一个HashEntry并加入到Segment中，同时会先判断是否需要进行扩容操作。</p><p>4、释放Segment锁。</p><p>jdk1.8步骤:</p><p>1、根据key计算出hash值。</p><p>2、判断是否需要进行初始化。</p><p>3、定位到node结点，拿到首结点f，判断首结点f：</p><ul><li>如果为null，则通过cas到方式尝试添加。</li><li>如果为f.hash&#x3D;moved&#x3D;-1,说明其他线程在扩容，参与一起扩容。</li><li>如果都满足，synchronized锁住f节点，判断是链表还是红黑树，遍历插入。</li></ul><p>4、当在链表长度到达8的时候，数据扩容或者将链表转化成红黑树。</p><h2 id="62、ConcurrentHashMap的不支持key或者value为null的原因？"><a href="#62、ConcurrentHashMap的不支持key或者value为null的原因？" class="headerlink" title="62、ConcurrentHashMap的不支持key或者value为null的原因？"></a>62、ConcurrentHashMap的不支持key或者value为null的原因？</h2><p>我们先来说value为什么不能为null，因为ConcurrentHashMap时用于多线程的，如果map.get(key)得到了null，无法判断，是映射的value是null，还是没有找到对应的key而为null，这就有了二义性。</p><h2 id="63、ConcurrentHashMap迭代器是强一致性还是弱一致性？"><a href="#63、ConcurrentHashMap迭代器是强一致性还是弱一致性？" class="headerlink" title="63、ConcurrentHashMap迭代器是强一致性还是弱一致性？"></a>63、ConcurrentHashMap迭代器是强一致性还是弱一致性？</h2><p>与HashMap迭代器是强一致性不同，ConcurrentHashMap迭代器是弱一致性。</p><p>ConcurrentHashMap的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元 素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</p><h2 id="64、JDk1-7与jdk1-8中ConcurrentHashMap的区别"><a href="#64、JDk1-7与jdk1-8中ConcurrentHashMap的区别" class="headerlink" title="64、JDk1.7与jdk1.8中ConcurrentHashMap的区别?"></a>64、JDk1.7与jdk1.8中ConcurrentHashMap的区别?</h2><p>数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。 </p><p>保证线程安全机制：JDK1。7采用Segment的分段锁机制实现线程安全，其中segment？继承自ReentrantLock。JDKI。8采用CAS+Synchronized保证线程安全。</p><p>锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁 (Node)</p><p>链表转化为红黑树：定位结点的hash算法简化会带来弊端，Hash冲突加剧，因此在链表节点数量大于8 时，会将链表转化为红黑树进行存储。</p><p>查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p><h2 id="65、多线程安全的操作map还有其他方法吗"><a href="#65、多线程安全的操作map还有其他方法吗" class="headerlink" title="65、多线程安全的操作map还有其他方法吗?"></a>65、多线程安全的操作map还有其他方法吗?</h2><p>1、还可以使用collections.synchronziedMap方法。</p><p>2、加上synchronized同步锁。</p><p>3、使用ConcurrentHashMap</p><h2 id="66、HashSet和HashMap的区别"><a href="#66、HashSet和HashMap的区别" class="headerlink" title="66、HashSet和HashMap的区别:"></a>66、HashSet和HashMap的区别:</h2><p>1、HashSet实现了set接口，Hash Map实现的是map接口</p><p>2、HashMap存储键值对，HashSet只能存储值</p><p>3、HashSet的底层就是使用的HashMap的key部分，value保存了一个虚值。</p><p>4、HashSet的使用add方法添加数据,HashMap使用put来添加数据</p><h2 id="67、Collection框架中实现比较怎么做？"><a href="#67、Collection框架中实现比较怎么做？" class="headerlink" title="67、Collection框架中实现比较怎么做？"></a>67、Collection框架中实现比较怎么做？</h2><p>1、去让我们的实体类实现Comparable接口，并实现compareTo(T t)方法，称为内部比较器，如果CompareTo方法返回的是一个正数表示从小到大的排序。升序排序的。如果是一个负数，就是降序排序的。如果是0表示等于。</p><h2 id="68、Iterator和Listerator有什么区别？"><a href="#68、Iterator和Listerator有什么区别？" class="headerlink" title="68、Iterator和Listerator有什么区别？"></a>68、Iterator和Listerator有什么区别？</h2><p>遍历。使用Iterator，可以遍历所有集合，如Map，List，Set；但只能在向前方向上遍历集合中的元素。</p><p>使用Listlterator，只能遍历List实现的对象，但可以向前和向后遍历集合中的元素。</p><p>添加元素。Iterator无法向集合中添加元素；而，Listlteror可以向集合添加元素。</p><p>修改元素。Iterator无法修改集合中的元素而，Listlterator可以使用set0修改集合中的元素。</p><p>索引。Iteratori无法获取集合中元素的索引；而，使用Listlterator，可以获取集合中元素的索引。</p><h2 id="69、讲一讲快速失败-fail-fast-和安全失败-fail-safe"><a href="#69、讲一讲快速失败-fail-fast-和安全失败-fail-safe" class="headerlink" title="69、讲一讲快速失败(fail-fast)和安全失败(fail-safe)"></a>69、讲一讲快速失败(fail-fast)和安全失败(fail-safe)</h2><p>快速失败（fail-fast）</p><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改)，则会抛出ConcurrentModification Exception。</p><p>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个nodCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext(0&#x2F;next)遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值， 是的话就返回遍历；否则抛出异常，终止遍历。</p><p>注意：这里异常的抛出条件是检测到modCount！&#x3D;expectedmodCount这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p><p>场景: java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改,比如HashMap、ArrayList这些集合类。</p><p>安全失败(fail-fast):</p><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><p>场景:java.util.concurrent包下的容器都是安全失败,可以在多线程下并发使用,并发修改，比如:ConcurrentHashMap</p><h2 id="70、在并发环境下使用什么list啊？"><a href="#70、在并发环境下使用什么list啊？" class="headerlink" title="70、在并发环境下使用什么list啊？"></a>70、在并发环境下使用什么list啊？</h2><p>1、最简单的方法就是直接使用Vector</p><p>2、使用collections.synchronziedList修饰这个list，将这个list保证成线程安全的。</p><p>3、使用我们的写时赋值技术，也就是CopyOnWriteArrayList</p><p>底层实现的写入时copy的思想，增删改操作会将底层数据拷贝一份，更改操作在新数组上执行，这时不影响其他线程的并发读，读写分离。</p><p>适合读多写少的场景</p><p>get弱一致性问题:</p><p>不如说我的集合中有1，2，3三个元素,这时线程1去读取元素，线程二去remove掉一个元素，拷贝出一个一摸一样的数组，然后去这个数组中去将1清除掉，这时赋值回去的时候，线程1还可以去原来的数组中去获取元素1。这就是CopyOnWirte的弱一致性。</p><h1 id="线程篇"><a href="#线程篇" class="headerlink" title="线程篇"></a>线程篇</h1><h2 id="1、创建线程的几种方式"><a href="#1、创建线程的几种方式" class="headerlink" title="1、创建线程的几种方式"></a>1、创建线程的几种方式</h2><ul><li>继承Thread，重写run方法</li><li>实现Runnalbe，实现run方法</li><li>实现Callable接口，实现call方法。</li><li>使用线程池创建线程。</li></ul><p>区别:</p><p>1、第一个方式因为是使用继承，所以不能在继承其他的类</p><p>2、第二种方式,就是因为使用实现，所以还是可以继续实现其他的接口，并且还可以继承其他的类，所以第二种的扩展性比较好</p><p>3、实现Callble的接口，call方法允许存在的泛型的，所以可以规范我们的传输数据。call方法可以存在的返回值。但是需要使用Future进行接收。call方法可以抛出异常的。</p><h2 id="2、线程池的创建"><a href="#2、线程池的创建" class="headerlink" title="2、线程池的创建"></a>2、线程池的创建</h2><p>1、可以使用Executors工具类创建线程.</p><p>Executors几种创建线程的方式:</p><p>1、newFixedThreadPool 固定线程数,核心线程和最大线程数一样的</p><p>2、newSingleThreadExecutor 一池一线程</p><p>3、newCachedThreadPool() 核心线程是0，最大线程数是Integer.MAX_VALUE</p><p>4、newScheduledThreadPool()：定时任务的线程池</p><p>2、使用ThreadPoolExecutor去创建我们的线程池。</p><p>自己去创建我们的线程池的七大参数:</p><p>1、corePoolSize:线程池的核心线程数</p><p>2、maxNumPoolSize:线程池的最大线程数</p><p>3、keepAliveTime:线程的存活时间</p><p>4、Unit：时间单元</p><p>5、ThreadFactory：线程的工厂，用于创建线程。</p><p>6、BlockingQueue:线程的阻塞队列。</p><p>7、Rejected：线程池的拒接策略。</p><h2 id="3、线程池的执行流程"><a href="#3、线程池的执行流程" class="headerlink" title="3、线程池的执行流程:"></a>3、线程池的执行流程:</h2><p>当我们的任务来了之后,线程池会去判断我们线程池中的线程是否小于corePoolSize，如果小于则直接创建线程执行任务,如果大于，就把当前线程放入到阻塞队列中。<br>当我们的阻塞队列中的任务，满了以后，会去判断我们当前线程池中的线程是否小于maxNumPoolSize的值，如果小于则去创建多余的线程去执行任务。如果当我们创建的线程数大于等于maxNumPoolSize了，那么我们就要启动拒接策略。去进行拒接。当我们的任务执行完之后，会去判断当前线程池中的线程是否大于corePoolSize，如果大于的话，会去等待这些线程的空闲时间大于或等于keepAliveTime，就会将这些多余的线程进行回收。</p><h2 id="4、线程池中有哪些拒接策略"><a href="#4、线程池中有哪些拒接策略" class="headerlink" title="4、线程池中有哪些拒接策略:"></a>4、线程池中有哪些拒接策略:</h2><p>1、AbortPolicy(阿婆特跑了c)(默认):直接抛出异常</p><p>2、CallerRunsPolicy:调用者运行的一种调节机制，该策略不会抛弃任务，也不会抛出异常，而是将这些任务退回到调用者，从而降低新任务的流量。</p><p>3、DiscardOldestPolicy:抛弃队列中等候最久的任务，然后把当前任务加入到队列中,尝试再次提交当前任务。</p><p>4、DiscardPolicy:该策略默默地丢弃无法处理的任务，不予任何处理也不抛异常。如果允许任务的丢失，这是最好的一种策略。</p><h2 id="5、进程与线程之间的区别"><a href="#5、进程与线程之间的区别" class="headerlink" title="5、进程与线程之间的区别:"></a>5、进程与线程之间的区别:</h2><p>1、进程:当我们启动一个程序，将我们程序的代码从磁盘中加载内存中，这就相当于开启了一个进程。例如说:启动了qq.exe,相当于开启了一个qq进程。我们进程是系统进行资源分配的最小单元。</p><p>2、线程:线程java允许过程中最小的调度单元。一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给cpu执行。</p><p>3、进程包含线程，也就是线程是进程的子集。</p><p>4、线程通信相对简单，因为它们共享进程内的内容。</p><p>5、线程的上下文切换比进程更加的轻量。</p><p>ps -ef ｜ grep 查询具体的进程。</p><p>kill -9 杀死我们的某个进程。</p><h2 id="6、Thread中常用的方法"><a href="#6、Thread中常用的方法" class="headerlink" title="6、Thread中常用的方法:"></a>6、Thread中常用的方法:</h2><p>1、start() 启动线程</p><p>2、run()方法,线程启动时会调用这个方法。</p><p>3、join 等待线程运行结束</p><p>4、getName 获取线程名称</p><p>5、getPriority（）获取线程优先级</p><p>6、getState 获取线程的状态</p><p>7、isInterrupted() 打断线程</p><p>8、isAlive 线程是否存活</p><p>9、currentThread() 获取当前正在执行的线程</p><h2 id="7、为什么要使用多线程呢？"><a href="#7、为什么要使用多线程呢？" class="headerlink" title="7、为什么要使用多线程呢？"></a>7、为什么要使用多线程呢？</h2><p>从计算机底层来说：线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核CPU时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</p><p>从当代互联网发展趋势来说：现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p><p>根本的原因就是单线程不够用吗。</p><h2 id="8、线程的状态切换"><a href="#8、线程的状态切换" class="headerlink" title="8、线程的状态切换:"></a>8、线程的状态切换:</h2><p>1、从系统层面来看的:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220113213622272.png" alt="image-20220113213622272"></p><p>1、初始状态:创建线程，还没有于我们的操作系统进行关联。</p><p>2、可运行状态:指该线程已经被创建，可以由cpu进行调度执行。</p><p>3、运行状态:指获取到了cpu的时间片。当时间片用完，会从运行状态转化成可运行状态，会进行现场上下文之间的切换。</p><p>4、阻塞状态:表示调用阻塞式的IO可能会导致线程的阻塞，比如调用了传统的IO比如FileOutputStream等。</p><p>5、终止状态:表示线程已经执行完毕，生命周期已经结束,不会再转换为其他状态</p><h2 id="9、start方法和run方法的区别"><a href="#9、start方法和run方法的区别" class="headerlink" title="9、start方法和run方法的区别:"></a>9、start方法和run方法的区别:</h2><p>start()方法是开启线程一个线程，其实底层调用的是一个使用native修饰的start0()方法来开启线程.线程启动之后，会去调用run方法。如果只是调用run()方法，就相当于只是去执行了run方法，没有去启动线程</p><h2 id="10、sleep和yield的区别"><a href="#10、sleep和yield的区别" class="headerlink" title="10、sleep和yield的区别:"></a>10、sleep和yield的区别:</h2><p>1、调用sleep会让当前线程从Running进入到Time waiting状态(阻塞)</p><p>2、其他线程可以使用interruptor来进行打断正在随眠的线程，这时sleep方法会抛InterruptorException</p><p>3、睡眠结束后的线程未必会立刻得到执行</p><p>4、yield会当当前线程从Running状态变为Runnable的就绪状态,然后去调度执行其他线程</p><p>5、具体实现依赖于操作系统的任务调度</p><blockquote><p> 线程的优先级:</p><p>1、线程优先级会提示调度器优先去调度该线程，但它仅仅是一个提示，调度器可以忽略它<br>2、如果cpu比较忙，那么优先级高的线程会获得更多的时间片，但cpu闲时,优先级几乎没作用。<br>使用setPriority</p></blockquote><h2 id="11、java层面的线程状态"><a href="#11、java层面的线程状态" class="headerlink" title="11、java层面的线程状态"></a>11、java层面的线程状态</h2><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220113215646043.png" alt="image-20220113215646043"></p><p>1、new状态:表示当前new Thread(),但是还没有调用start()方法。</p><p>2、runable:指当前线程调用start()方法，去抢夺cpu的时间片</p><p>3、waiting:等待</p><p>4、blocked:阻塞</p><p>5、time_waiting：等待时间</p><p>6、终止:程序执行完毕</p><p>之间的转换:</p><p>1、new—&gt;runnable 就是调用了start()方法就会从我们的new状态变为runnable</p><p>2、runnable–&gt;wait：就是当我们多个线程去抢夺synchronized的对象锁的时候，调用了Object.wait方法会让当前线程变为wait状态。</p><p>调用obj.notify()、notifyAll()、interrupt()时，就会去竞争锁成功,t线程从waiting—-&gt;runnable</p><p>竞争锁失败,t线程从waiting—-》blocked</p><p>调用LockSupport.park()方法会让当前线程从runnable–&gt;waiting</p><p>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</p><p>RUNNABLE –&gt; TIMED_WAITING:</p><p>1、调用的join()设置了时间<br>2、调用了sleep方法会让当前线程变为time_waiting<br>3、调用Locksupprot方法的park方法。<br>4、就是去抢夺对象锁的时候，调用了wait方法，并设置了等待时间。</p><p>runnable–&gt;blcoked<br>1、抢夺对象锁失败，就会进如到entryList中进行阻塞。</p><p>runnable–&gt;终止状态:程序执行完毕</p><h2 id="12、什么是临界区"><a href="#12、什么是临界区" class="headerlink" title="12、什么是临界区:"></a>12、什么是临界区:</h2><p>指一个程序运行多个线程本身是没有问题。</p><p>问题出在多个线程访问共享资源。<br>    1、多个线程共享资源其实没有问题。<br>    2、在多个线程对共享资源读写时发生指令交错，就会出现问题。</p><p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区。</p><p>竟态条件:</p><p> 多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之发生了竟太条件。</p><p>如何解决临界区问题:</p><p>1、阻塞式的解决方案;synchronized、lock</p><p>2、非阻塞式的解决方案:原子变量</p><p>解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><h2 id="13、互斥和同步的区别"><a href="#13、互斥和同步的区别" class="headerlink" title="13、互斥和同步的区别:"></a>13、互斥和同步的区别:</h2><p>互斥是防止临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</p><p>同步是由于线程执行的先后、顺序不同、需要一个线程等待其他线程运行到某个点</p><h2 id="14、synchronized"><a href="#14、synchronized" class="headerlink" title="14、synchronized"></a>14、synchronized</h2><p>java中的关键字,使用对象锁的方式来解决临界区问题。是一个可重入锁，是一个重量级锁。</p><p>可以修饰代码块、可以修饰静态方法、实例方法。</p><p>修饰静态方法，相当于锁当前的class，如果是修饰实例方法，相当于锁当前的对象。</p><p>理解:</p><p>当多个线程区执行到synchronized的时候，就会去抢夺对象锁，获取到对象锁后，就会执行任务，这时其他线程也想执行，发现对象锁已被获取，那么它就只能阻塞住，等别人去释放锁。有可能当前线程还没执行完的时候，cpu时间片用完了，被剔除了房间，但是当前房间依旧是上锁的，其他线程进不去，只能当前线程进去，继续执行，执行完毕之后，会去唤醒所有的阻塞线程去抢夺对象锁。</p><h2 id="15、变量的线程安全分析"><a href="#15、变量的线程安全分析" class="headerlink" title="15、变量的线程安全分析:"></a>15、变量的线程安全分析:</h2><p>1、成员变量和静态变量是否线程安全:</p><ul><li>如果它们没有共享，则线程安全。<ul><li>如果它们共享了，根据它们的状态能否能够改变，分为两种情况:<ul><li>如果只有读操作，则是线程安全</li><li>如果有写的操作,则这段代码是临界区，需要考虑线程安全。</li></ul></li></ul></li></ul><p>2、局部变量是否线程安全</p><ul><li>局部变量是线程安全，因为每个线程都有属于自己的栈帧。</li><li>但局部变量引用的对象则未必:<ul><li>如果该对象没有逃离方法的作用域，它是线程安全。</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全。</li></ul></li></ul><h2 id="16、常见的线程安全的类"><a href="#16、常见的线程安全的类" class="headerlink" title="16、常见的线程安全的类"></a>16、常见的线程安全的类</h2><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>juc包下的类</li></ul><p>这里说它们是线程安全的指,多个线程调用它们同一个实例的某个方法时，是线程安全的。它们的每个方法是原子的。<br>但注意它们多个方法的组合不是原子的。</p><p>一个对象是否是线程安全，取决于它是否被多个线程访问。</p><h2 id="17、synchronized的底层实现"><a href="#17、synchronized的底层实现" class="headerlink" title="17、synchronized的底层实现"></a>17、synchronized的底层实现</h2><p>java对象头:</p><p>普通对象分为:mark word、klass word</p><p>klass word里面存放的是对象类型。</p><p>其中的mark word对象头中存储了一个biased_lock的表示位:</p><pre class=" language-java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">|</span> Mark <span class="token function">Word</span> <span class="token punctuation">(</span><span class="token number">64</span> bits<span class="token punctuation">)</span> <span class="token operator">|</span> State <span class="token operator">|</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">|</span> unused<span class="token operator">:</span><span class="token number">25</span> <span class="token operator">|</span> hashcode<span class="token operator">:</span><span class="token number">31</span> <span class="token operator">|</span> unused<span class="token operator">:</span><span class="token number">1</span> <span class="token operator">|</span> age<span class="token operator">:</span><span class="token number">4</span> <span class="token operator">|</span> biased_lock<span class="token operator">:</span><span class="token number">0</span> <span class="token operator">|</span> <span class="token number">01</span> <span class="token operator">|</span> Normal <span class="token operator">|</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">|</span> thread<span class="token operator">:</span><span class="token number">54</span> <span class="token operator">|</span> epoch<span class="token operator">:</span><span class="token number">2</span> <span class="token operator">|</span> unused<span class="token operator">:</span><span class="token number">1</span> <span class="token operator">|</span> age<span class="token operator">:</span><span class="token number">4</span> <span class="token operator">|</span> biased_lock<span class="token operator">:</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">01</span> <span class="token operator">|</span> Biased <span class="token operator">|</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">|</span> ptr_to_lock_record<span class="token operator">:</span><span class="token number">62</span> <span class="token operator">|</span> <span class="token number">00</span> <span class="token operator">|</span> Lightweight Locked <span class="token operator">|</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">|</span> ptr_to_heavyweight_monitor<span class="token operator">:</span><span class="token number">62</span> <span class="token operator">|</span> <span class="token number">10</span> <span class="token operator">|</span> Heavyweight Locked <span class="token operator">|</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">|</span> <span class="token operator">|</span> <span class="token number">11</span> <span class="token operator">|</span> Marked <span class="token keyword">for</span> GC <span class="token operator">|</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span></code></pre><p>hasCode、对象年龄等。<br>如果是0表示是偏向锁<br>如果是01:表示正常状态、并没有枷锁。如果00表示轻量级锁。10表示重量级锁。</p><p>每一个java对象都关联一个Minitor对象,如果使用synchronized给对象上锁之后，该对象头的Mark word中就被设置指向Minitor对象的指针。<br>Monitor结构如下:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220115221331431.png"></p><p>1、刚开始Minitor中Owner为null</p><p>2、当Thread-2执行了synchronized(obj)就会将Minitor的所有者Owner置为Thread-2,Minitor只能有一个</p><p>3、当Thread-2上锁的过程中，如果Thread-3、Thread-4、Thread-5也来执行synchronized(obj)，就会进入EntryList Blocked</p><p>4、当我们的Thread-2执行完同步代码块的内容，然后去唤醒EntryList中等待的线程来竞争锁，竞争是非公平的。</p><p>5、但我们在对象锁中调用wait方法，就会去释放锁，让后去到wating中进行等待notify到释放。</p><h2 id="18、synchronzied的优化"><a href="#18、synchronzied的优化" class="headerlink" title="18、synchronzied的优化"></a>18、synchronzied的优化</h2><p>从jdk1.6开始引入了synchronized的优化策略，锁升级的策略,也就是不是一开始就使用重量级锁,而是从偏向锁、轻量级锁、重量级锁这一过程。</p><p><font color="red">偏向锁的过程:</font></p><p>轻量级锁在没有竞争时，每次重入仍然需要执行CAS操场。所以在java6中引入了偏向锁，来做进一步的优化:只有第一次使用CAS将线程ID设置到对象Mark Word头，之后发现这个线程id是自己的就表示没有竞争，不用重新CAS。然后只要不发生竞争，这个对象就归当前线程所有。设置失败，表示存在竞争，进入到锁升级到状态中。</p><p>偏向状态:</p><p>java的头格式:</p><p>如果开启了偏向锁,那么对象创建后，markword值为0x05即最后3位为101，这时它的thread、epoch、age都为0</p><p>偏向锁默认是延迟的。如果没有开启偏向锁，那么对象创建后，markword值为后三位为001.</p><p>轻量级锁失效:</p><p>1、调用了hashCode以后，偏向锁会自动关闭，因为底层一旦hash码产生，他就没有办法去存储线程的锁记录了。</p><p>2、多个线程的同时调用，会导致竞争，会进入到锁升级状态<br>3、调用wait和notify的，因为是重量级锁，调用该方法偏向锁失效，进入到锁膨胀成为重量级锁。</p><p>批量重偏向:撤销偏向阈值超过20次后，jvm会进行重新偏向。</p><p>批量撤销:当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的.</p><p>锁消除:jvm底层有个jit编辑器,会自动优化你的代码，比如一个局部对象,使用synchronized的加锁,jit编辑器会认为你的加锁方式是无意义的,会在底层自动撤销掉这个锁.</p><p><font color="orange">轻量级锁:</font></p><p>使用场景:如果一个对象虽然有多线程要加锁，但加锁时间是错开，也就是没有竞争，那么可以使用轻量级锁来优化。</p><p>轻量级锁对使用者是透明的即语法仍然是synchronized。</p><p>假设有两个方法同步块，利用同一个对象加锁</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 同步块 A</span>        <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 同步块 B</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>轻量级锁的流程:</p><p>1、创建一个锁记录(lock record)对象，</p><ul><li>每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word:</li></ul><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220115235021028.png" alt="image-20220115235021028"></p><p>2、让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录 </p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220115235544339.png" alt="image-20220115235544339"></p><p>3、如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220116000314509.png" alt="image-20220116000314509"></p><p>4、如果 cas 失败，有两种情况</p><ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ul><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220116000408974.png" alt="image-20220116000408974"></p><p>5、当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220116000508711.png" alt="image-20220116000508711"></p><p>6、当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</p><ul><li><p>成功，则解锁成功</p></li><li><p>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p></li></ul><p><font color="red"><strong>总结:当我们的线程去获取对象锁时，jvm会创建一个锁记录,用于指向当前对象头，然后会去尝试去用锁记录去替换对象头中的markword，替换成功表示加锁成功。替换失败分为两种情况,一种是存在多个线程竞争，会进入锁膨胀阶段变为重量级锁。另一种，自己又去获取对象锁，这是进入到锁重入阶段，会再次创建一个锁记录，count+1。当我们去解锁的时候，会先去查看是否存在一个取值为null的锁记录，如果有表示该锁需要去重置锁记录，让锁记录-1，减到为0的时候，表示没有锁重入，这是就会去使用cas将MarkWord的值还给对象头，交换成功，表示解锁成功，归还失败，表示进入到重量级锁的解锁过程。</strong></font></p><blockquote><p>锁膨胀</p><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><p>1、当我们的Thread-1进行轻量级加锁时，发现thread-0已经对该对象加了轻量级锁。</p><p>2、这时Thread-1加轻量级锁失败，进入锁膨胀流程</p><ul><li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</li><li>然后自己进入 Monitor 的 EntryList BLOCKED</li></ul><p>3、当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</p></blockquote><blockquote><p>自旋优化</p><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p></blockquote><h2 id="19、原理-wait和notify"><a href="#19、原理-wait和notify" class="headerlink" title="19、原理 wait和notify"></a>19、原理 wait和notify</h2><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220121231347259.png" alt="image-20220121231347259"></p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li></ul><p> wait和notify使用</p><ul><li><p>obj.wait() 让进入 object 监视器的线程到 waitSet 等待</p></li><li><p>obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒</p></li><li><p>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒</p></li></ul><p>sleep和wait的区别:</p><p>  1、sleep是Thread的静态方法，而wait是Object中方法。<br>  2、sleep不需要强制和synchronized一起联合使用，wait需要和synchronized联合使用。<br>  3、sleep表示睡眠当前时间，但是它是不会释放锁，当wait也是让当前线程去waitSet中进行等待，但是会释放锁。<br>  4、它们的状态的Time_waiting状态</p><p>使用wait和notify的模版代码:使用while避免虚假唤醒。</p><p>使用场景:保护性暂停<br>在一个线程等待另一个线程的执行结果<br><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220124220039050.png" alt="image-20220124220039050"></p><p>代码实现:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>serookie<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2022/1/25 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GuardedDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        GuardedObject guarded <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GuardedObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"等待结果"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object resp <span class="token operator">=</span> guarded<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"    "</span><span class="token operator">+</span>resp<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"执行下载...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//模拟下载资源</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            guarded<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">GuardedObject</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Object response<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取结果</span>    <span class="token keyword">public</span> Object <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>response<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> response<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">complete</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token operator">=</span>obj<span class="token punctuation">;</span>           <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>join的底层的原理的就是使用wait和notifyAll</p><p>future的底层实现原理都是使用wait和notifyAll来进行实现的。</p><h2 id="20、Java的内存模型"><a href="#20、Java的内存模型" class="headerlink" title="20、Java的内存模型"></a>20、Java的内存模型</h2><p>JMM即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着cpu寄存器、缓存、硬件内存、cpu指令优化等。</p><p>JMM体现在以下几个方面:</p><ul><li>原子性:保证指令不会收到线程上下文切换的影响。</li><li>可见性:保证指令不会受到cpu等缓存的影响。</li><li>有序性:保证指令不会受到cpu指令并行优化的影响。</li></ul><p>原子性：表示一个指令操作不能被线程上下文之间的切换进行打断。即表示一个指令操作的必须是原子性的要么执行完，要么不执行。</p><p>可见性:</p><p>受到cpu缓存的影响，cpu缓存分为多级缓存，主内存和工作内存，当我们的线程频繁去访问我们的主内存中数据的时候，jit会进行优化，将我们的主内存中数据放到我们的工作内存中，让我们的当前线程一直操作工作内存的数据。这样就会导致一个问题就是，当前数据就只能被当前线程可见，对其他线程是不可见的。</p><p>解决的方式就是通过我们的<font color="red">volatile关键字</font>来进行解决。</p><p>volatile可以用于修饰的成员变量和静态的成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须强制到我们的主存中获取它的值，线程操作volatile变量都是直接操作主存。</p><p>volatile可以保证在多个线程之间，一个线程对变量的修改对另一个线程是可见的，不能保证原子性，仅用在一个写线程，多个读线程的情况。</p><p>有序性:</p><p>jvm在不影响结果正确性的情况下，它会优化我们的代码的执行顺序。这种特性称之为指令重排，多线程下指令重排会影响正确性。</p><p>volatile底层实现的是基于内存屏障，Memory Barrier</p><ul><li>对volatile变量的写指令后加入写屏障。</li><li>对volatile变量的读指令前会加入读屏障。</li></ul><p>如何保证可见性:</p><p>写屏障保证在该屏障之前，对共享变量的改动，都同步到我们的主存中。</p><p>读屏障保证在屏障之后，对共享变量的读，都是从我们的主存中进行读取。读到都是最新的数据。</p><p>如何解决有序性:</p><p>写屏障保证在指令重排序时，不会将写屏障之前的数据放到我们的屏障之后。</p><p>读屏障保证在指令重排序时，不会讲读屏障之后的数据放到我们的屏障之前。</p><p><font color="orange"><strong>volatile不能解决原子性。</strong></font></p><h2 id="21、happends-before原则-lt-重要🌟🌟🌟-gt"><a href="#21、happends-before原则-lt-重要🌟🌟🌟-gt" class="headerlink" title="21、happends-before原则:&lt;重要🌟🌟🌟&gt;"></a>21、happends-before原则:&lt;重要🌟🌟🌟&gt;</h2><p>规定了对共享变量的写操作对其他线程的读操作可见，它是可见性与有序性的一套规则总结。抛出以下happends-before原则，JMM并不能保证一个线程对共享变量的写，对于其他线程对该共享变量的读可见。</p><p>1、线程解锁之前对变量的写，对于接下来对加锁的其他线程的读可见。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JMM</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//1、线程解锁之前对我们的线程写操作，对于接下来对加锁的其他线程的读可见。</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>                i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2、线程对volatile变量的写，对该线程变量的读是可见的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> day2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/4/10 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JMM2</span> <span class="token punctuation">{</span>    <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            i<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3、线程start前对变量的写，对该线程开始后对该变量的读可见的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JMM3</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        i<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>4、线程结束前对变量的写，对其他线程得知它结束后对读可见。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JMM4</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>5、线程t1打断t2前对变量的写，对于其他线程得知t2被打断后对变量的读可见。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      t2<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>t2<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>6、对变量默认值(0,false,null)的写，对其他线程对该变量的读可见。</p><p>7、具有传递性，如果x-hp-y  y-hp-z 那么我们的x-hp-z。</p><h2 id="22、无锁的实现"><a href="#22、无锁的实现" class="headerlink" title="22、无锁的实现:"></a>22、无锁的实现:</h2><p>volatile加cas来实现无锁并发。或者直接使用Atomic类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//获取到最新的值</span>   <span class="token keyword">int</span> prev<span class="token operator">=</span>money<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//修改后的余额</span>   <span class="token keyword">int</span> next<span class="token operator">=</span>prev<span class="token operator">-</span>num<span class="token punctuation">;</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>money<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">break</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>compareAndSet：在set前，先去获取最新的值与当前值做比较，如果不一致，next作废，返回false失败，如果是一致，以next设置新值，返回true成功。</p><p>其中的关键是compareAndSet，它的简称就是CAS，它必须是原子操作。</p><p>注意:CAS的底层使用lock cmpxchg指令，在单核cpu和多核cpu下都能保证cas的原子性。在多核的状态下，某个指令执行到带lock的指令时，cpu会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性,是原子的。</p><p>CAS必须借助volatile才能读取到共享变量的最新值来实现[比较并交换]的效果。</p><p>CAS必须搭配volatile一起使用。</p><p>无锁并发适合线程数少、多核cpu的场景下。</p><h2 id="23、为什么无锁的效率高"><a href="#23、为什么无锁的效率高" class="headerlink" title="23、为什么无锁的效率高"></a>23、为什么无锁的效率高</h2><p>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，<br>等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p><h2 id="24、CAS的特点"><a href="#24、CAS的特点" class="headerlink" title="24、CAS的特点:"></a>24、CAS的特点:</h2><p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。<br>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p><p>CAS 体现的是无锁并发、无阻塞并发。</p><p>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一，但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</p><h2 id="25、ABA问题"><a href="#25、ABA问题" class="headerlink" title="25、ABA问题"></a>25、ABA问题</h2><p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：</p><p>只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号</p><p>使用这个类就可以解决AtomicStampedReference里面有一个版本号需要更新</p><p>原子累加器</p><p>LongAdder:性能提升的原因很简单，就是在有竞争时,设置多个累加单元,Thread-0累加共享变量1,而Thread-1累加共享变量2…最后将结果汇总。这样它们在累加时操作的不同的共享变量，因此减少了cas重试失败，从而提升性能。</p><p>扩展了解:</p><blockquote><p>Unsafe:</p><p>CAS的底层就是使用Unsafe来进行实现的。</p><p>Unsafe是java提供给我们能够直接操作内存空间的方法。只能通过java反射来进行暴力的获取。</p><p>Unsafe类中的.compareAndSwapInt就是CAS底层的原理。</p><p>要获取到属性的偏移量，然后根据偏移量来进行修改。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Unsafe1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchFieldException<span class="token punctuation">,</span> IllegalAccessException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过反射获取我们的属性 unsafe</span>        Field theUnsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"theUnsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        theUnsafe<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Unsafe unsafe<span class="token operator">=</span><span class="token punctuation">(</span>Unsafe<span class="token punctuation">)</span>theUnsafe<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取对象的偏移量</span>        Field name <span class="token operator">=</span> Student<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Field id <span class="token operator">=</span> Student<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> nameOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> idOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span>student<span class="token punctuation">,</span>idOffset<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span>student<span class="token punctuation">,</span>nameOffset<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></blockquote><h2 id="26、ThreadLocal"><a href="#26、ThreadLocal" class="headerlink" title="26、ThreadLocal"></a>26、ThreadLocal</h2><p>1、ThreadLocal可以实现资源对象的线程的隔离，让每个线程各用各的资源对象，避免引发线程安全的问题。</p><p>2、ThreadLocal同时实现线程内的资源共享</p><p>能干嘛？</p><p>实现每一个线程都有自己专属的本地变量副本(自己用自己的变量不麻烦别人,不和其他人共享,人人有份，人格一份)，主要解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题。</p><p>ThreadLocal和synchronized的区别:</p><p>虽然ThreadLocal模式与synchronized关键字都用于处理多线程并发访问变量的问题,不过两者处理问题的角度的和思路不同。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220228172356806.png" alt="image-20220228172356806"></p><p>源码分析:</p><p>1、Thread，点击发现有一个Thread Locals，点击ThreadLocal发现里面有一个静态的内部类ThreadLocalMap。三者之间的关系:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220707214316966.png" alt="image-20220707214316966"></p><p>ThreadLocalMap实际上就是一个以ThreadLocal为key，任意对象为value的entry对象。</p><p>当我们为threadlocal变量赋值，实际上就是以当前threadLocal实例为key,值为value的Entry往这个threadLocalMap中存放。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220707222252090.png" alt="image-20220707222252090"></p><p>1、获取当前线程实例，调用getMap方法，参数为当前线程，返回值为ThreadLocalMap。去拿到ThreadLocalMap的值</p><p>2、判断map是否为null，如果为null，则调用Initialvalue进行初始化。</p><p>3、如果不为null,则调用map的getEntry方法，传入当前线程，返回一个Entry对象，拿到entry对象中的value值，进行一个返回。</p><p>4、entry对象以key，value键值对的形式存储数据，key为ThreadLocal，value为object对象。来进行取值和存值。</p><p>在ThreadLocalMap的entry对象继承了WeakReference，包转成了一个弱引用对象，当我们的垃圾收集器来进行垃圾收集的时候，不管内存空间是否足够，都会清理到ThreadLocalMap中的对象。</p><p>出现的问题:</p><p>必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用,如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用try-finlly块进行回收。</p><h2 id="27、什么是线程的死锁？如何避免死锁"><a href="#27、什么是线程的死锁？如何避免死锁" class="headerlink" title="27、什么是线程的死锁？如何避免死锁?"></a>27、什么是线程的死锁？如何避免死锁?</h2><p>死锁:一个线程需要同时获取多把锁，这时就容易发生死锁</p><p>t1 线程获得A对象锁，接下来想获取 B对象的锁 t2 线程获得B对象锁,接下来想获取A对象的锁,这样就会产生死锁。</p><p>死锁必须具备以下四个条件:</p><ul><li>互斥条件:该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程以获得的资源在未使用完之前不能被其他线程强行剥夺，只能自己使用完毕后才释放资源。</li><li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><p>如何避免死锁:</p><p>通过调整获取的锁的顺序来解决死锁的问题，比如规定:要想获取B对象锁，必须先获取A对象锁才可以。按顺序来取锁就可以避免死锁的产生。</p><h2 id="28、Park和unPark的使用"><a href="#28、Park和unPark的使用" class="headerlink" title="28、Park和unPark的使用"></a>28、Park和unPark的使用</h2><p>使用LockSuport类中的方法，</p><p>&#x2F;&#x2F; 暂停当前线程<br>LockSupport.park(); </p><p>&#x2F;&#x2F; 恢复某个线程的运行<br>LockSupport.unpark(暂停线程对象)</p><p>与 Object 的 wait &amp; notify 相比：</p><p>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</p><p>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll </p><p>是唤醒所有等待线程，就不那么【精确】</p><p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</p><p>底层实现原理:也是使用的Unsafe类的unpark方法。</p><h2 id="29、Lock锁"><a href="#29、Lock锁" class="headerlink" title="29、Lock锁"></a>29、Lock锁</h2><p>Lock实现提供比使用synchronized方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象Condition.</p><p>对比synchronzied的特点:</p><p>1、可重入</p><p>2、可以设置超时时间</p><p>3、可以设置为公平锁</p><p>4、支持多个条件变量</p><p>ReentrantLock(可重入锁)、ReentrantReadWriteLock.ReadLock（读锁）、ReentrantReadWriteLock.WriteLock(写锁)</p><p>如何使用</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UseReentrantLock</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> ReentrantLock lock<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">try</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//所需操作</span>         <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>             e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>             lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="30、lock和synchronized的区别"><a href="#30、lock和synchronized的区别" class="headerlink" title="30、lock和synchronized的区别:"></a>30、lock和synchronized的区别:</h2><p>1、lock是java.utils.current包下的接口，synchronzied是属于java官方给内置关键字。</p><p>2、synchronized无法判断获取锁的状态，lock可以判断是否获取锁。</p><p>3、synchronized会执行我们的业务操作后会自动释放锁，而我们的lock是需要我们搭配tryfinally一起使用手动的释放锁。</p><p>4、synchronzied如果存在多个线程获取锁的话，其中只有一个线程可以获取到锁，其他的线程会被阻塞住。lock锁可以去尝试获取锁。</p><p>5、synchronized的锁是可重入、不可中断、非公平，lock锁可重入、可中断、可公平的锁。</p><h2 id="31、如何精准的控制lock"><a href="#31、如何精准的控制lock" class="headerlink" title="31、如何精准的控制lock:"></a>31、如何精准的控制lock:</h2><p>使用的是条件变量来进行控制.</p><p>synchronized提供了wait和notify来进行线程之间的通信.</p><p>而ReentrantLock的条件变量比synchronized强大之处就在于，它是支持多个条件变量的。</p><p>synchronized是那些不满足条件的线程在同一间休息室中等消息。</p><p>而ReentrantLock支持多件休息室，让不同的条件的线程进入到不同的休息室。然后进行精确唤醒.</p><p>await方法，线程等待</p><p>signal()方法，唤醒线程</p><h2 id="32、JUC的几个辅助类"><a href="#32、JUC的几个辅助类" class="headerlink" title="32、JUC的几个辅助类:"></a>32、JUC的几个辅助类:</h2><p>1、CountDownLatch类，允许一个类或多个类等待直到其他线程执行完一组操作的同步辅助</p><p>用来进行线程同步协作，等待所有线程完成倒计时。其中构造参数用来初始化等待计数值，await()用来等待计数归零，countDown()用来让计数减一</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDawnLatch1</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> CountDownLatch count<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>           <span class="token keyword">try</span> <span class="token punctuation">{</span>               TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程一正在执行....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           count<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程二正在执行....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程三正在执行....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            count<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            count<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程四正在执行...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>2、CyclicBarrier</p><p>允许一组线程全部等待彼此达到共同屏障点的同步辅助。 循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 屏障被称为循环 ，因为它可以在等待的线程被释放之后重新使用。</p><p>作用：它的作用就是会让所有线程都等待完成后才会继续下一步行动。<br>它和CountDownLatch一样，只不过一个时减一个时加</p><p>CyclicBarrier是使用我们的ReentrantLock来进行实现的。</p><p>如果调用了await()方法,</p><p><strong>1、先检查前面是否已经有count个线程了，如果没有线程则会进入等待状态</strong><br><strong>2、当检测到屏障已经有count个线程了，则所有线程会冲出屏障继续执行（如果有Runnable参数的构造方法先执行汇总方法）</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"老师进行关门"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t 学生出门"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>3、Semaphore</p><p>1、acquire(获取)当一个线程调用acquire操作时,它要么通过成功获取信号量(信号量减一)，要么一直等下去,直到有线程释法信号量，或超时。</p><p>2、release(释放)实际上会将信号量的值加1，然后唤醒等待的线程。</p><p>信号量主要作用于两个目的,一个时用于多个线程共享资源的互斥使用,另一个用于并发线程数的控制</p><p>使用Semaphore限流，在访问最高峰期时,让请求线程阻塞，高峰期过去在释放许可,当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数</p><p>用Semaphore实现简单连接池，对比享元模式下的实现(wait notify)，性能和可读性显然更好。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Semaphore1</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//抢车位 可以用来秒杀业务</span>        Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//只有三个车位</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span><span class="token number">6</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t 抢占类车位"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t 离开类车位"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Semaphore原理:</p><p>加锁解锁流程:</p><p>Semaphore有点像一个停车场,permits就好像停车位数量，当线程获取了permist就像是获得了停车位，然后停车场显示空余车位减一</p><p>刚开始,permist为3，这时5个线程来获取资源</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220803165430483.png" alt="image-20220803165430483"></p><p>假设其中Thread-1，Thread-2，Thread-4 cas竞争成功,而Thread-0和Thread-3竞争失败,进入AQS队列park阻塞。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220803173153987.png" alt="image-20220803173153987"></p><p>这时Thread-4释放了permist，状态如下:</p><pre class=" language-java"><code class="language-java">sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220803173235251.png" alt="image-20220803173235251"></p><p>接下来Thread-0竞争成功，permist再次设置为0，设置自己为head节点，断开原来的head节点，unpark接下来Thread-3节点，但由于permist是0，因此Thread-3在尝试不成功后再次进入park状态。</p><h2 id="33、AQS是什么？"><a href="#33、AQS是什么？" class="headerlink" title="33、AQS是什么？"></a>33、AQS是什么？</h2><p>全称是AbstractQueuedSynchronized是阻塞式锁和同步器工具开发的框架。</p><p>特点:</p><p>使用state属性来表示资源的状态,子类需要定义如何维护这个状态，控制如何获取。</p><p>锁的获取和释放：</p><ul><li>getState：获取锁的状态</li><li>setState：设置state的状态</li><li>compareAndSetState:利用cas来设置state状态</li></ul><p>独占模式表示只有一个线程能访问资源，而共享模式可以允许多个线程访问资源。</p><p>提供了机遇FIFO的等待队列。类似于MInitor的EntryList。条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet子类主要实现这样一些方法(默认抛出UNsupportedOperationException)</p><p>tryAcquice尝试获取锁<br>tryRelease 尝试释放锁</p><p>基本思想:</p><p>  通过修改AQS中的state来判断是否加锁成功，如果cas为1，则表示加锁成功，然后将owner置为当前线程。<br>  释放锁的逻辑，判断state是否为1，为1表示有锁，修改0，表示无锁，然后将owner置为null。<br>要点:</p><ul><li>原子维护state状态。</li><li>阻塞及恢复线程</li><li>维护队列</li></ul><p>state使用volatile配合cas包装其修改时的原子性</p><h2 id="34、ReentrantLock原理"><a href="#34、ReentrantLock原理" class="headerlink" title="34、ReentrantLock原理:"></a>34、ReentrantLock原理:</h2><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220706110401775.png" alt="image-20220706110401775"></p><p>非公共锁的实现:</p><p>加锁流程:</p><p>先从构造器开始看,默认为非公平锁实现: sync&#x3D;new NonfairSync即成于AQS<br>没有竞争时:</p><p>直接将锁NofairSync里面的owner置为当前线程即可。</p><p>当有竞争时:</p><p>1、Thread-1去尝试执行cas改为1，结果失败的。</p><p>2、进入到tryAcquire逻辑，这时state已经是1，结果仍然失败。</p><p>3、接下来进入addWaiter逻辑，构造Node队列:</p><p>其中第一个Node称为头节点，用来占位，并不关联线程。</p><p>4、当前线程会进入到AcquireQueued逻辑:</p><ul><li>acquireQueued会在一个死循环中不断尝试获取锁，失败后进入park阻塞。</li><li>如果自己是近邻着head(排第二位),那么再次tryAcquire尝试获取锁，当然这是state仍未1，失败。</li><li>进入shouIdParkAfterFailedAcquire逻辑，将前驱node，即head到waitStatus改为-1，这次返回false</li></ul><p>5、shouIdparkAfterFailedAcquired执行完毕回到acquireQueued，再次tryAcquire尝试获取锁，当然这是state仍为1，失败。</p><p>6、当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</p><p>7、进入 parkAndCheckInterrupt， Thread-1 park(灰色表示)</p><p>8、再次有多个线程经历上述过程竞争失败，变成这个样子</p><p>9、Thread-0 释放锁，进入 tryRelease 流程，如果成功</p><ul><li>设置onwer为null，将state改为0.表示解锁成功。</li></ul><p>10、当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor 流程找到队列中离 head 最近的一个 Node(没取消的)，unpark 恢复其运行，本例中即为 Thread-1 回到Thread-1 的 acquireQueued 流程</p><p>11、如果加锁成功(没有竞争)，会设置omwer为当前线程，并把这个state设置1.表示加锁成功,head指向刚刚Thread-1所在的Node，该Node清空Thread。原本的Head因为链表断开，被垃圾回收。</p><h2 id="35、读写锁ReadWirteLock"><a href="#35、读写锁ReadWirteLock" class="headerlink" title="35、读写锁ReadWirteLock"></a>35、读写锁ReadWirteLock</h2><p>读写锁ReadWirteLock:一对关联的locks，一个用于只读操作，一个用于写入。</p><p>为什么会存在呢</p><p>因为之前的lock它是全锁而不是分离锁，我们一般情况下只有在修改的情况下才需要加锁，在读的情况下，是不需要加锁的。</p><p>读读可共享、读写谢谢要独占。</p><p>总结：读的时候是共享锁(都能读,不能写),写的时候排它锁(只能当下的线程写，不能读)</p><h2 id="36、Blocking"><a href="#36、Blocking" class="headerlink" title="36、Blocking"></a>36、Blocking</h2><p>Blocking大部分实现基于锁,并提供用来阻塞的方法</p><p>BlockingQueue阻塞队列：先进先出</p><p>当队列是空的，从队列中获取元素的操作将会被阻塞</p><p>当队列是满的，从队列中添加元素的操作将会被阻塞</p><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1、OSI-和-TCP-x2F-IP-网络分层模型"><a href="#1、OSI-和-TCP-x2F-IP-网络分层模型" class="headerlink" title="1、OSI 和 TCP&#x2F;IP 网络分层模型"></a>1、OSI 和 TCP&#x2F;IP 网络分层模型</h2><p>OSI七层模式时国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示:</p><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-model-detail.png" alt="img"></p><p>1、物理层:机械、电子、定时接口通信信道上的原始比特流传输</p><p>2、数据链路层:物理寻址，同时将原始比特流转变为逻辑传输线路。</p><p>3、网络层:控制子网的允许，如逻辑编址、分组传输、路由选择。</p><p>4、传输层:接收上一层的数据，在必要的时候把数据进行分割，并将这些数据交给网络层，且保证这些数据段有效到达对端。</p><p>5、会话层:不同机器上的用户之间建立及管理会话。</p><p>6、表示层:信息的语法语义以及它们的关联，如加密解密、转换翻译、压缩解压缩。</p><p>7、应用层:各种应用程序协议，如http、ftp等</p><h2 id="2、TCP-x2F-IP四层模型"><a href="#2、TCP-x2F-IP四层模型" class="headerlink" title="2、TCP&#x2F;IP四层模型"></a>2、TCP&#x2F;IP四层模型</h2><p><strong>TCP&#x2F;IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP &#x2F; IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p>1、应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。我们把应用层交互的数据单元称为报文。</p><p>应用层协议定义网络通信规则，对于不同的网络应用需要不同的应用层协议。web应用的http协议。邮件SMTP协议等。</p><p>2、传输层</p><p>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。”通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p><p>运输层主要使用以下两种协议:</p><ul><li><p>传输控制协议TCP– 提供面向连接的可靠的数据传输服务。</p></li><li><p>用户传输协议UDP– 提供无连接的，尽最大努力的数据传输服务(不保证数据传输的可靠性)</p></li></ul><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/transport-layer-protocol.png" alt="传输层重要协议"></p><p>3、网络层</p><p>网路层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p><p><strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p><p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p><p>网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Prococol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</p><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/nerwork-layer-protocol.png" alt="网络层重要协议"></p><p><strong>网络层常见协议</strong> ：</p><ul><li>IP协议：网际协议 IP 是TCP&#x2F;IP协议中最重要的协议之一，也是网络层最重要的协议之一，IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。目前IP协议主要分为两种，一种是过去的IPv4，另一种是较新的IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li></ul><p>4、网络接口层</p><p>我们把网络接口层看作是数据链路层和物理层的合体。</p><p>1、数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></p><p>2、物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</p><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/network-interface-layer-protocol.png" alt="网络接口层重要协议"></p><p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p><h2 id="3、应用层有哪些常见的协议"><a href="#3、应用层有哪些常见的协议" class="headerlink" title="3、应用层有哪些常见的协议"></a>3、应用层有哪些常见的协议</h2><p>1、HTTP:超文本传输协议</p><p><strong>超文本传输协议（HTTP，HyperText Transfer Protocol)</strong> 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。</p><p><img src="https://oss.javaguide.cn/github/javaguide/450px-HTTP-Header.png" alt="img"></p><p>HTTP 协议是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p><p>另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。</p><p>2、SMTP协议:简单邮件传输协议</p><p><strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong> 基于 TCP 协议，用来发送电子邮件。SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p><ol><li>电子邮件的发送过程</li><li>如何判断邮箱是真正存在的？</li></ol><p><strong>电子邮件的发送过程？</strong></p><p>比如我的邮箱是“<a href="mailto:&#x64;&#97;&#98;&#97;&#x69;&#x40;&#99;&#115;&#x7a;&#104;&#105;&#110;&#97;&#110;&#x2e;&#x63;&#111;&#x6d;">&#x64;&#97;&#98;&#97;&#x69;&#x40;&#99;&#115;&#x7a;&#104;&#105;&#110;&#97;&#110;&#x2e;&#x63;&#111;&#x6d;</a>”，我要向“<a href="mailto:&#x78;&#x69;&#97;&#111;&#109;&#x61;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;">&#x78;&#x69;&#97;&#111;&#109;&#x61;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;</a>”发送邮件，整个过程可以简单分为下面几步：</p><ol><li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给163邮箱服务器（邮局）。</li><li>163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。</li><li>qq邮箱服务器接收邮件之后就通知邮箱为“<a href="mailto:&#x78;&#x69;&#97;&#x6f;&#x6d;&#97;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d;">&#x78;&#x69;&#97;&#x6f;&#x6d;&#97;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d;</a>”的用户来收邮件，然后用户就通过 <strong>POP3&#x2F;IMAP</strong> 协议将邮件取出。</li></ol><p>注意⚠️：<strong>接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p><p><strong>如何判断邮箱是真正存在的？</strong></p><p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p><ol><li>查找邮箱域名对应的 SMTP 服务器地址</li><li>尝试与服务器建立连接</li><li>连接成功后尝试向需要验证的邮箱发送邮件</li><li>根据返回结果判定邮箱地址的真实性</li></ol><p>3、FTP:文件传输协议</p><p><strong>FTP 协议</strong> 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p><p>FTP 是基于客户—服务器（C&#x2F;S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p><blockquote><p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p><ol><li>控制连接：用于传送控制信息（命令和响应）</li><li>数据连接：用于数据传送；</li></ol><p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p></blockquote><p>4、SSH:安全的网络传输协议</p><p><strong>SSH（ Secure Shell）</strong> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</p><h2 id="4、TCP和UDP的区别"><a href="#4、TCP和UDP的区别" class="headerlink" title="4、TCP和UDP的区别"></a>4、TCP和UDP的区别</h2><p>1、是否面向连接:UDP在传输数据之前不需要先建立连接。而TCP提供面向连接的服务，在传输数据之前必须先建立连接，数据传输结束后释放连接。</p><p>2、是否是可靠传输:远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p><p>3、是否有状态:TCP是传输有状态，记录自己发送消息的状态比如是否发送了、是否被接收了等等。UDP是无状态服务。简单来说就是不管发出去之后的事情。</p><p>4、传输效率:UDP传输是高于我们的TCP。</p><p>5、传输形式:TCP是面向字节流的，UDP是面向报文的。</p><p>6、是否提供广播服务:TCP只支持点对点的通信，UDP支持一对一、一对多、多对多。</p><p>应用场景:</p><p>1、udp一般用于即时通信,比如:语音、视频、直播等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别不是很大。</p><p>2、TCP一般用于传输准确性要求特别高的场景，比如:文件传输、发送和接收邮件等。</p><h2 id="5、HTTP基于TCP还是UDP？"><a href="#5、HTTP基于TCP还是UDP？" class="headerlink" title="5、HTTP基于TCP还是UDP？"></a>5、HTTP基于TCP还是UDP？</h2><p>HTTP 3.0 之前是基于 TCP 协议的，而 HTTP3.0 将弃用 TCP，改用 <strong>基于 UDP 的 QUIC 协议</strong> 。此变化主要为了解决 HTTP&#x2F;2 中存在的队头阻塞问题。由于 HTTP&#x2F;2 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。</p><h2 id="6、使用TCP端协议有哪些？使用UDP端协议有哪些？"><a href="#6、使用TCP端协议有哪些？使用UDP端协议有哪些？" class="headerlink" title="6、使用TCP端协议有哪些？使用UDP端协议有哪些？"></a>6、使用TCP端协议有哪些？使用UDP端协议有哪些？</h2><p>运行于TCP协议之上的协议：</p><p>1、HTTP协议:超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</p><p>2、HTTPS协议:更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</p><p>3、<strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，<strong>基于 TCP</strong> 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p><p>4、<strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</p><p>运行于UDP协议:</p><ol><li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li><li><strong>DNS</strong> ： <strong>域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href="http://www.baidu.com/">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。</strong> 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。</li></ol><h2 id="7、TCP三次握手和四次挥手-非常重要🌟🌟🌟🌟🌟"><a href="#7、TCP三次握手和四次挥手-非常重要🌟🌟🌟🌟🌟" class="headerlink" title="7、TCP三次握手和四次挥手(非常重要🌟🌟🌟🌟🌟)"></a>7、TCP三次握手和四次挥手(非常重要🌟🌟🌟🌟🌟)</h2><h3 id="7-1-、TCP三次握手"><a href="#7-1-、TCP三次握手" class="headerlink" title="7.1 、TCP三次握手:"></a>7.1 、TCP三次握手:</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" alt="TCP 三次握手图解"></p><p>建立一个TCP连接需要”三次握手”,缺一不可:</p><ul><li>一次握手:客户端发送带有SYN(SEQ&#x3D;x)标志的数据包–&gt;服务端，然后客户端会进入到send状态，等待服务器端确认。</li><li>二次握手:服务端发送带有SYN+ACK标志的数据包–&gt;客户端。</li><li>第三次握手:客户端发送带有ACK(ACK&#x3D;y+1)标志的数据包–&gt;服务端，然后客户端和服务器都进入<strong>确认状态</strong>完成TCP三次握手。</li></ul><p>当建立三次握手之后，客户端和服务器就可以传输数据啦！</p><h3 id="7-2-、为什么要三次握手"><a href="#7-2-、为什么要三次握手" class="headerlink" title="7.2 、为什么要三次握手"></a>7.2 、为什么要三次握手</h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p><p><strong>第一次握手</strong> ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p><strong>第二次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p><strong>第三次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>三次握手就能确认双方收发功能都正常，缺一不可。</p><h2 id="7-3-断开连接-TCP-四次挥手"><a href="#7-3-断开连接-TCP-四次挥手" class="headerlink" title="7.3  断开连接-TCP 四次挥手"></a>7.3  断开连接-TCP 四次挥手</h2><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png" alt="TCP 四次挥手图解"></p><p>断开一个TCP连接则需要”四次挥手”,缺一不可:</p><p><strong>第一次挥手</strong> ：客户端发送一个 FIN（SEQ&#x3D;X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</p><p><strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （SEQ&#x3D;X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</p><p><strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</p><p><strong>第四次挥手</strong> ：客户端发送 ACK (SEQ&#x3D;y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</p><p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p><h3 id="7-4-为什么要四次挥手？"><a href="#7-4-为什么要四次挥手？" class="headerlink" title="7.4 为什么要四次挥手？"></a>7.4 为什么要四次挥手？</h3><p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后。</p><ol><li><strong>第一次挥手</strong> ： A 说“我没啥要说的了”</li><li><strong>第二次挥手</strong> ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li><li><strong>第三次挥手</strong> ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li><li><strong>第四次挥手</strong> ：A 回答“知道了”，这样通话才算结束。</li></ol><h2 id="8、HTTP"><a href="#8、HTTP" class="headerlink" title="8、HTTP"></a>8、HTTP</h2><p>从输入URL到页面展示到底发生了什么？(非常重要🌟🌟🌟🌟🌟)</p><p><img src="https://oss.javaguide.cn/github/javaguide/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="img"></p><p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p><p>总体来说分为以下几个过程:</p><ol><li>DNS 解析:将浏览器的域名解析(DNS)成IP地址</li><li>TCP 连接：浏览器会向我们的服务器发送一个HTTP请求之前，会先经过我们的三次握手建立一个TCP连接。发送数据在网络层使用IP协议来进行数据的发送。</li><li>发送 HTTP 请求:使用HTTP协议访问网页。</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h2 id="9、HTTP状态码"><a href="#9、HTTP状态码" class="headerlink" title="9、HTTP状态码"></a>9、HTTP状态码</h2><p>HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。</p><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png" alt="常见 HTTP 状态码"></p><h2 id="10、HTTP和HTTPS有什么区别"><a href="#10、HTTP和HTTPS有什么区别" class="headerlink" title="10、HTTP和HTTPS有什么区别?"></a>10、HTTP和HTTPS有什么区别?</h2><p><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</p><p><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</p><p><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p><h2 id="11、HTTP-是不保存状态的协议-如何保存用户状态"><a href="#11、HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="11、HTTP 是不保存状态的协议, 如何保存用户状态?"></a>11、HTTP 是不保存状态的协议, 如何保存用户状态?</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p><strong>Cookie 被禁用怎么办?</strong></p><p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p><h2 id="12-、URI-和-URL-的区别是什么"><a href="#12-、URI-和-URL-的区别是什么" class="headerlink" title="12 、URI 和 URL 的区别是什么?"></a>12 、URI 和 URL 的区别是什么?</h2><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li><li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h2 id="13、ARP"><a href="#13、ARP" class="headerlink" title="13、ARP"></a>13、ARP</h2><h3 id="什么是-Mac-地址？"><a href="#什么是-Mac-地址？" class="headerlink" title="什么是 Mac 地址？"></a>什么是 Mac 地址？</h3><p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。</p><p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p><blockquote><p> 还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。</p></blockquote><p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（$2^{48}$），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。</p><p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p><p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p><h3 id="ARP-协议解决了什么问题地位如何？"><a href="#ARP-协议解决了什么问题地位如何？" class="headerlink" title="ARP 协议解决了什么问题地位如何？"></a>ARP 协议解决了什么问题地位如何？</h3><p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2023/03/29/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/03/29/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><h2 id="1-2-结构"><a href="#1-2-结构" class="headerlink" title="1.2 结构"></a>1.2 结构</h2><p>原型模式包含如下角色:</p><ul><li>抽象原型类:规定了具体原型对象必须实现的的 clone() 方法。 </li><li>具体原型类:实现抽象原型类的 clone() 方法，它是可被复制的对象。 </li><li>访问类:使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><p>接口类图如下:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230329182720307.png" alt="image-20230329182720307"></p><h2 id="1-3-实现"><a href="#1-3-实现" class="headerlink" title="1.3 实现"></a>1.3 实现</h2><p>原型模式的克隆分为浅克隆和深克隆。</p><ul><li>浅克隆:创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li><li>深克隆:创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li></ul><p>Java中的Object类中提供了 clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下:</p><p>Realizetype(具体的原型类):</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Prototype</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//返回具体的复制对象</span>    <span class="token keyword">public</span> <span class="token function">Prototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体的原型对象创建完成"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Prototype <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体原型复制成功！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>Prototype<span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>PrototypeTest</strong>：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrototypeTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        Prototype r1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Prototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Prototype r2 <span class="token operator">=</span> r1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对象r1和r2是同一个对象?"</span> <span class="token operator">+</span> <span class="token punctuation">(</span>r1 <span class="token operator">==</span> r2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>结果如下:</p><pre class=" language-java"><code class="language-java">具体的原型对象创建完成具体原型复制成功！对象r1和r2是同一个对象<span class="token operator">?</span><span class="token boolean">false</span></code></pre><h2 id="1-4-使用场景"><a href="#1-4-使用场景" class="headerlink" title="1.4 使用场景"></a>1.4 <strong>使用场景</strong></h2><ul><li><p>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</p></li><li><p>性能和安全要求比较高</p></li></ul><h2 id="1-5-扩展-深克隆"><a href="#1-5-扩展-深克隆" class="headerlink" title="1.5 扩展(深克隆)"></a>1.5 <strong>扩展(深克隆)</strong></h2><p>要想使用深克隆必须使用我们的对象流来进行。</p><pre class=" language-java"><code class="language-java">Prototype r1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Prototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>FileOutputStream fos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ObjectOutputStream oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>fos<span class="token punctuation">)</span><span class="token punctuation">;</span>oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>r1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用我们的对象的输入流进行解析</span>ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\Think\\Desktop\\b.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//读取对象</span>Prototype c2 <span class="token operator">=</span> <span class="token punctuation">(</span>Prototype<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>注意⚠️:Prototype类必须实现Serializable接口，否则会抛 NotSerializableException异常。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试体总结</title>
      <link href="/2023/03/28/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2023/03/28/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>支付宝支付</title>
      <link href="/2023/03/23/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98/"/>
      <url>/2023/03/23/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98/</url>
      
        <content type="html"><![CDATA[<h2 id="支付接口的调研"><a href="#支付接口的调研" class="headerlink" title="支付接口的调研:"></a>支付接口的调研:</h2><h3 id="微信支付接口调研"><a href="#微信支付接口调研" class="headerlink" title="微信支付接口调研:"></a>微信支付接口调研:</h3><p>一般情况下，一个网站要支持在线支付功能通常接入第三方支付平台，比如：微信支付、支付宝、其它的聚合支付平台。</p><p>本项目的需求实现手机扫码支付，现在对微信、支付宝的支付接口进行调研。</p><p>微信目前提供的支付方式如下：</p><p>地址：<a href="https://pay.weixin.qq.com/static/product/product_index.shtml">https://pay.weixin.qq.com/static/product/product_index.shtml</a></p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160603449.png" alt="image-20230323160603449"></p><ol><li><p>付款码支付是指用户展示微信钱包内的“付款码”给商户系统扫描后直接完成支付，适用于线下场所面对面收银的场景，例如商超、便利店、餐饮、医院、学校、电影院和旅游景区等具有明确经营地址的实体场所。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160633442.png" alt="image-20230323160633442"></p></li><li><p>SAPI支付是指商户通过调用微信支付提供的JSAPI接口，在支付场景中调起微信支付模块完成收款</p><p>线下场所：调用接口生成二维码，用户扫描二维码后在微信浏览器中打开页面后完成支付</p><p>公众号场景：用户在微信公众账号内进入商家公众号，打开某个主页面，完成支付</p><p>PC网站场景：在网站中展示二维码，用户扫描二维码后在微信浏览器中打开页面后完成支付</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160650164.png" alt="image-20230323160650164"></p></li><li><p>小程序支付是指商户通过调用微信支付小程序支付接口，在微信小程序平台内实现支付功能；用户打开商家助手小程序下单，输入支付密码并完成支付后，返回商家小程序。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160710635.png" alt="image-20230323160710635"></p></li><li><p>Native支付是指商户系统按微信支付协议生成支付二维码，用户再用微信“扫一扫”完成支付的模式。该模式适用于PC网站、实体店单品或订单、媒体广告支付等场景。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160729715.png" alt="image-20230323160729715"></p></li><li><p>APP支付是指商户通过在移动端应用APP中集成开放SDK调起微信支付模块来完成支付。适用于在移动端APP中集成微信支付功能的场景。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160750086.png" alt="image-20230323160750086"></p></li><li><p>刷脸支付是指用户在刷脸设备前通过摄像头刷脸、识别身份后进行的一种支付方式，安全便捷。适用于线下实体场所的收银场景，如商超、餐饮、便利店、医院、学校等。</p></li></ol><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160805994.png" alt="image-20230323160805994"></p><p>以上接口native和JSAPI都可以实现pc网站实现扫码支付，两者区别是什么？怎么选择？</p><p>JSAPI除了在pc网站扫码支付还可以实现公众号页面内支付，可以实现在H5页面唤起微信客户端完成支付。</p><p>本项目选择JSAPI支付接口。</p><p>接口文档：<a href="https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_1.shtml">https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_1.shtml</a></p><p>如果要微信的话需要开通账号认证。</p><h3 id="支付宝接口调研"><a href="#支付宝接口调研" class="headerlink" title="支付宝接口调研:"></a>支付宝接口调研:</h3><p>支付宝支付产品如下：</p><p>文档：<a href="https://b.alipay.com/signing/productSetV2.htm">https://b.alipay.com/signing/productSetV2.htm</a></p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160945145.png" alt="image-20230323160945145"></p><p>与本项目需求相关的接口：电脑网站支付、手机网站支付。</p><p>1、电脑网站支付</p><p>PC网站轻松收款，资金马上到账：用户在商家PC网站消费，自动跳转支付宝PC网站收银台完成付款。 交易资金直接打入商家支付宝账户，实时到账。</p><p><img src="https://gw.alipayobjects.com/mdn/rms_e15e15/afts/img/A*bbMhQJxew7wAAAAAAAAAAABjARQnAQ" alt="img"></p><p>2、手机网站支付</p><p><img src="https://gw.alipayobjects.com/mdn/rms_e15e15/afts/img/A*KhnKRKr3vsEAAAAAAAAAAABjARQnAQ" alt="img"></p><p>用户在商家手机网站消费，通过浏览器自动跳转支付宝APP或支付宝网页完成付款。 轻松实现和APP支付相同的支付体验。</p><p>对比两种支付方式：手机网站支付方式可以在H5网页唤起支付宝，手机扫码支付可以使用手机网站支付方式来完成，相比电脑网站支付形式更灵活。</p><p>本项目选择手机网站支付方式。</p><p>文档：<a href="https://opendocs.alipay.com/open/02ivbt">https://opendocs.alipay.com/open/02ivbt</a></p><h3 id="准备开发环境"><a href="#准备开发环境" class="headerlink" title="准备开发环境"></a>准备开发环境</h3><p>第三方支付接口流程大同小异，考虑开发及教学的方便性，支付宝提供支付宝沙箱环境开发支付接口，在教学中接入支付宝手机网站支付接口。</p><p>1、配置沙箱环境</p><p>沙箱环境是支付宝开放平台为开发者提供的与生产环境完全隔离的联调测试环境，开发者在沙箱环境中完成的接口调用不会对生产环境中的数据造成任何影响。</p><p>接入手机网站支付需要具备如下条件：</p><p>•    申请前必须拥有经过实名认证的支付宝账户；</p><p>•    企业或个体工商户可申请；</p><p>•    需提供真实有效的营业执照，且支付宝账户名称需与营业执照主体一致；</p><p>•    网站能正常访问且页面显示完整，网站需要明确经营内容且有完整的商品信息；</p><p>•    网站必须通过ICP备案。如为个体工商户，网站备案主体需要与支付宝账户主体名称一致；</p><p>•    如为个体工商户，则团购不开放，且古玩、珠宝等奢侈品、投资类行业无法申请本产品。</p><p>详细参见：<a href="https://docs.open.alipay.com/203">https://docs.open.alipay.com/203</a></p><p>本文档使用支付宝沙箱进行开发测试，这里主要介绍支付宝沙箱环境配置。</p><p>详细参见：<a href="https://docs.open.alipay.com/200/105311/">https://docs.open.alipay.com/200/105311/</a></p><h3 id="创建一个订单服务"><a href="#创建一个订单服务" class="headerlink" title="创建一个订单服务"></a>创建一个订单服务</h3><p>创建订单服务过程study-plus-orders到自己的过程目录。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323195840976.png" alt="image-20230323195840976"></p><h3 id="支付接口测试"><a href="#支付接口测试" class="headerlink" title="支付接口测试"></a>支付接口测试</h3><p>手机网站支付接入流程详细参见：<a href="https://docs.open.alipay.com/203/105285/">https://docs.open.alipay.com/203/105285/</a></p><h4 id="1、接口交互流程如下："><a href="#1、接口交互流程如下：" class="headerlink" title="1、接口交互流程如下："></a>1、接口交互流程如下：</h4><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323203611508.png" alt="image-20230323203611508"></p><p>1）用户在商户的H5网站下单支付后，商户系统按照<a href="https://docs.open.alipay.com/203/107090">手机网站支付接口alipay.trade.wap.pay</a>API的参数规范生成订单数据</p><p>2）前端页面通过Form表单的形式请求到支付宝。此时支付宝会自动将页面跳转至支付宝H5收银台页面，如果用户手机上安装了支付宝APP，则自动唤起支付宝APP。</p><p>3）输入支付密码完成支付。</p><p>4）用户在支付宝APP或H5收银台完成支付后，会根据商户在手机网站支付API中传入的前台回跳地址return_url自动跳转回商户页面，同时在URL请求中以Query String的形式附带上支付结果参数，详细回跳参数见“手机网站支付接口alipay.trade.wap.pay”<a href="https://docs.open.alipay.com/203/107090#s2">前台回跳参数</a>。</p><p>5）支付宝还会根据原始支付API中传入的异步通知地址notify_url，通过POST请求的形式将支付结果作为参数通知到商户系统，详情见<a href="https://docs.open.alipay.com/203/105286">支付结果异步通知</a>。</p><h4 id="2、接口定义"><a href="#2、接口定义" class="headerlink" title="2、接口定义:"></a>2、接口定义:</h4><p>文档:<a href="https://opendocs.alipay.com/open/203/107090">https://opendocs.alipay.com/open/203/107090</a></p><p>接口定义：外部商户请求支付宝创建订单并支付</p><p>公共参数</p><p><strong>请求地址</strong>：</p><p>开发中使用沙箱地址：<a href="https://openapi.alipaydev.com/gateway.do">https://openapi.alipaydev.com/gateway.do</a></p><p>请求参数：</p><p>详细查阅<a href="https://opendocs.alipay.com/open/203/107090">https://opendocs.alipay.com/open/203/107090</a></p><p>一部分由sdk设置，一部分需要编写程序时指定。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323204204833.png" alt="image-20230323204204833"></p><p>其它扩展参数参见接口文档。</p><h4 id="3、示例代码"><a href="#3、示例代码" class="headerlink" title="3、示例代码"></a>3、示例代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest httpRequest<span class="token punctuation">,</span>                   HttpServletResponse httpResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>    AlipayClient alipayClient <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//获得初始化的AlipayClient</span>    AlipayTradeWapPayRequest alipayRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlipayTradeWapPayRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建API对应的request</span>    alipayRequest<span class="token punctuation">.</span><span class="token function">setReturnUrl</span><span class="token punctuation">(</span><span class="token string">"http://domain.com/CallBack/return_url.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    alipayRequest<span class="token punctuation">.</span><span class="token function">setNotifyUrl</span><span class="token punctuation">(</span><span class="token string">"http://domain.com/CallBack/notify_url.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在公共参数中设置回跳和通知地址</span>    alipayRequest<span class="token punctuation">.</span><span class="token function">setBizContent</span><span class="token punctuation">(</span><span class="token string">"{"</span> <span class="token operator">+</span>            <span class="token string">"    \"out_trade_no\":\"20150320010101002\","</span> <span class="token operator">+</span>            <span class="token string">"    \"total_amount\":88.88,"</span> <span class="token operator">+</span>            <span class="token string">"    \"subject\":\"Iphone6 16G\","</span> <span class="token operator">+</span>            <span class="token string">"    \"product_code\":\"QUICK_WAP_WAY\""</span> <span class="token operator">+</span>            <span class="token string">"  }"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//填充业务参数</span>    String form <span class="token operator">=</span> alipayClient<span class="token punctuation">.</span><span class="token function">pageExecute</span><span class="token punctuation">(</span>alipayRequest<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用SDK生成表单</span>    httpResponse<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html;charset="</span> <span class="token operator">+</span> AlipayServiceEnvConstants<span class="token punctuation">.</span>CHARSET<span class="token punctuation">)</span><span class="token punctuation">;</span>    httpResponse<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>form<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接将完整的表单html输出到页面</span>    httpResponse<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="4、下单执行流程"><a href="#4、下单执行流程" class="headerlink" title="4、下单执行流程"></a>4、<strong>下单执行流程</strong></h4><p>根据接口描述，支付宝下单接口的执行流程如下：</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323204555884.png" alt="image-20230323204555884"></p><h4 id="5、支付接口测试"><a href="#5、支付接口测试" class="headerlink" title="5、支付接口测试"></a>5、<strong>支付接口测试</strong></h4><p><strong>编写下单代码</strong></p><p>根据接口流程，首先在订单服务编写测试类请求支付宝下单的接口。</p><p>在订单服务api工程添加依赖：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alipay.sdk<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>alipay-sdk-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.7.73.ALL<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 支付宝SDK依赖的日志 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>下载示例代码<a href="https://opendocs.alipay.com/open/203/105910">https://opendocs.alipay.com/open/203/105910</a></p><p>代码Demo编写:请求支付宝，拿起我们的请求页面</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/playTest"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest httpRequest<span class="token punctuation">,</span>                       HttpServletResponse httpResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException<span class="token punctuation">,</span> AlipayApiException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 测试的接口参数为:         * 1、url请求的地址         * 2、appid商户id         * 3、私钥         * 4、请求格式         * 5、编码         * 6、支付宝公钥         * 7、加密方式         */</span>        AlipayClient alipayClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultAlipayClient</span><span class="token punctuation">(</span>AlipayConfig<span class="token punctuation">.</span>URL<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>APPID<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>RSA_PRIVATE_KEY<span class="token punctuation">,</span> AlipayConfig<span class="token punctuation">.</span>FORMAT<span class="token punctuation">,</span> AlipayConfig<span class="token punctuation">.</span>CHARSET<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>ALIPAY_PUBLIC_KEY<span class="token punctuation">,</span>AlipayConfig<span class="token punctuation">.</span>SIGNTYPE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获得初始化的AlipayClient</span>        AlipayTradeWapPayRequest alipayRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlipayTradeWapPayRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建API对应的request</span><span class="token comment" spellcheck="true">//        alipayRequest.setReturnUrl("http://domain.com/CallBack/return_url.jsp");</span><span class="token comment" spellcheck="true">//        alipayRequest.setNotifyUrl("http://domain.com/CallBack/notify_url.jsp");//在公共参数中设置回跳和通知地址</span>        <span class="token comment" spellcheck="true">//out_trade_no商户的订单号</span><span class="token comment" spellcheck="true">//        total_amount订单的总金额</span>        <span class="token comment" spellcheck="true">//subject 订单标题。</span>        alipayRequest<span class="token punctuation">.</span><span class="token function">setBizContent</span><span class="token punctuation">(</span><span class="token string">"{"</span> <span class="token operator">+</span>                <span class="token string">"    \"out_trade_no\":\"20150320010101002\","</span> <span class="token operator">+</span>                <span class="token string">"    \"total_amount\":88.88,"</span> <span class="token operator">+</span>                <span class="token string">"    \"subject\":\"Iphone6 16G\","</span> <span class="token operator">+</span>                <span class="token string">"    \"product_code\":\"QUICK_WAP_WAY\""</span> <span class="token operator">+</span>                <span class="token string">"  }"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//填充业务参数</span>        String form <span class="token operator">=</span> alipayClient<span class="token punctuation">.</span><span class="token function">pageExecute</span><span class="token punctuation">(</span>alipayRequest<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用SDK生成表单</span>        httpResponse<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html;charset="</span> <span class="token operator">+</span> AlipayConfig<span class="token punctuation">.</span>CHARSET<span class="token punctuation">)</span><span class="token punctuation">;</span>        httpResponse<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>form<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接将完整的表单html输出到页面</span>        httpResponse<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a><strong>生成二维码</strong></h4><p>用户在前端使用支付宝沙箱通过扫码请求下单接口，我们需要生成订单服务的下单接口的二维码。</p><p>ZXing是一个开源的类库，是用Java编写的多格式的1D &#x2F; 2D条码图像处理库，使用ZXing可以生成、识别QR Code（二维码）。常用的二维码处理库还有zbar，近几年已经不再更新代码，下边介绍ZXing生成二维码的方法。</p><p>1）引入依赖</p><p>在base工程pom.xml中添加依赖：</p><pre class=" language-xml"><code class="language-xml"> <span class="token comment" spellcheck="true">&lt;!-- 二维码生成&amp;识别组件 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.google.zxing<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.3.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.google.zxing<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javase<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.3.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-lang3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>2）生成二维码方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>kevintam<span class="token punctuation">.</span>study<span class="token punctuation">.</span>utils<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>zxing<span class="token punctuation">.</span>BarcodeFormat<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>zxing<span class="token punctuation">.</span>EncodeHintType<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>zxing<span class="token punctuation">.</span>client<span class="token punctuation">.</span>j2se<span class="token punctuation">.</span>MatrixToImageWriter<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>zxing<span class="token punctuation">.</span>common<span class="token punctuation">.</span>BitMatrix<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>zxing<span class="token punctuation">.</span>qrcode<span class="token punctuation">.</span>QRCodeWriter<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>zxing<span class="token punctuation">.</span>qrcode<span class="token punctuation">.</span>decoder<span class="token punctuation">.</span>ErrorCorrectionLevel<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang3<span class="token punctuation">.</span>StringUtils<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>imageio<span class="token punctuation">.</span>ImageIO<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>ServletOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>awt<span class="token punctuation">.</span>image<span class="token punctuation">.</span>BufferedImage<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ByteArrayOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author Mr.M * @version 1.0 * @description 二维码生成工具 * @date 2022/10/3 0:03 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QRCodeUtil</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成二维码     *     * @param content 二维码对应的URL     * @param width   二维码图片宽度     * @param height  二维码图片高度     * @return     */</span>    <span class="token keyword">public</span> String <span class="token function">createQRCode</span><span class="token punctuation">(</span>String content<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        String resultImage <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//除了尺寸，传入内容不能为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ServletOutputStream stream <span class="token operator">=</span> null<span class="token punctuation">;</span>            ByteArrayOutputStream os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//二维码参数</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"rawtypes"</span><span class="token punctuation">)</span>            HashMap<span class="token operator">&lt;</span>EncodeHintType<span class="token punctuation">,</span> Comparable<span class="token operator">></span> hints <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//指定字符编码为“utf-8”</span>            hints<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>EncodeHintType<span class="token punctuation">.</span>CHARACTER_SET<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//L M Q H四个纠错等级从低到高，指定二维码的纠错等级为M</span>            <span class="token comment" spellcheck="true">//纠错级别越高，可以修正的错误就越多，需要的纠错码的数量也变多，相应的二维吗可储存的数据就会减少</span>            hints<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>EncodeHintType<span class="token punctuation">.</span>ERROR_CORRECTION<span class="token punctuation">,</span> ErrorCorrectionLevel<span class="token punctuation">.</span>M<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//设置图片的边距</span>            hints<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>EncodeHintType<span class="token punctuation">.</span>MARGIN<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//zxing生成二维码核心类</span>                QRCodeWriter writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QRCodeWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//把输入文本按照指定规则转成二维吗</span>                BitMatrix bitMatrix <span class="token operator">=</span> writer<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> BarcodeFormat<span class="token punctuation">.</span>QR_CODE<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> hints<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//生成二维码图片流</span>                BufferedImage bufferedImage <span class="token operator">=</span> MatrixToImageWriter<span class="token punctuation">.</span><span class="token function">toBufferedImage</span><span class="token punctuation">(</span>bitMatrix<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//输出流</span>                ImageIO<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bufferedImage<span class="token punctuation">,</span> <span class="token string">"png"</span><span class="token punctuation">,</span> os<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/**                 * 原生转码前面没有 data:image/png;base64 这些字段，返回给前端是无法被解析，所以加上前缀                 */</span>                resultImage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"data:image/png;base64,"</span> <span class="token operator">+</span> EncryptUtil<span class="token punctuation">.</span><span class="token function">encodeBase64</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> resultImage<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"生成二维码出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>stream <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    stream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    stream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        QRCodeUtil qrCodeUtil <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QRCodeUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>qrCodeUtil<span class="token punctuation">.</span><span class="token function">createQRCode</span><span class="token punctuation">(</span><span class="token string">"http://localhost:63050/orders/alipaytest"</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行main方法输入二维码图片的base64串，如下：</p><pre class=" language-bash"><code class="language-bash">data:image/png<span class="token punctuation">;</span>base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADIAQAAAACFI5MzAAABXUlEQVR42u2YSY6EMAxFnVWO4ZuS5KY5Rla4PRWgKvWm1VL+oiIkIh4L4+HbgeS3RV/yR7JIVxHpVc46ibjbA8YgrCYOvRYrHL63hxikEwfRL2i2oYJFZls8Yo9HikwL+8Ii4u7UNDwU1fc82EroZWxeb/Wzk7zWWaX7Kx+6s4+4L+8gLzoqDLHY0kF8mskqgZaSbTEG0Tv5slohr2DNRwwSvULvU32ptketQJBoFBZqleTZ3KNHdrPdxI0VT8Nh+9mioWEQU7u7b1DzPQYxDY4gh8m9+ndgkOHJaPJcw6NQJCPsQwr7WwxBPAFLVEmSq352E1flZt3M3KnKd5rGYBBv++UqjhXyLBAklnfals32ruDNJE855s6ycow6q2CQmDpDXTzOUSgY5DrlhFNt5BQkkkdDG/H6YwqAIN7/42gYGgNCnk0jquSZiVtJnnK6aV4oX3az/eT7v+p/yQ/ovSDjCl7mQgAAAABJRU5ErkJggg<span class="token operator">==</span></code></pre><h4 id="支付结果查询接口"><a href="#支付结果查询接口" class="headerlink" title="支付结果查询接口"></a><strong>支付结果查询接口</strong></h4><p>支付完成可以调用第三方支付平台的支付结果查询接口 查询支付结果。</p><p>文档：<a href="https://opendocs.alipay.com/open/02ivbt">https://opendocs.alipay.com/open/02ivbt</a></p><p>示例代码:</p><pre class=" language-java"><code class="language-java">AlipayClient alipayClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultAlipayClient</span><span class="token punctuation">(</span><span class="token string">"https://openapi.alipay.com/gateway.do"</span><span class="token punctuation">,</span><span class="token string">"app_id"</span><span class="token punctuation">,</span><span class="token string">"your private_key"</span><span class="token punctuation">,</span><span class="token string">"json"</span><span class="token punctuation">,</span><span class="token string">"GBK"</span><span class="token punctuation">,</span><span class="token string">"alipay_public_key"</span><span class="token punctuation">,</span><span class="token string">"RSA2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>AlipayTradeQueryRequest request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlipayTradeQueryRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>JSONObject bizContent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bizContent<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"out_trade_no"</span><span class="token punctuation">,</span> <span class="token string">"20150320010101001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//bizContent.put("trade_no", "2014112611001004680073956707");</span>request<span class="token punctuation">.</span><span class="token function">setBizContent</span><span class="token punctuation">(</span>bizContent<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>AlipayTradeQueryResponse response <span class="token operator">=</span> alipayClient<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>刚才订单付款成功，可以使用out_trade_no商品订单号或支付宝的交易流水号trade_no去查询支付结果。</p><p>out_trade_no商品订单号: 是在下单请求时指定的商品订单号。</p><p>支付宝的交易流水号trade_no：是支付完成后支付宝通知支付结果时发送的trade_no</p><p>我们使用out_trade_no商品订单号去查询，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"getOrder"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> AlipayApiException <span class="token punctuation">{</span>        AlipayClient alipayClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultAlipayClient</span><span class="token punctuation">(</span>AlipayConfig<span class="token punctuation">.</span>URL<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>APPID<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>RSA_PRIVATE_KEY<span class="token punctuation">,</span> AlipayConfig<span class="token punctuation">.</span>FORMAT<span class="token punctuation">,</span> AlipayConfig<span class="token punctuation">.</span>CHARSET<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>ALIPAY_PUBLIC_KEY<span class="token punctuation">,</span>AlipayConfig<span class="token punctuation">.</span>SIGNTYPE<span class="token punctuation">)</span><span class="token punctuation">;</span>        AlipayTradeQueryRequest request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlipayTradeQueryRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JSONObject bizContent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bizContent<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"out_trade_no"</span><span class="token punctuation">,</span> <span class="token string">"20150320010101002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//bizContent.put("trade_no", "2014112611001004680073956707");</span>        request<span class="token punctuation">.</span><span class="token function">setBizContent</span><span class="token punctuation">(</span>bizContent<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AlipayTradeQueryResponse response <span class="token operator">=</span> alipayClient<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>响应如下:</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"alipay_trade_query_response"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"code"</span><span class="token operator">:</span><span class="token string">"10000"</span><span class="token punctuation">,</span>                                <span class="token property">"msg"</span><span class="token operator">:</span><span class="token string">"Success"</span><span class="token punctuation">,</span>                                <span class="token property">"buyer_logon_id"</span><span class="token operator">:</span><span class="token string">"drf***@sandbox.com"</span><span class="token punctuation">,</span>                                <span class="token property">"buyer_pay_amount"</span><span class="token operator">:</span><span class="token string">"0.00"</span><span class="token punctuation">,</span>                                <span class="token property">"buyer_user_id"</span><span class="token operator">:</span><span class="token string">"2088102180608143"</span><span class="token punctuation">,</span>                                <span class="token property">"buyer_user_type"</span><span class="token operator">:</span><span class="token string">"PRIVATE"</span><span class="token punctuation">,</span>                                <span class="token property">"invoice_amount"</span><span class="token operator">:</span><span class="token string">"0.00"</span><span class="token punctuation">,</span>                                <span class="token property">"out_trade_no"</span><span class="token operator">:</span><span class="token string">"20150320010101002"</span><span class="token punctuation">,</span>                                <span class="token property">"point_amount"</span><span class="token operator">:</span><span class="token string">"0.00"</span><span class="token punctuation">,</span>                                <span class="token property">"receipt_amount"</span><span class="token operator">:</span><span class="token string">"0.00"</span><span class="token punctuation">,</span>                                <span class="token property">"send_pay_date"</span><span class="token operator">:</span><span class="token string">"2023-03-23 21:43:38"</span><span class="token punctuation">,</span>                                <span class="token property">"total_amount"</span><span class="token operator">:</span><span class="token string">"88.88"</span><span class="token punctuation">,</span>                                <span class="token property">"trade_no"</span><span class="token operator">:</span><span class="token string">"2023032322001408140511381202"</span><span class="token punctuation">,</span>                                <span class="token property">"trade_status"</span><span class="token operator">:</span><span class="token string">"TRADE_SUCCESS"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token property">"sign"</span><span class="token operator">:</span><span class="token string">"doZWWCAMJsxnOc12zHXFLCf2JrjgTjk7Qi2PnHld7EWDQZvhbUbR+3utVlX/S1G0Dh/SAWkNKd518xzQ+I3+LsGy4pF+BLR0vJzFUzZ8Ou13gjwxcjCBmUWBxdudRbTbtLaugZdBjPpxIn7+APuQYdIPuB/NLepUNqamkK4Zb+m7djtv81u13xlXjnFL/kXSUe2DEDtSlJj4LoZHiE6UrCph+Sqs70pD0vjbXP777NhqcugtK7hbpFhTpWfCCFDdL37nPS67ArwLpwo0HiGdbGyBiPYPKG1wkoJd7HmBI8xdZ6vF1LqNeXK5DWwp1STlX2+YWbPEBX37lBwmY9Ha4w=="</span><span class="token punctuation">}</span></code></pre><p>参考文档<a href="https://opendocs.alipay.com/open/02ivbt">https://opendocs.alipay.com/open/02ivbt</a> 查阅每个参数的意义。</p><p>我们主要需要下边的参数：</p><p>“out_trade_no” : “20220520010101026”,</p><p>“trade_no”:”2022100422001422760505740639” ： 支付宝交易流水号</p><p>“total_amount” : “1.30”</p><p>“trade_status” : “TRADE_SUCCESS”： 交易状态</p><p>交易状态类型：</p><p>交易状态：WAIT_BUYER_PAY（交易创建，等待买家付款）</p><p>TRADE_CLOSED（未付款交易超时关闭，或支付完成后全额退款）</p><p>TRADE_SUCCESS（交易支付成功）</p><p>TRADE_FINISHED（交易结束，不可退款）</p><h4 id="支付结果通知接口"><a href="#支付结果通知接口" class="headerlink" title="支付结果通知接口"></a><strong>支付结果通知接口</strong></h4><p>对于手机网站支付产生的交易，支付宝会根据原始支付 API 中传入的异步通知地址 notify_url，通过 POST 请求的形式将支付结果作为参数通知到商户系统。详情可查看 <a href="https://opendocs.alipay.com/support/01raw4">支付宝异步通知说明</a> 。</p><p>文档：<a href="https://opendocs.alipay.com/open/203/105286">https://opendocs.alipay.com/open/203/105286</a></p><p>根据下单执行流程，订单服务收到支付结果需要对内容进行验签，验签过程如下：</p><ol><li><p>在通知返回参数列表中，除去sign、sign_type两个参数外，凡是通知返回回来的参数皆是待验签的参数。将剩下参数进行 url_decode，然后进行字典排序，组成字符串，得到待签名字符串； 生活号异步通知组成的待验签串里需要保留 sign_type 参数。</p></li><li><p>将签名参数（sign）使用 base64 解码为字节码串；</p></li><li><p>使用 RSA 的验签方法，通过签名字符串、签名参数（经过 base64 解码）及支付宝公钥验证签名。</p></li><li><p>验证签名正确后，必须再严格按照如下描述校验通知数据的正确性。</p></li></ol><p>在上述验证通过后，商户必须根据支付宝不同类型的业务通知，正确的进行不同的业务处理，并且过滤重复的通知结果数据。</p><p>通过验证out_trade_no、total_amount、appid参数的正确性判断通知请求的合法性。</p><p>验证的过程可以参考sdk demo代码，下载 sdk demo代码，<a href="https://opendocs.alipay.com/open/203/105910">https://opendocs.alipay.com/open/203/105910</a></p><p><strong>编写测试代码</strong></p><p>1、在下单请求时设置通知地址request.setNotifyUrl(“商户自己的notify_url地址”);</p><pre class=" language-java"><code class="language-java"><span class="token function">PostMapping</span><span class="token punctuation">(</span><span class="token string">"/paynotify"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">paynotify</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token keyword">throws</span> UnsupportedEncodingException<span class="token punctuation">,</span> AlipayApiException <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> params <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Map requestParams <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Iterator iter <span class="token operator">=</span> requestParams<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String name <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> requestParams<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        String valueStr <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> values<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            valueStr <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> values<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> valueStr <span class="token operator">+</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    <span class="token operator">:</span> valueStr <span class="token operator">+</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//乱码解决，这段代码在出现乱码时使用。如果mysign和sign不相等也可以使用这段代码转化</span>        <span class="token comment" spellcheck="true">//valueStr = new String(valueStr.getBytes("ISO-8859-1"), "gbk");</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> valueStr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//商户订单号</span>    String out_trade_no <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"out_trade_no"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//支付宝交易号</span>    String trade_no <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"trade_no"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//交易状态</span>    String trade_status <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"trade_status"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取支付宝的通知返回参数，可参考技术文档中页面跳转同步通知参数列表(以上仅供参考)//</span>    <span class="token comment" spellcheck="true">//计算得出通知验证结果</span>    <span class="token comment" spellcheck="true">//boolean AlipaySignature.rsaCheckV1(Map&lt;String, String> params, String publicKey, String charset, String sign_type)</span>    <span class="token keyword">boolean</span> verify_result <span class="token operator">=</span> AlipaySignature<span class="token punctuation">.</span><span class="token function">rsaCheckV1</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> ALIPAY_PUBLIC_KEY<span class="token punctuation">,</span> CHARSET<span class="token punctuation">,</span> <span class="token string">"RSA2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>verify_result<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//验证成功</span>        <span class="token comment" spellcheck="true">//////////////////////////////////////////////////////////////////////////////////////////</span>        <span class="token comment" spellcheck="true">//请在这里加上商户的业务逻辑程序代码</span>        <span class="token comment" spellcheck="true">//——请根据您的业务逻辑来编写程序（以下代码仅作参考）——</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>trade_status<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"TRADE_FINISHED"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//交易结束</span>            <span class="token comment" spellcheck="true">//判断该笔订单是否在商户网站中已经做过处理</span>            <span class="token comment" spellcheck="true">//如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序</span>            <span class="token comment" spellcheck="true">//请务必判断请求时的total_fee、seller_id与通知时获取的total_fee、seller_id为一致的</span>            <span class="token comment" spellcheck="true">//如果有做过处理，不执行商户的业务程序</span>            <span class="token comment" spellcheck="true">//注意：</span>            <span class="token comment" spellcheck="true">//如果签约的是可退款协议，退款日期超过可退款期限后（如三个月可退款），支付宝系统发送该交易状态通知</span>            <span class="token comment" spellcheck="true">//如果没有签约可退款协议，那么付款完成后，支付宝系统发送该交易状态通知。</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>trade_status<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"TRADE_SUCCESS"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//交易成功</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>trade_status<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//判断该笔订单是否在商户网站中已经做过处理</span>            <span class="token comment" spellcheck="true">//如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序</span>            <span class="token comment" spellcheck="true">//请务必判断请求时的total_fee、seller_id与通知时获取的total_fee、seller_id为一致的</span>            <span class="token comment" spellcheck="true">//如果有做过处理，不执行商户的业务程序</span>            <span class="token comment" spellcheck="true">//注意：</span>            <span class="token comment" spellcheck="true">//如果签约的是可退款协议，那么付款完成后，支付宝系统发送该交易状态通知。</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="通知接口测试"><a href="#通知接口测试" class="headerlink" title="通知接口测试"></a><strong>通知接口测试</strong></h4><p>1、重启订单服务，并在下单接口中打上断点</p><p>2、配置内网穿透的本地端口为订单服务端口，启动内网穿透客户端。</p><p>3、打开模拟器、支付宝沙箱，扫码、支付。</p><p>4、观察下单接口断点处的执行情况、接收数据等是否正常。</p><h3 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战:"></a>项目实战:</h3><p>点击“支付宝支付”此时打开支付二维码，用户扫码支付。</p><p>所以首先需要生成支付二维码，用户扫描二维码开始请求支付宝下单，在向支付宝下单前需要添加选课记录、创建商品订单、生成支付交易记录。</p><p>生成二维码执行流程如下：</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323223103719.png" alt="image-20230323223103719"></p><p>执行流程：</p><p>1、前端调用学习中心服务的添加选课接口。</p><p>2、添加选课成功请求订单服务生成支付二维码接口。</p><p>3、生成二维码接口：创建商品订单、生成支付交易记录、生成二维码。</p><p>4、将二维码返回到前端，用户扫码。</p><p>用户扫码支付流程如下：</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323230516623.png" alt="image-20230323230516623"></p><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>订单支付模式的核心由三张表组成：订单表、订单明细表、支付交易记录表。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323230553795.png" alt="image-20230323230553795"></p><p>订单表：记录订单信息</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323230610490.png" alt="image-20230323230610490"></p><p>订单明细表记录订单的详细信息：</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230324184737807.png" alt="image-20230324184737807"></p><p>支付交易记录表记录与支付平台的交易明细:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230324184816694.png" alt="image-20230324184816694"></p><p>三张表之间的关系就是订单表和订单明细表是一对多的关系。然后我们的订单记录表和订单表也是一对多的关系。</p><p>因为我们发起支付宝的请求页面需要将我们的订单信息发送给我们的支付宝页面，如果是将我们的订单id发送过去的话，有可能会造成支付中断，导致再次将订单id发送过去，有可能会导致该订单Id支付不成功，因为你发送过一次支付了，再次支付有可能会出现一些问题。所以一般我们是将订单记录发送过去。</p><p>订单号注意唯一性、安全性、尽量短等特点，生成方案常用的如下：</p><p>1、时间戳+随机数</p><p>年月日时分秒毫秒+随机数</p><p>2、高并发场景</p><p>年月日时分秒毫秒+随机数+redis自增序列</p><p>3、订单号中加上业务标识</p><p>订单号加上业务标识方便客服，比如：第10位是业务类型，第11位是用户类型等。</p><p>4、雪花算法</p><p>雪花算法是推特内部使用的分布式环境下的唯一ID生成算法，它基于时间戳生成，保证有序递增，加以入计算机硬件等元素，可以满足高并发环境下ID不重复。</p><p>1位的符号位、32位的时间戳、12位的机器码</p><p>本项目订单号生成采用雪花算法。</p><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a><strong>接口定义</strong></h4><p>在订单服务中定义生成支付二维码接口。</p><p>请求：订单信息</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@ToString</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AddOrderDto</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 总价     */</span>    <span class="token keyword">private</span> Float totalPrice<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 订单类型     */</span>    <span class="token keyword">private</span> String orderType<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 订单名称     */</span>    <span class="token keyword">private</span> String orderName<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 订单描述     */</span>    <span class="token keyword">private</span> String orderDescrip<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 订单明细json，不可为空     * [{"goodsId":"","goodsType":"","goodsName":"","goodsPrice":"","goodsDetail":""},{...}]     */</span>    <span class="token keyword">private</span> String orderDetail<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 外部系统业务id     */</span>    <span class="token keyword">private</span> String outBusinessId<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>响应：支付交易记录信息及二维码信息：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PayRecordDto</span> <span class="token keyword">extends</span> <span class="token class-name">XcPayRecord</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//二维码</span>    <span class="token keyword">private</span> String qrcode<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接口定义如下：</p><p>AddOrderDTO就是一个下单的信息，前端点击下单操作，会将用户的信息发送到我们的后端中，我们将信息，做一个幂等姓的校验。</p><p>用户扫码请求下单，定义下单接口如下：</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span><span class="token string">"根据用户下单生成一个二维码"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token keyword">public</span> PayRecordDto <span class="token function">payRecordDto</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> AddOrderDto addOrderDto<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>用户扫码请求下单，定义下单接口如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span><span class="token string">"扫码下单接口"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/requestpay"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">requestpay</span><span class="token punctuation">(</span>String payNo<span class="token punctuation">,</span>HttpServletResponse httpResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h4 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a><strong>接口实现</strong></h4><p><strong>保存商品订单</strong></p><p>商品订单的数据来源于选课记录，在订单表需要存入选课记录的ID，这里需要作好幂等处理。</p><p>定义保存订单信息接口</p><pre class=" language-java"><code class="language-java">   <span class="token comment" spellcheck="true">/** * @description 创建商品订单 * @param addOrderDto 订单信息 * @return PayRecordDto 支付交易记录(包括二维码) * @author Mr.M * @date 2022/10/4 11:02*/</span><span class="token keyword">public</span> PayRecordDto <span class="token function">createOrder</span><span class="token punctuation">(</span>String userId<span class="token punctuation">,</span>AddOrderDto addOrderDto<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在保存订单接口中需要做创建商品订单、创建支付交易记录</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> PayRecordDto <span class="token function">createOrder</span><span class="token punctuation">(</span>String userId<span class="token punctuation">,</span>AddOrderDto addOrderDto<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//添加商品订单</span>    <span class="token comment" spellcheck="true">//添加支付交易记录</span><span class="token punctuation">}</span></code></pre><p>编写创建商品订单方法：</p><pre class=" language-java"><code class="language-java">Transactional<span class="token keyword">public</span> XcOrders <span class="token function">saveXcOrders</span><span class="token punctuation">(</span>String userId<span class="token punctuation">,</span>AddOrderDto addOrderDto<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//幂等性处理</span>    XcOrders order <span class="token operator">=</span> <span class="token function">getOrderByBusinessId</span><span class="token punctuation">(</span>addOrderDto<span class="token punctuation">.</span><span class="token function">getOutBusinessId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>order<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> order<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    order <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XcOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//生成订单号</span>    <span class="token keyword">long</span> orderId <span class="token operator">=</span> IdWorkerUtils<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    order<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>    order<span class="token punctuation">.</span><span class="token function">setTotalPrice</span><span class="token punctuation">(</span>addOrderDto<span class="token punctuation">.</span><span class="token function">getTotalPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    order<span class="token punctuation">.</span><span class="token function">setCreateDate</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    order<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token string">"600001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//未支付</span>    order<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>    order<span class="token punctuation">.</span><span class="token function">setOrderType</span><span class="token punctuation">(</span>addOrderDto<span class="token punctuation">.</span><span class="token function">getOrderType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    order<span class="token punctuation">.</span><span class="token function">setOrderName</span><span class="token punctuation">(</span>addOrderDto<span class="token punctuation">.</span><span class="token function">getOrderName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    order<span class="token punctuation">.</span><span class="token function">setOrderDetail</span><span class="token punctuation">(</span>addOrderDto<span class="token punctuation">.</span><span class="token function">getOrderDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    order<span class="token punctuation">.</span><span class="token function">setOrderDescrip</span><span class="token punctuation">(</span>addOrderDto<span class="token punctuation">.</span><span class="token function">getOrderDescrip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    order<span class="token punctuation">.</span><span class="token function">setOutBusinessId</span><span class="token punctuation">(</span>addOrderDto<span class="token punctuation">.</span><span class="token function">getOutBusinessId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//选课记录id</span>    ordersMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>    String orderDetailJson <span class="token operator">=</span> addOrderDto<span class="token punctuation">.</span><span class="token function">getOrderDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>XcOrdersGoods<span class="token operator">></span> xcOrdersGoodsList <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseArray</span><span class="token punctuation">(</span>orderDetailJson<span class="token punctuation">,</span> XcOrdersGoods<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    xcOrdersGoodsList<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>goods<span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>        XcOrdersGoods xcOrdersGoods <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XcOrdersGoods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BeanUtils<span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>goods<span class="token punctuation">,</span>xcOrdersGoods<span class="token punctuation">)</span><span class="token punctuation">;</span>        xcOrdersGoods<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//订单号</span>        ordersGoodsMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>xcOrdersGoods<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> order<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//根据业务id查询订单</span><span class="token keyword">public</span> XcOrders <span class="token function">getOrderByBusinessId</span><span class="token punctuation">(</span>String businessId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    XcOrders orders <span class="token operator">=</span> ordersMapper<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LambdaQueryWrapper</span><span class="token operator">&lt;</span>XcOrders<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span>XcOrders<span class="token operator">:</span><span class="token operator">:</span>getOutBusinessId<span class="token punctuation">,</span> businessId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> orders<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="创建支付交易记录"><a href="#创建支付交易记录" class="headerlink" title="创建支付交易记录"></a><strong>创建支付交易记录</strong></h4><p><strong><font color="red">为什么创建支付交易记录？</font></strong></p><p>在请求微信或支付宝下单接口时需要传入 商品订单号，在与第三方支付平台对接时发现，当用户支付失败或因为其它原因最终该订单没有支付成功，此时再次调用第三方支付平台的下单接口发现报错“订单号已存在”，此时如果我们传入一个没有使用过的订单号就可以解决问题，但是商品订单已经创建，因为没有支付成功重新创建一个新订单是不合理的。</p><p>解决以上问题的方案是：</p><p>1、用户每次发起都创建一个新的支付交易记录 ，此交易记录与商品订单关联。</p><p>2、将支付交易记录的流水号传给第三方支付系统下单接口，这样就即使没有支付成功就不会出现上边的问题。</p><p>3、需要提醒用户不要重复支付。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230324190926958.png" alt="image-20230324190926958"></p><p>编写创建支付交易记录的方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> XcPayRecord <span class="token function">createPayRecord</span><span class="token punctuation">(</span>XcOrders orders<span class="token punctuation">)</span><span class="token punctuation">{</span>    XcPayRecord payRecord <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XcPayRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//生成支付交易流水号</span>    <span class="token keyword">long</span> payNo <span class="token operator">=</span> IdWorkerUtils<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    payRecord<span class="token punctuation">.</span><span class="token function">setPayNo</span><span class="token punctuation">(</span>payNo<span class="token punctuation">)</span><span class="token punctuation">;</span>    payRecord<span class="token punctuation">.</span><span class="token function">setOrderId</span><span class="token punctuation">(</span>orders<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//商品订单号</span>    payRecord<span class="token punctuation">.</span><span class="token function">setOrderName</span><span class="token punctuation">(</span>orders<span class="token punctuation">.</span><span class="token function">getOrderName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    payRecord<span class="token punctuation">.</span><span class="token function">setTotalPrice</span><span class="token punctuation">(</span>orders<span class="token punctuation">.</span><span class="token function">getTotalPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    payRecord<span class="token punctuation">.</span><span class="token function">setCurrency</span><span class="token punctuation">(</span><span class="token string">"CNY"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    payRecord<span class="token punctuation">.</span><span class="token function">setCreateDate</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    payRecord<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token string">"601001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//未支付</span>    payRecord<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>orders<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    payRecordMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>payRecord<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> payRecord<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>生成支付二维码</strong></p><p>完善创建订单service方法</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> PayRecordDto <span class="token function">createOrder</span><span class="token punctuation">(</span>String userId<span class="token punctuation">,</span> AddOrderDto addOrderDto<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建商品订单</span>    XcOrders orders <span class="token operator">=</span> <span class="token function">saveXcOrders</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> addOrderDto<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//生成支付记录</span>    XcPayRecord payRecord <span class="token operator">=</span> <span class="token function">createPayRecord</span><span class="token punctuation">(</span>orders<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//生成二维码</span>    String qrCode <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//url要可以被模拟器访问到，url为下单接口(稍后定义)</span>        qrCode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QRCodeUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createQRCode</span><span class="token punctuation">(</span><span class="token string">"http://192.168.101.1/api/orders/requestpay?payNo="</span><span class="token operator">+</span>payRecord<span class="token punctuation">.</span><span class="token function">getPayNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        XueChengPlusException<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span><span class="token string">"生成二维码出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    PayRecordDto payRecordDto <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PayRecordDto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    BeanUtils<span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>payRecord<span class="token punctuation">,</span>payRecordDto<span class="token punctuation">)</span><span class="token punctuation">;</span>    payRecordDto<span class="token punctuation">.</span><span class="token function">setQrcode</span><span class="token punctuation">(</span>qrCode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> payRecordDto<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="生成二维码接口完善"><a href="#生成二维码接口完善" class="headerlink" title="生成二维码接口完善"></a><strong>生成二维码接口完善</strong></h4><p>完善生成支付二维码controller接口</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span><span class="token string">"生成支付二维码"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/generatepaycode"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> PayRecordDto <span class="token function">generatePayCode</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestBody</span> AddOrderDto addOrderDto<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//登录用户</span>    SecurityUtil<span class="token punctuation">.</span>XcUser user <span class="token operator">=</span> SecurityUtil<span class="token punctuation">.</span><span class="token function">getUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>        XueChengPlusException<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span><span class="token string">"请登录后继续选课"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token keyword">return</span> orderService<span class="token punctuation">.</span><span class="token function">createOrder</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> addOrderDto<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span></code></pre><p><strong>扫码下单接口</strong></p><p>生成了支付二维码，用户扫码请求第三方支付平台下单、支付。</p><p>1、定义查询支付交易记录的Service接口与实现方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @description 查询支付交易记录 * @param payNo  交易记录号 * @return com.xuecheng.orders.model.po.XcPayRecord * @author Mr.M * @date 2022/10/20 23:38*/</span><span class="token keyword">public</span> XcPayRecord <span class="token function">getPayRecordByPayno</span><span class="token punctuation">(</span>String payNo<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>实现如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> XcPayRecord <span class="token function">getPayRecordByPayno</span><span class="token punctuation">(</span>String payNo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    XcPayRecord xcPayRecord <span class="token operator">=</span> payRecordMapper<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LambdaQueryWrapper</span><span class="token operator">&lt;</span>XcPayRecord<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span>XcPayRecord<span class="token operator">:</span><span class="token operator">:</span>getPayNo<span class="token punctuation">,</span> payNo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> xcPayRecord<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>定义下单接口如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span><span class="token string">"扫码下单接口"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/requestpay"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">requestpay</span><span class="token punctuation">(</span>String payNo<span class="token punctuation">,</span>HttpServletResponse httpResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//如果payNo不存在则提示重新发起支付</span>        XcPayRecord payRecord <span class="token operator">=</span> orderService<span class="token punctuation">.</span><span class="token function">getPayRecordByPayno</span><span class="token punctuation">(</span>payNo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>payRecord <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            XueChengPlusException<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span><span class="token string">"请重新点击支付获取二维码"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//构造sdk的客户端对象</span>        AlipayClient alipayClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultAlipayClient</span><span class="token punctuation">(</span>serverUrl<span class="token punctuation">,</span> APP_ID<span class="token punctuation">,</span> APP_PRIVATE_KEY<span class="token punctuation">,</span> <span class="token string">"json"</span><span class="token punctuation">,</span> CHARSET<span class="token punctuation">,</span> ALIPAY_PUBLIC_KEY<span class="token punctuation">,</span> sign_type<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//获得初始化的AlipayClient</span>        AlipayTradeWapPayRequest alipayRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlipayTradeWapPayRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建API对应的request</span><span class="token comment" spellcheck="true">//        alipayRequest.setReturnUrl("http://domain.com/CallBack/return_url.jsp");</span><span class="token comment" spellcheck="true">//        alipayRequest.setNotifyUrl("http://tjxt-user-t.itheima.net/xuecheng/orders/paynotify");//在公共参数中设置回跳和通知地址</span>        alipayRequest<span class="token punctuation">.</span><span class="token function">setBizContent</span><span class="token punctuation">(</span><span class="token string">"{"</span> <span class="token operator">+</span>                <span class="token string">" \"out_trade_no\":\""</span><span class="token operator">+</span>payRecord<span class="token punctuation">.</span><span class="token function">getPayNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\","</span> <span class="token operator">+</span>                <span class="token string">" \"total_amount\":\""</span><span class="token operator">+</span>payRecord<span class="token punctuation">.</span><span class="token function">getTotalPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\","</span> <span class="token operator">+</span>                <span class="token string">" \"subject\":\""</span><span class="token operator">+</span>payRecord<span class="token punctuation">.</span><span class="token function">getOrderName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\","</span> <span class="token operator">+</span>                <span class="token string">" \"product_code\":\"QUICK_WAP_PAY\""</span> <span class="token operator">+</span>                <span class="token string">" }"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//填充业务参数</span>        String form <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//请求支付宝下单接口,发起http请求</span>            form <span class="token operator">=</span> alipayClient<span class="token punctuation">.</span><span class="token function">pageExecute</span><span class="token punctuation">(</span>alipayRequest<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用SDK生成表单</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">AlipayApiException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        httpResponse<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html;charset="</span> <span class="token operator">+</span> CHARSET<span class="token punctuation">)</span><span class="token punctuation">;</span>        httpResponse<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>form<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接将完整的表单html输出到页面</span>        httpResponse<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        httpResponse<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>接口测试</strong></p><p>测试准备：</p><p>1、启动网关服务、认证服务、验证码服务、学习中心服务、订单服务、内容管理服务。</p><p>2、发布一门收费课程。</p><p>测试流程：</p><p>1、进入收费课程详细页面，点击马上学习。</p><p>2、跟踪浏览器及微服务，观察选课记录是否创建成功、商品订单是否创建成功、支付交易记录是否创建成功。</p><p>3、观察生成二维码是否成功</p><p>4、使用模拟器扫码测试，是否可以正常支付。</p><p>如果报订单参数异常报如下错误，需要检查请求支付宝的下单数据是否正确。</p><h4 id="对账操作"><a href="#对账操作" class="headerlink" title="对账操作"></a>对账操作</h4><p>上面模拟完成了返回一个二维码到前端，用户通过扫描二维码能跳转到对应的支付页面，进行支付。支付完成之后，我们的后端需要对我们的支付结果，进行查询，虽然支付宝会将支付完成之后会通过回调函数，来调用传递给我们的支付结果，但是呢，为了做保险操作，需要我们的服务器本地的进行查账的操作。</p><p>查找的接口:</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/playResult"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span><span class="token string">"查询支付宝结果的接口"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> PayRecordDto <span class="token function">payRecordDto</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"payNo"</span><span class="token punctuation">)</span> String payNo<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//1、从数据库中查询数据，进行对账操作，然后去更新我们的数据库</span>        PayRecordDto recordDto<span class="token operator">=</span>orderService<span class="token punctuation">.</span><span class="token function">getPayResult</span><span class="token punctuation">(</span>payNo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>业务的流程就是:</p><p>将我们的订单号传递到后端，后端去支付宝服务器进行请求，请求发送之后，收到我们的结果，然后将结果封装会数据库中。</p><p>service的服务器:</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> PayRecordDto <span class="token function">getPayResult</span><span class="token punctuation">(</span>String payNo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>payNo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StudyException</span><span class="token punctuation">(</span><span class="token string">"订单号不能为null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        XcPayRecord payRecord <span class="token operator">=</span> payRecordMapper<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token operator">&lt;</span>XcPayRecord<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"pay_no"</span><span class="token punctuation">,</span> payNo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>payRecord <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StudyException</span><span class="token punctuation">(</span><span class="token string">"该订单记录号不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//查询数据库进行封装操作</span>        PayStatusDto payStatusDto <span class="token operator">=</span> <span class="token function">getAlipayResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//封装成功</span>        <span class="token comment" spellcheck="true">//修改数据库中的支付状态位</span>        <span class="token function">saveAliPayStatus</span><span class="token punctuation">(</span>payStatusDto<span class="token punctuation">)</span><span class="token punctuation">;</span>        XcPayRecord record <span class="token operator">=</span> payRecordMapper<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">QueryWrapper</span><span class="token operator">&lt;</span>XcPayRecord<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span><span class="token string">"pay_no"</span><span class="token punctuation">,</span> payNo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PayRecordDto recordDto <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PayRecordDto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BeanUtils<span class="token punctuation">.</span><span class="token function">copyProperties</span><span class="token punctuation">(</span>record<span class="token punctuation">,</span>recordDto<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> recordDto<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>封装数据库:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> PayStatusDto <span class="token function">getAlipayResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        AlipayClient alipayClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultAlipayClient</span><span class="token punctuation">(</span>AlipayConfig<span class="token punctuation">.</span>URL<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>APPID<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>RSA_PRIVATE_KEY<span class="token punctuation">,</span> AlipayConfig<span class="token punctuation">.</span>FORMAT<span class="token punctuation">,</span> AlipayConfig<span class="token punctuation">.</span>CHARSET<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>ALIPAY_PUBLIC_KEY<span class="token punctuation">,</span> AlipayConfig<span class="token punctuation">.</span>SIGNTYPE<span class="token punctuation">)</span><span class="token punctuation">;</span>        AlipayTradeQueryRequest request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlipayTradeQueryRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JSONObject bizContent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bizContent<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"out_trade_no"</span><span class="token punctuation">,</span> <span class="token string">"20150320010101002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//bizContent.put("trade_no", "2014112611001004680073956707");</span>        request<span class="token punctuation">.</span><span class="token function">setBizContent</span><span class="token punctuation">(</span>bizContent<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AlipayTradeQueryResponse response <span class="token operator">=</span> null<span class="token punctuation">;</span>        Map parseMap <span class="token operator">=</span> null<span class="token punctuation">;</span>        Map alipay_trade_query_response<span class="token operator">=</span>null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            response <span class="token operator">=</span> alipayClient<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>response<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StudyException</span><span class="token punctuation">(</span><span class="token string">"请求支付宝查询支付结果失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            String body <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            parseMap <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> Map<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            alipay_trade_query_response<span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">)</span> parseMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"alipay_trade_query_response"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">AlipayApiException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"请求支付宝支付失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        PayStatusDto payStatusDto <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PayStatusDto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        payStatusDto<span class="token punctuation">.</span><span class="token function">setApp_id</span><span class="token punctuation">(</span>AlipayConfig<span class="token punctuation">.</span>APPID<span class="token punctuation">)</span><span class="token punctuation">;</span>        payStatusDto<span class="token punctuation">.</span><span class="token function">setTrade_status</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> alipay_trade_query_response<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"trade_status"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        payStatusDto<span class="token punctuation">.</span><span class="token function">setOut_trade_no</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> alipay_trade_query_response<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"out_trade_no"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        payStatusDto<span class="token punctuation">.</span><span class="token function">setTotal_amount</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> alipay_trade_query_response<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"total_amount"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        payStatusDto<span class="token punctuation">.</span><span class="token function">setTrade_no</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> alipay_trade_query_response<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"trade_no"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> payStatusDto<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>修改数据库中的支付状态位：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">saveAliPayStatus</span><span class="token punctuation">(</span>PayStatusDto payStatusDto<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//支付结果</span>        String trade_status <span class="token operator">=</span> payStatusDto<span class="token punctuation">.</span><span class="token function">getTrade_status</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>trade_status<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"TRADE_SUCCESS"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//支付流水号</span>            String payNo <span class="token operator">=</span> payStatusDto<span class="token punctuation">.</span><span class="token function">getOut_trade_no</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//查询支付流水</span>            XcPayRecord payRecord <span class="token operator">=</span> <span class="token function">getPayRecordByPayno</span><span class="token punctuation">(</span>payNo<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//支付金额变为分</span>            Float totalPrice <span class="token operator">=</span> payRecord<span class="token punctuation">.</span><span class="token function">getTotalPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">;</span>            Float total_amount <span class="token operator">=</span> Float<span class="token punctuation">.</span><span class="token function">parseFloat</span><span class="token punctuation">(</span>payStatusDto<span class="token punctuation">.</span><span class="token function">getTotal_amount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//校验是否一致</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>payRecord <span class="token operator">!=</span> null                    <span class="token operator">&amp;&amp;</span> payStatusDto<span class="token punctuation">.</span><span class="token function">getApp_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>APP_ID<span class="token punctuation">)</span>                    <span class="token operator">&amp;&amp;</span> totalPrice<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> total_amount<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String status <span class="token operator">=</span> payRecord<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"601001"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//未支付时进行处理</span>                    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"更新支付结果,支付交易流水号:{},支付结果:{}"</span><span class="token punctuation">,</span> payNo<span class="token punctuation">,</span> trade_status<span class="token punctuation">)</span><span class="token punctuation">;</span>                    XcPayRecord payRecord_u <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XcPayRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    payRecord_u<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token string">"601002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//支付成功</span>                    payRecord_u<span class="token punctuation">.</span><span class="token function">setOutPayChannel</span><span class="token punctuation">(</span><span class="token string">"Alipay"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    payRecord_u<span class="token punctuation">.</span><span class="token function">setOutPayNo</span><span class="token punctuation">(</span>payStatusDto<span class="token punctuation">.</span><span class="token function">getTrade_no</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//支付宝交易号</span>                    payRecord_u<span class="token punctuation">.</span><span class="token function">setPaySuccessTime</span><span class="token punctuation">(</span>LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//通知时间</span>                    <span class="token keyword">int</span> update1 <span class="token operator">=</span> payRecordMapper<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>payRecord_u<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LambdaQueryWrapper</span><span class="token operator">&lt;</span>XcPayRecord<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span>XcPayRecord<span class="token operator">:</span><span class="token operator">:</span>getPayNo<span class="token punctuation">,</span> payNo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>update1 <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"收到支付通知，更新支付交易状态成功.付交易流水号:{},支付结果:{}"</span><span class="token punctuation">,</span> payNo<span class="token punctuation">,</span> trade_status<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"收到支付通知，更新支付交易状态失败.支付交易流水号:{},支付结果:{}"</span><span class="token punctuation">,</span> payNo<span class="token punctuation">,</span> trade_status<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">//关联的订单号</span>                    Long orderId <span class="token operator">=</span> payRecord<span class="token punctuation">.</span><span class="token function">getOrderId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    XcOrders orders <span class="token operator">=</span> ordersMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>orders <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        XcOrders order_u <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XcOrders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        order_u<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token string">"600002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">int</span> update <span class="token operator">=</span> ordersMapper<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>order_u<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LambdaQueryWrapper</span><span class="token operator">&lt;</span>XcOrders<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eq</span><span class="token punctuation">(</span>XcOrders<span class="token operator">:</span><span class="token operator">:</span>getId<span class="token punctuation">,</span> orderId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>update <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"收到支付通知，更新订单状态成功.付交易流水号:{},支付结果:{},订单号:{},状态:{}"</span><span class="token punctuation">,</span> payNo<span class="token punctuation">,</span> trade_status<span class="token punctuation">,</span> orderId<span class="token punctuation">,</span> <span class="token string">"600002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"收到支付通知，更新订单状态失败.支付交易流水号:{},支付结果:{},订单号:{},状态:{}"</span><span class="token punctuation">,</span> payNo<span class="token punctuation">,</span> trade_status<span class="token punctuation">,</span> orderId<span class="token punctuation">,</span> <span class="token string">"600002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"收到支付通知，根据交易记录找不到订单,交易记录号:{},订单号:{}"</span><span class="token punctuation">,</span> payRecord_u<span class="token punctuation">.</span><span class="token function">getPayNo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span></code></pre><h4 id="支付结果的通知"><a href="#支付结果的通知" class="headerlink" title="支付结果的通知"></a>支付结果的通知</h4><p>支付完成后第三方支付系统会主动通知支付结果，要实现主动通知需要在请求支付系统下单时传入NotifyUrl，这里有两个url：NotifyUrl和ReturnUrl，ReturnUrl是支付完成后支付系统携带支付结果重定向到ReturnUrl地址，NotifyUrl是支付完成后支付系统在后台定时去通知，使用NotifyUrl比使用ReturnUrl有保证。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/playNotify"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@ApiOperation</span><span class="token punctuation">(</span><span class="token string">"支付结果的回调地址"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playNotify</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token keyword">throws</span> AlipayApiException<span class="token punctuation">,</span> UnsupportedEncodingException <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> params <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map requestParams <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Iterator iter <span class="token operator">=</span> requestParams<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            String name <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String<span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> requestParams<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>            String valueStr <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> values<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                valueStr <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> values<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> valueStr <span class="token operator">+</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                        <span class="token operator">:</span> valueStr <span class="token operator">+</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//乱码解决，这段代码在出现乱码时使用。如果mysign和sign不相等也可以使用这段代码转化</span>            <span class="token comment" spellcheck="true">//valueStr = new String(valueStr.getBytes("ISO-8859-1"), "gbk");</span>            params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> valueStr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//商户订单号</span>        String out_trade_no <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"out_trade_no"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//支付宝交易号</span>        String trade_no <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"trade_no"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//交易状态</span>        String trade_status <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"trade_status"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String total_amount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"total_amount"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获取支付宝的通知返回参数，可参考技术文档中页面跳转同步通知参数列表(以上仅供参考)//</span>        <span class="token comment" spellcheck="true">//计算得出通知验证结果</span>        <span class="token comment" spellcheck="true">//boolean AlipaySignature.rsaCheckV1(Map&lt;String, String> params, String publicKey, String charset, String sign_type)</span>        <span class="token keyword">boolean</span> verify_result <span class="token operator">=</span> AlipaySignature<span class="token punctuation">.</span><span class="token function">rsaCheckV1</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> AlipayConfig<span class="token punctuation">.</span>ALIPAY_PUBLIC_KEY<span class="token punctuation">,</span> AlipayConfig<span class="token punctuation">.</span>CHARSET<span class="token punctuation">,</span> <span class="token string">"RSA2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>verify_result<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//验证成功</span>            <span class="token comment" spellcheck="true">//////////////////////////////////////////////////////////////////////////////////////////</span>            <span class="token comment" spellcheck="true">//请在这里加上商户的业务逻辑程序代码</span>            <span class="token comment" spellcheck="true">//——请根据您的业务逻辑来编写程序（以下代码仅作参考）——</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>trade_status<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"TRADE_SUCCESS"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//交易成功</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>trade_status<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//判断该笔订单是否在商户网站中已经做过处理</span>                <span class="token comment" spellcheck="true">//如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序</span>                <span class="token comment" spellcheck="true">//请务必判断请求时的total_fee、seller_id与通知时获取的total_fee、seller_id为一致的</span>                <span class="token comment" spellcheck="true">//如果有做过处理，不执行商户的业务程序</span>                <span class="token comment" spellcheck="true">//执行我们的保存我们的订单操作即可。</span>                PayStatusDto recordDto <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PayStatusDto</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                recordDto<span class="token punctuation">.</span><span class="token function">setTrade_no</span><span class="token punctuation">(</span>trade_no<span class="token punctuation">)</span><span class="token punctuation">;</span>                recordDto<span class="token punctuation">.</span><span class="token function">setApp_id</span><span class="token punctuation">(</span>AlipayConfig<span class="token punctuation">.</span>APPID<span class="token punctuation">)</span><span class="token punctuation">;</span>                recordDto<span class="token punctuation">.</span><span class="token function">setOut_trade_no</span><span class="token punctuation">(</span>out_trade_no<span class="token punctuation">)</span><span class="token punctuation">;</span>                recordDto<span class="token punctuation">.</span><span class="token function">setTrade_status</span><span class="token punctuation">(</span>trade_status<span class="token punctuation">)</span><span class="token punctuation">;</span>                recordDto<span class="token punctuation">.</span><span class="token function">setTotal_amount</span><span class="token punctuation">(</span>total_amount<span class="token punctuation">)</span><span class="token punctuation">;</span>                orderService<span class="token punctuation">.</span><span class="token function">saveAliPayStatus</span><span class="token punctuation">(</span>recordDto<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h4 id="支付通知"><a href="#支付通知" class="headerlink" title="支付通知"></a>支付通知</h4><p><strong>消息通知方式</strong></p><p>订单服务作为通用服务在订单支付成功后需要将支付结果通知给与订单服务对接的其它微服务。</p><p>为了保证通知过程的简便还要保证消息全部到达消费服务，采用发布订阅的方式通知支付结果。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230326232046372.png" alt="image-20230326232046372"></p><p>学习中心服务：对收费课程选课需要支付，与订单服务对接完成支付。</p><p>学习资源服务：对收费的学习资料需要购买后下载，与订单服务对接完成支付。</p><p>订单服务完成支付后将支付结果发给每一个与订单服务对接的微服务，订单服务将消息发给交换机，由交换机广播消息，每个订阅消息的微服务都可以接收到支付结果，根据支付结果的内容去更新自己的业务数据。</p><p>学习中心等微服务收到消息并处理完成通过消息队列回复订单服务。</p><h4 id="分布式事务问题"><a href="#分布式事务问题" class="headerlink" title="分布式事务问题"></a><strong>分布式事务问题</strong></h4><p>订单服务收到第三方支付系统的通知更新支付结果，订单服务将支付结果通知给其它微服务，订单服务需要保证更新支付结果成功并且向其它微服务通知支付结果也成功，两件事跨多个微服务并且需要保证一致性，存在分布式事务控制的需求。</p><p>针对该业务场景如何控制分布式事务？</p><p>根据需求可知，订单服务先将支付结果更新成功后再将支付结果通知给其它微服务，只要保证最终将支付结果通知到微服务保证最终一致性即可，可以采用课程发布模块的技术方案，先通过本地事务更新支付结果的同时添加一条消息表记录，再由任务调度去定时调度将支付结果通知给其它微服务。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230326232254925.png" alt="image-20230326232254925"></p><h4 id="集成消息队列"><a href="#集成消息队列" class="headerlink" title="集成消息队列"></a><strong>集成消息队列</strong></h4><p><strong>支付结果通知队列</strong></p><p>订单服务通过消息队列将支付结果发给学习中心服务，消息队列采用发布订阅模式。</p><p>1、订单服务创建支付结果通知交换机。</p><p>2、学习中心服务绑定队列到交换机。</p><p>项目使用RabbitMQ作为消息队列，在课前下发的虚拟上已经安装了RabbitMQ.</p><p>执行docker start rabbitmq 启动RabbitMQ。访问：<a href="http://192.168.101.65:15672/">http://192.168.101.65:15672/</a> </p><p>账户密码：guest&#x2F;guest</p><p>交换机Fanout广播模式。</p><p>首先需要在内容管理服务层工程和消息服务工程配置连接消息队列。</p><p>1、首先在订单服务添加消息队列依赖</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>2、在nacos配置rabbitmq-dev.yaml为通用配置文件</p><pre class=" language-yaml"><code class="language-yaml">YAML<span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> 192.168.101.65    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> guest    <span class="token key atrule">password</span><span class="token punctuation">:</span> guest    <span class="token key atrule">virtual-host</span><span class="token punctuation">:</span> /    <span class="token key atrule">publisher-confirm-type</span><span class="token punctuation">:</span> correlated <span class="token comment" spellcheck="true">#correlated 异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback</span>    <span class="token key atrule">publisher-returns</span><span class="token punctuation">:</span> <span class="token boolean important">false </span><span class="token comment" spellcheck="true">#开启publish-return功能，同样是基于callback机制，需要定义ReturnCallback</span>    <span class="token key atrule">template</span><span class="token punctuation">:</span>      <span class="token key atrule">mandatory</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true">#定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息</span>    <span class="token key atrule">listener</span><span class="token punctuation">:</span>      <span class="token key atrule">simple</span><span class="token punctuation">:</span>        <span class="token key atrule">acknowledge-mode</span><span class="token punctuation">:</span> none <span class="token comment" spellcheck="true">#出现异常时返回unack，消息回滚到mq；没有异常，返回ack ,manual:手动控制,none:丢弃消息，不回滚到mq</span>        <span class="token key atrule">retry</span><span class="token punctuation">:</span>          <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true">#开启消费者失败重试</span>          <span class="token key atrule">initial-interval</span><span class="token punctuation">:</span> 1000ms <span class="token comment" spellcheck="true">#初识的失败等待时长为1秒</span>          <span class="token key atrule">multiplier</span><span class="token punctuation">:</span> <span class="token number">1 </span><span class="token comment" spellcheck="true">#失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span>          <span class="token key atrule">max-attempts</span><span class="token punctuation">:</span> <span class="token number">3 </span><span class="token comment" spellcheck="true">#最大重试次数</span>          <span class="token key atrule">stateless</span><span class="token punctuation">:</span> <span class="token boolean important">true </span><span class="token comment" spellcheck="true">#true无状态；false有状态。如果业务中包含事务，这里改为false</span></code></pre><p>3、编写MQ配置类，配置交换机</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @description 消息队列配置 * @author Mr.M * @date 2022/10/4 22:25 * @version 1.0 */</span><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PayNotifyConfig</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//交换机</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String PAYNOTIFY_EXCHANGE_FANOUT <span class="token operator">=</span> <span class="token string">"paynotify_exchange_fanout"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//支付结果通知消息类型</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String MESSAGE_TYPE <span class="token operator">=</span> <span class="token string">"payresult_notify"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//声明交换机</span>  <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>PAYNOTIFY_EXCHANGE_FANOUT<span class="token punctuation">)</span>  <span class="token keyword">public</span> FanoutExchange <span class="token function">paynotify_exchange_fanout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除</span>   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FanoutExchange</span><span class="token punctuation">(</span>PAYNOTIFY_EXCHANGE_FANOUT<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="注意⚠️-跳转和重定向"><a href="#注意⚠️-跳转和重定向" class="headerlink" title="注意⚠️:跳转和重定向"></a>注意⚠️:跳转和重定向</h3><p>跳转的时候实际上是通过我们服务器端将请求转发到另外的页面或者servelt中，这个时候跳转到的目标页面或者servlet可以获取到请求对象，也可以获取到请求中的属性和参数。而外部跳转的时候实际上是第一次请求后，服务器端向我们的客户端再次发送了一个请求，这个时候服务器第二次拿到的request对象已经不是第一次请求的request对象了，所以无法获取到第一次请求里的参数和属性。</p><p>跳转的URL地址栏不会发生变化，重定向url则会发生变化。</p><p>跳转无法跳转到过程以外的jsp或者servlet，重定向可以。</p><h3 id="注意⚠️-long返回给前端精度丢失"><a href="#注意⚠️-long返回给前端精度丢失" class="headerlink" title="注意⚠️:long返回给前端精度丢失"></a>注意⚠️:long返回给前端精度丢失</h3><blockquote><p>java服务端如果直接返回Long整数数据给前端，JS会自动转换为Number类型精度浮点数，表示原理和取值范围等同于java的double。Long类型能表示的最大值是2的63次方-1，在取值范围之内，超过2的53次方的数值转换为js的NUmber时，有些数值会有精度损失。</p></blockquote><p>解决方案:</p><p>1、直接将Long id改为String id，这种只适合于这个对象只在这个方法中使用了，比较局限。</p><p>2、在属性上标注一个Jackson注解。可以添加@JsonFormat(shape&#x3D;JsonFormat.shape.STRING)或者@JsonSerialize(using&#x3D;ToStringSerializer.class)注解。</p><p>但是我们的第二种方式，存在一个问题，就是每一个我们的主键id都需要标注这个注解。我们可以在配置中进行配置。让我们的所有的id都可以采用这中序列化。</p><p>Jackson提供了这种支持，可以对ObjectMapper进行定制，具体的代码如下所示:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JacksonConfiguration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Jackson2ObjectMapperBuilderCustomizer <span class="token function">jackson2ObjectMapperBuilderCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> jacksonObjectMapperBuilder <span class="token operator">-</span><span class="token operator">></span> jacksonObjectMapperBuilder                <span class="token punctuation">.</span><span class="token function">serializerByType</span><span class="token punctuation">(</span>Long<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> ToStringSerializer<span class="token punctuation">.</span>instance<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">serializerByType</span><span class="token punctuation">(</span>Long<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> ToStringSerializer<span class="token punctuation">.</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2023/03/22/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/03/22/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式:"></a>单例模式:</h2><p>单例模式(Singleton Pattern)是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h3 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a><strong>单例模式的结构</strong></h3><p>单例模式的主要有以下角色:</p><ul><li>单例类:只能创建一个实例的类</li><li>访问类:使用单例类</li></ul><h3 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h3><p>单例类的实现主要分为两种实现方式:</p><ul><li>饿汉式:在类加载的时候，就会去创建对象</li><li>懒汉式:类加载的时候不会导致该实例被创建，而是首次使用该对象时才会被创建</li></ul><h3 id="1、饿汉式-静态变量方式"><a href="#1、饿汉式-静态变量方式" class="headerlink" title="1、饿汉式-静态变量方式"></a>1、饿汉式-静态变量方式</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 单例模式<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/14 * 单例模式 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 单例模式主要分为     * 恶汉式: 在类加载的时候，就回去创建该对象     * 懒汉式:在我们真正去实现它时才会去创建对象     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton INSTANCE<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。 instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p><h3 id="2-饿汉式-静态代码块方式"><a href="#2-饿汉式-静态代码块方式" class="headerlink" title="2 饿汉式-静态代码块方式"></a>2 饿汉式-静态代码块方式</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 恶汉式* 在静态代码块中创建该类对象 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//私有构造方法</span><span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//在成员位置创建该类的对象</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//对外提供静态方法获取该对象</span><span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说明:</p><p>该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着 类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</p><h3 id="3、懒汉式-线程不安全"><a href="#3、懒汉式-线程不安全" class="headerlink" title="3、懒汉式 线程不安全"></a>3、懒汉式 线程不安全</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 懒汉式* 线程不安全 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//私有构造方法</span><span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//在成员位置创建该类的对象</span><span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对外提供静态方法获取该对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说明:</p><p>从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的 赋值操作，那么什么时候赋值的呢?当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p><h3 id="4、懒汉式-线程安全："><a href="#4、懒汉式-线程安全：" class="headerlink" title="4、懒汉式 线程安全："></a>4、懒汉式 线程安全：</h3><p>使用synchronized来解决线程安全:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 懒汉式* 线程安全 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//私有构造方法</span><span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//在成员位置创建该类的对象</span><span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对外提供静态方法获取该对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个是可以解决我们的线程安全的问题，但是会存在一个锁的粒度会很高，导致我们的程序的性能不是很好，可以使用双重检索的方式来进行解决.</p><h3 id="5、懒汉式-双重检查锁"><a href="#5、懒汉式-双重检查锁" class="headerlink" title="5、懒汉式 -双重检查锁"></a>5、懒汉式 -双重检查锁</h3><p>对于上面的操作加锁问题，我们单例模式应该是一个读多写少的问题。所以针对这个问题，我们可以改造我们的代码:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">DoubleSingleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//volatile保证我们不会受到可见性的影响。</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> DoubleSingleton instance<span class="token punctuation">;</span>    <span class="token keyword">public</span> DoubleSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第一次进行校验</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//会出现线程安全的问题</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p><p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 volatile 关键字, volatile 关 键字可以保证可见性和有序性。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">DoubleSingleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//volatile保证我们不会受到可见性的影响。</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> DoubleSingleton instance<span class="token punctuation">;</span>    <span class="token keyword">public</span> DoubleSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第一次进行校验</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//会出现线程安全的问题</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><p>添加 volatile 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程 的情况下线程安全也不会有性能问题。</p><h3 id="6、懒汉式-静态内部类"><a href="#6、懒汉式-静态内部类" class="headerlink" title="6、懒汉式 -静态内部类"></a>6、懒汉式 -静态内部类</h3><p>静态内部类单例模式中实例有内部类创建，由于JVM在类加载的过程中，是不会加载静态内部类的，只有内部类的属性&#x2F;方法被调用时才会被加载，并初始化其静态属性。静态属性由于被static修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHandler</span><span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> SingletonHandler<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说明:</p><p>第一次类记载的时候，不会去初始化的我们的静态内部类的，只有第一次调用getInstance,虚拟机加载SingletonHander，并初始化。</p><p>小结:<br> 静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任<br> 何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题:"></a>存在的问题:</h3><p>1、怎么破坏单例模式:</p><p>使上面定义的单例类(Singleton)可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。</p><p>序列化反序列化</p><p>Singleton类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//私有构造方法</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//对外提供静态方法获取该对象</span><span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Test类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//往文件中写对象</span><span class="token comment" spellcheck="true">//writeObject2File(); //从文件中读取对象</span>        Singleton s1 <span class="token operator">=</span> <span class="token function">readObjectFromFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Singleton s2 <span class="token operator">=</span> <span class="token function">readObjectFromFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断两个反序列化后的对象是否是同一个对象</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton <span class="token function">readObjectFromFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//创建对象输入流对象</span>        ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span>                <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\Think\\Desktop\\a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//第一个读取Singleton对象</span>        Singleton instance <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writeObject2File</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//获取Singleton类的对象</span>        Singleton instance <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建对象输出流</span>        ObjectOutputStream oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span>                <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\Think\\Desktop\\a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将instance对象写出到文件中</span>        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面代码运行结果是 false ，表明序列化和反序列化已经破坏了单例设计模式。</p><p>2、可以通过我们的暴力反射可以破解我们的单例模式</p><p>Singleton类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">DoubleSingleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//volatile保证我们不会受到可见性的影响。</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> DoubleSingleton instance<span class="token punctuation">;</span>    <span class="token keyword">public</span> DoubleSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第一次进行校验</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//会出现线程安全的问题</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><p>Test类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//获取Singleton类的字节码对象</span>        Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//获取Singleton类的私有无参构造方法对象</span>        Constructor constructor <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//取消访问检查</span>        constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建Singleton类的对象s1</span>        Singleton s1 <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建Singleton类的对象s2</span>        Singleton s2 <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断通过反射创建的两个Singleton对象是否是同一个对象</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span><span class="token punctuation">}</span></code></pre><h3 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决:"></a>问题的解决:</h3><p>1、序列化、反序列化方式破解我们的单例模式的解决方法:</p><p>在Singleton类中添加 readResolve() 方法，在反序列化时被反射调用，如果定义了这个方法， 就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 下面是为了解决序列化反序列化破解单例模式 */</span><span class="token keyword">private</span> Object <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2、反射方式破解单例的解决方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//私有构造方法</span><span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>就是使用异常的方式来进行解决.</p><p>说明: 这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操</p><p>作。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm</title>
      <link href="/2022/04/27/jvm/"/>
      <url>/2022/04/27/jvm/</url>
      
        <content type="html"><![CDATA[<h2 id="1、jvm的体系结构"><a href="#1、jvm的体系结构" class="headerlink" title="1、jvm的体系结构"></a>1、jvm的体系结构</h2><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220220161522429.png" alt="image-20220220161522429"></p><h2 id="2、什么是类加载器"><a href="#2、什么是类加载器" class="headerlink" title="2、什么是类加载器"></a>2、什么是类加载器</h2><p>作用:类加载器用于加载类对象的。</p><p>类加载器的分类:根加载器、扩展加载器、应用加载器。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220328204134383.png" alt="image-20220328204134383"></p><h2 id="3、双亲委派机制"><a href="#3、双亲委派机制" class="headerlink" title="3、双亲委派机制"></a>3、双亲委派机制</h2><p> 一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。</p><p>顺序:发现委托是从下向上,然后具体查找过程却是自上至下。</p><p>作用:</p><p>1、避免重复加载,当父类加载的时候,子类的classloader就没必要在加载一次.</p><p>2、安全因素，如果不使用这样的委托模式,那么用户可以随时自定义的String来动态替代java的核心类.这样存在非常大的隐患。原因：因为String的类在JVM启动的时候,就已经被父类的加载器进行加载了,用户自定义的类就无法加载进去了。</p><h2 id="4、Native-本地方法栈"><a href="#4、Native-本地方法栈" class="headerlink" title="4、Native(本地方法栈)"></a>4、Native(本地方法栈)</h2><p>什么是native:java的关键字,凡事带了native关键字的表示说明java的作用域范围达不到了，会去调用底层c或者c++的本地库。</p><p>会进入到本地方法栈。调用本地方法接口JNI</p><p>JNI的作用:扩展java的使用，使其能够融合不同的编程语言为java所用。</p><p>执行顺序:</p><p>它会在内存中专门开辟一块标志区域:native method stack，登记native方法,在最终执行的时候，加载本地方法库中的方法</p><h2 id="5、程序技术器"><a href="#5、程序技术器" class="headerlink" title="5、程序技术器"></a>5、程序技术器</h2><p>1、程序计数器是一块较小的区域,可以看作是当前线程执行的字节码的行号指示器。</p><p>2、作用:程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能。</p><p>3、程序计数器是线程私有?</p><ul><li>因为java的多线程通过轮流切换、分配处理器执行时间来实现的。在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此为了线程切换后能恢复到正确的执行位置。</li></ul><p>4、如果线程正在执行的是一个java方法，那么这个计数器记录的是正在执行的是字节码指令的地址，如果是本地方法，那么这个计数器则为null。</p><p>5、程序计数器是唯一一个没有规定任何OutOfMemoryError情况的区域.</p><h2 id="6、方法区"><a href="#6、方法区" class="headerlink" title="6、方法区"></a>6、方法区</h2><p>Method area方法区</p><p>方法区和堆一样,是各个线程共享的内存区域,它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>方法区是规范,像什么永久代(jdk1.6 占用的堆内存)和元空间(jdk 1.8 占用的是系统内存)只是实现。</p><p>如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。</p><p>jdk1.6的方法区内存结构:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220726163247742.png" alt="image-20220726163247742"></p><p>Jdk 1.6组成：</p><p>类信息、类加载器、运行时常量池（字符常量池）</p><p>Jdk 1.8的组成:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220726164138565.png" alt="image-20220726164138565"></p><p>在jdk1.8之后，将永久带进行了废弃,使用元空间来实现方法区。将元空间放到了直接内存(本地内存)中。</p><p>还有一个区别就是,将SpringTable，从元空间中抽取出来放到了heap堆内存中。</p><p>元空间的调控参数：</p><p>-XX:MaxMetaspaceSize&#x3D;8m</p><p>字节码:cglib在运行期间动态生成类字节码,完成动态的类加载</p><p>方法区的重要组成部分:运行时常量池</p><ul><li>常量池,就是一张表,虚拟机指令根据这张常量表找到执行的类名、方法名、参数类型、字面量等信息。</li><li>运行时常量池，常量池是*.class文件中的，当该类被加载,它的常量池信息就会放入运行时常量池,并把里面的符号地址变为真实地址。</li></ul><p>StringTable的特性:</p><ul><li>常量池中的字符串仅是符号,第一次用到时才变为对象</li><li>利用串池的机制,来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder(1.8)</li><li>字符串常量拼接的原理是编译期优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池。如果串池中有,则直接返回串池中的对象，如果串池中没有,就将改对象放入到串池中。</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//常量池和串池之间的关系</span><span class="token comment" spellcheck="true">//常量池中的信息,都会被加载到运行时常量池中。</span><span class="token comment" spellcheck="true">//创建一个StringTable也就是字符串常量池.将字面值放入到StringTable中。先去查找一下是否存在改数据，如果存在，那么就不会放进行，如果没有就将字面值放进去。</span><span class="token comment" spellcheck="true">//StringTable Hashtable,不能扩容</span>String s1<span class="token operator">=</span><span class="token string">"a"</span><span class="token punctuation">;</span>String s2<span class="token operator">=</span><span class="token string">"b"</span><span class="token punctuation">;</span>String s3<span class="token operator">=</span><span class="token string">"ab"</span><span class="token punctuation">;</span>String s4<span class="token operator">=</span>s1<span class="token operator">+</span>s2<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//底层 new StringBuilder()调用append方法来进行拼接操作。调用toString()将其转为String对象</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3<span class="token operator">==</span>s4<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>在jdk1.6 StringTable也就是字符串常量池是存储在永久带中的。而jdk1.8以后，移除了永久带,使用元空间来进行代替.将字符串常量池从方法区里移出，放到了堆内存中。</li><li>springtable是可以被垃圾回收的<ul><li>参数:-Xmx:10m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails -verbose:gc</li></ul></li><li>springtable的性能调优<ul><li>调整-XX:StringTableSize&#x3D;桶的大小</li><li>可以将字符串放入到常量池中。</li></ul></li></ul><h2 id="7、队列和栈"><a href="#7、队列和栈" class="headerlink" title="7、队列和栈"></a>7、队列和栈</h2><p>队列（FIFO）：先进先出</p><p>栈:先进后出</p><p>生命周期：虚拟机栈道生命周期与线程相同的</p><p>栈也是线程私有的。</p><p>栈:8大基本类型+对象引用+实例方法</p><p>栈运行原理:栈帧</p><p>什么时候执行:</p><blockquote><p>每个方法执行的时候，java虚拟机都会同步创建一个栈帧。每一个方法被调用直至执行完毕的过程，就对应一个栈帧在虚拟机中从入栈到出栈道过程。</p></blockquote><p>栈满了:StackOverflowError</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220726134034510.png" alt="image-20220726134034510"></p><p>栈的定义:</p><ul><li>每个线程运行时所需要的内存,称为虚拟机栈</li><li>每个栈由多个栈帧组成,对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧,对应着当前正在执行的那个方法 ,存在于栈帧的顶部</li><li>栈帧指每个方法运行时所需要的内存空间,有参数、局部变量、返回地址等</li></ul><p>栈帧用来存储什么?</p><p>1、用于存储局部变量表、操作数栈、动态连接、方法出口等</p><ul><li>局部变量存放着各种java虚拟机的基本数据类型（byte、short、int、long、float、double、boolean、char）和对象引用(它不等同于对象本身，可以只是一个只想对象起始地址的引用地址)和returnAddress(存储的是return后要执行的字节码的指令地址)类型</li></ul><p><font color="red"><strong>在java虚拟机中规范队这个内存区域规范了两类异常状况:1、如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError异常。2、如果java虚拟机栈容量可以动态扩展当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常</strong></font></p><p><font color="red">问题分析:</font></p><ul><li>垃圾回收是否涉及到栈内存？</li></ul><p>不会，因为方法执行结束后,栈空间的内存的栈帧就会被进行弹栈处理,栈空间会自动释放.</p><ul><li>栈内存分配是否越大越好?</li></ul><p>栈的内存可以通过参数进行调整,通过-Xss size。栈内存分配不是越大越好,因为物理内存是固定的，比如说有500M，栈内存为1m，那么在理论上就可以创建500个线程。如果栈内存变为了2m，那么我们的线程就会减少至250个。栈内存的分配越大，就会导致我们的线程数就越少。</p><ul><li>方法内的局部变量是否是线程安全的</li></ul><p>线程安全问题在于是否共享，如果共享就要考虑线程安全问题，线程私有不需要考虑线程安全问题的。</p><p>方法内的局部变量是否逃离了方法的作用域,如果逃离了，那么就需要考虑线程安全问题。如果没有逃离就不需要考虑线程安全的问题。</p><p>栈内存溢出:</p><ul><li>栈帧过多导致栈内存溢出（递归）</li><li>栈帧过大导致内存溢出</li></ul><p><font color="red">调控参数:</font></p><ul><li>可以使用-Xss256k，来调控栈内容大小</li></ul><p><font color="orange">线程的诊断案列：</font></p><p>1、CPU占用过多</p><blockquote><p>1、可以使用top去定位一下后台的是那个进程的cpu占用过高</p><p>2、通过ps和grep可以准确找到那个进程里面那个线程占用过高</p><p>3、通过jstack 进程id,会将某一个进程中的所有的java线程都会展示出来</p><ul><li>可以根据线程id找到有问题的线程,进一步定位到问题代码的源码行号</li></ul></blockquote><p>2、程序运行很长时间没有结果</p><p>还是使用jstack 进程id，查看一下那端代码出现问题，进行解决.</p><h2 id="7、Heap-堆"><a href="#7、Heap-堆" class="headerlink" title="7、Heap 堆"></a>7、Heap 堆</h2><p>通过new关键字,创建对象都会使用堆内存</p><p>特点：它是被所有线程共享的一块内存区域,堆中对象都需要考虑线程安全问题，存在垃圾回收机制。</p><p>目的:   存放对象实例。</p><p>堆内存溢出:OutOfMemoryError</p><p>出现的原因: java堆中没有内存完成实例分配，并且堆也无法在扩展时，java虚拟机将会抛出OutOfMemoryError异常。</p><p>堆空间的调参:  -Xmx8m -Xms</p><p>堆内存的诊断:</p><ul><li>jps,拿到系统中有哪些java进程</li><li>jmap工具<ul><li>jmap -heap 进程id</li><li>查看堆内存中占用情况,只能查看某一时刻</li></ul></li><li>jconsole工具<ul><li>提供了图形可视化窗口,多功能连续监视</li></ul></li><li>JvisualVm工具<ul><li>也是一个图形可视化的窗口,只不过提供了更加强大的功能</li></ul></li></ul><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>对象的创建通过new关键字，但是从jvm的层面来说对象的创建过程又是什么样的呢?</p><p>当java虚拟机遇到一条字节码new指令时,首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用,并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。在类加载检查通过后,接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等于把一块确定大小的内存块从java堆中划分出来，根据java堆中的内存是否规整来选择那种分配方式。而java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理的能力决定的。因此，当使用serial、ParNew等代压缩整理过程代收集器时,采用指针碰撞的方式来分配内存，即简单有高效。而当使用cms这种基于清除算法的收集器时,理论上就只能采用较为复杂的空闲列表来分配内存。</p><p>对象创建在虚拟机中时非常频繁的行为,即使仅仅修改一个指针所指向的位置，在并发的情况下也并不是线程安全的,可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种解决方案:1、采用同步处理–虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一小块内存(线程隔离),称谓本地线程分配缓存(TLAB)，那个线程要分配内存,就在那个线程的本地缓冲区中分配,只有本地缓冲区用完了,分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB,可以通过-XX:+&#x2F;-UseTLAB参数来设定。</p><p>对象在内存分配空间之后，虚拟机必须将分配到的内存空间懂初始化为零值,如果使用了TLAB的话，这一项工作可以提前至TLAB中进行完成。接下来，java虚拟机还要对对象进行必要的设置，例如这个对象时那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前运行状态的不同,如是否启用偏向锁等。从虚拟机的角度来看一个新的对象已经产生了。</p><p>两种分配内存的方式:</p><p>1、假设java堆中内存时绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边,中间放着一个指针作为分界点的指示器,那所分配内存仅仅是把那个指针向空闲空间方法挪动一段与对象大小相等的距离，这种分配方法称为”指针碰撞”。</p><p>2、假设java堆中的内存不是绝对规整的,已被使用和空闲的内存相互交错在一起,那就没有办法简单的通过指针碰撞的方法来分配内存了。虚拟机就必要维护一个列表,记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例,并更新列表上的记录，这种分配方式称为空闲列表。</p><p>对象内存布局:</p><p>对象在堆内存中的存储布局可以划分为三部分：对象头(Header)、实例数据和对齐填充。</p><p>对象头包含两类信息:</p><ul><li>用于存储对象自身的运行时数据,如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程id、偏向时间戳等。(Mark world)</li></ul><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220729225606753.png" alt="image-20220729225606753"></p><ul><li>类型指针,即对象指向它的类型元数据等指针,java虚拟机通过这个指针来确定改对象是那个类的实例。</li></ul><p>实例数据存储的是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段懂必须记录起来。</p><p>对齐填充,这并不是必然存在的，也没有特别的含义，就是起到了占位符的作用。对象头地址必须是8的整数倍，如果对象实例部分没有对齐，就通过对齐填充来补全为8字节的倍数。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>主流的虚拟机对象访问方式有两种方式</p><ul><li><p>句柄</p><ul><li>如果使用句柄访问的话，java堆中将可能会划分出一块内存来作为句柄池,reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</li></ul><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220729230633077.png" alt="image-20220729230633077"></p></li><li><p>直接指针</p><ul><li>如果使用直接指针访问的话，java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li></ul></li></ul><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220729230837541.png" alt="image-20220729230837541"></p><p>使用句柄的好处就是:reference中存储的是稳定句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p><p>使用直接指针来访问最大的好处就是访问速度更快。</p><h2 id="8、直接内存"><a href="#8、直接内存" class="headerlink" title="8、直接内存"></a>8、直接内存</h2><p>直接内存也叫做系统内存,一般是用于io操作的。用于数据缓存区</p><p>分配回收成本较高,但读写性能高</p><p>不受jvm内存回收管理</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220727110606394.png" alt="image-20220727110606394"></p><p>从磁盘文件读取数据到系统缓存区，但是因为java代码无法直接系统内存,所以需要将系统内存中的数据，在拿到java堆内存中的缓冲区，到了这里java代码就可以直接操作了。但是这样会出现了重复,因为系统内存有一份，java的堆内存又有一份。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220727112654053.png" alt="image-20220727112654053"></p><p>开辟一块直接内存,这样不管是系统内存还是java内存都可以直接使用。在java中要使用unsafe类开管理内存,但unsafe类不能通过new关键字来进行获取，要通过反射去拿。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>kevintam<span class="token punctuation">.</span>stock<span class="token punctuation">;</span><span class="token keyword">import</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2022/7/27 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnsafeDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchFieldException<span class="token punctuation">,</span> IllegalAccessException <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//        Unsafe unsafe = Unsafe.getUnsafe();</span><span class="token comment" spellcheck="true">//        System.out.println(unsafe);</span>        Field theUnsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"theUnsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//设置是否开启</span>        theUnsafe<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Unsafe unsafe <span class="token operator">=</span> <span class="token punctuation">(</span>Unsafe<span class="token punctuation">)</span>theUnsafe<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        unsafe.compareAndSwap</span><span class="token comment" spellcheck="true">//        unsafe.</span>        <span class="token comment" spellcheck="true">//分配空间</span><span class="token comment" spellcheck="true">//        unsafe.allocateMemory()</span>        <span class="token comment" spellcheck="true">//释放内存</span><span class="token comment" spellcheck="true">//        unsafe.freeMemory();</span><span class="token comment" spellcheck="true">//        System.out.println(unsafes);</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>分配和回收原理:</p><ul><li>使用Unsafe对象完成直接内存的分配回收,并且回收需要主动调用freeMemory</li><li>ByteBuffer的实现类内部,使用了Clear(虚引用)来监视ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Clear的clear方法调用freeMemory来释放直接内存。</li></ul><h2 id="9、垃圾回收"><a href="#9、垃圾回收" class="headerlink" title="9、垃圾回收"></a>9、垃圾回收</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="1-1引用计数法"><a href="#1-1引用计数法" class="headerlink" title="1.1引用计数法"></a>1.1引用计数法</h4><p> 指：只要有一个对象被其他对象所引用，就会让这个对象的计数器加1，没有引用就会减一，直到这个计数会0，即可回收改对象</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220727130137448.png" alt="image-20220727130137448"></p><p>缺点:就是如果两个对象互相引用，就会导致这个对象的引用计数永远不会为0，那么就不会被进行回收.</p><h4 id="1、2-可达性分析算法"><a href="#1、2-可达性分析算法" class="headerlink" title="1、2 可达性分析算法"></a>1、2 可达性分析算法</h4><p>可达性分析算法首先要确定一系列根对象(不会被当做垃圾回收的对象，就叫做根对象)。如果一个对象有被这个根对象直接或者间接引用的对象，就不能被回收。如果没有被根对象直接或间接引用的对象，就会被回收。</p><ul><li><p>java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p></li><li><p>扫描堆中的对象，看是否能够沿着GCRoot对象为起点的引用链找到该对象，找不到，表示可以回收</p></li><li><p>那些对象可以作为GCRoot？</p><ul><li>java虚拟机栈中引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中的常量引用对象</li><li>本地方法栈中的native修饰的对象</li><li>加锁的一些对象，也可以作为GCRoot</li></ul></li><li><p>四种引用</p><ul><li>强引用:常用的引用变量赋值给一个对象，这就是强引用,jvm不会回收强引用</li><li>弱引用:SoftReference,当jvm内存空间不足时，会对软引用进行回收。如果jvm的内存空间足够大情况下，是不会对弱引用进行回收的</li><li>软引用:WorkReference，不管jvm的内存空间是否足够,只要发生了gc，就会把软引用进行回收</li><li>虚引用:相当于没有引用,只能搭配引用队列来进行使用ReferenceQueue。</li></ul></li></ul><p>可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能进行分析，这意味着必须全程冻结用户线程的运行。</p><p>GCRoot继续向下遍历对象图,这一步骤的停顿时间就必定会与java堆容量直接成正比例关系，堆越大，存储的对象越多,对象图结构越复杂,要标记更多对象而产生的停顿时间自然就更大。</p><p>为了解决用户线程的停顿时间,引入了三色标记作为工具辅导推导。把遍历对象图过程中遇到的对象，按照”是否访问过”这个条件标记成以下三种颜色:</p><ul><li>白色:表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li><li>黑色:表示已经被垃圾收集器访问过,且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过,它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。</li><li>灰色:表示对象已经被垃圾收集器访问过,但这个对象上至少存在一个引用还没有被扫描过。</li></ul><p>从三色标记这里可以知道,为什么垃圾收集器在枚举GCRoots的时候，需要将其他用户线程进行冻结。</p><ul><li>如果垃圾收集线程在工作,用户线程是并发工作的，收集器在对象图上标记颜色,同时用户线程在修改引用关系-即修改对象图的结构,这可以会出现两种问题:<ul><li>把原本消亡的对象错误标记为存活，这是可以容忍的,下次垃圾收集器在工作时，就可以回收这些浮动垃圾。</li><li>把原本存活的对象错误标记为已消亡，这是不能忍受的错误。程序出现错误。</li></ul></li></ul><p>致命错误是如何产生的:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220731003407781.png" alt="image-20220731003407781"></p><p>一下两个条件同时满足时,会产生对象消失问题,即原本应该是黑色的对象被误标为白色:</p><ul><li>赋值器插入了一条或多条从黑色对象到白色对象到新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象到直接或间接引用</li></ul><p>由此产生两种解决方案:</p><ul><li>增量更新<ul><li>破坏的第一个条件,当黑色对象插入新的指向白色对象的引用关系时,就将这个新插入的引用记录下来,等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为,黑色对象一旦新插入了指向白色对象的引用之后,它就变回灰色对象。</li></ul></li><li>原始快照<ul><li>当灰色对象要删除指向白色对象的引用关系时,就将这个要删除的引用记录下来,在并发扫描结束之后,再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</li></ul></li></ul><h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="2-0-垃圾回收算法的分代收起理论"><a href="#2-0-垃圾回收算法的分代收起理论" class="headerlink" title="2.0  垃圾回收算法的分代收起理论"></a>2.0  垃圾回收算法的分代收起理论</h4><p>商用虚拟机的垃圾收集器大多遵循分代收集的理论进行设计的。主要分为三个分代假说:</p><ul><li>弱分代假说:绝大多数对象都是朝生夕死的</li><li>强分代假说:熬过越多次垃圾收集过程的对象就越难以消亡。</li><li>跨代引用假说:跨代引用相对于同代引用来说仅占极少数。</li></ul><p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p><p>新生代收集(Minor GC&#x2F;Young GC)：指目标只是新生代的垃圾收集</p><p>老年代收集(OldGC&#x2F;Major GC): 指目标只是老年代的垃圾收集。目前只有cms收集器会单独收集老年代的行为。</p><p>混合收集(Mixed GC): 指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。</p><p>整堆收集(Full GC): 收集整个java堆和方法区的垃圾收集。</p><h4 id="2-1-标记清理算法"><a href="#2-1-标记清理算法" class="headerlink" title="2.1 标记清理算法"></a>2.1 标记清理算法</h4><p>标记清理算法:沿着GCRoot对象的引用链去找,扫描堆中的空间,找出所有不被GCRoot直接或者间接引用的对象,然后进行标记。标记完成之后,会把这些标记完的对象进行清除，清除只是将空间的起始地址进行了一个记录,放入到了空间列表，下一次有对象来就直接使用这个空闲列表里面的空间直接进行覆盖即可。</p><p>优点:速度相对较快，因为它没有真正意义上对空间进行清除。</p><p>缺点：会产生内存碎片。不是连续的内存空间，而是像碎片一样的散列开的空间。</p><p>执行效率不稳定,如果java堆中包含大量对象,而且其中大部分是需要被回收的这时必须进行大量标记和清除掉动作，导致标记和清除两个过程的执行效率懂随着对象增长而降低。</p><h4 id="2-2-标记整理算法"><a href="#2-2-标记整理算法" class="headerlink" title="2.2 标记整理算法"></a>2.2 标记整理算法</h4><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220727151030587.png" alt="image-20220727151030587"></p><p>标记阶段还是一样的，沿着GCRoot的引用链进行遍历,找到所有不呢GCRoot直接会间接引用的对象，进行标记。</p><p>整理: 会将标记对象空间后面的空间往前进行移动整理.可以解决内存碎片问题</p><p>缺点：因为你要将空间进行移动，所以涉及到对象引用也要跟着移动到的问题。需要效率会比标记清理会低一些。而且在移动的时候，会有stw暂停用户线程。</p><h4 id="2-3-复制算法："><a href="#2-3-复制算法：" class="headerlink" title="2.3 复制算法："></a>2.3 复制算法：</h4><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220727152038454.png" alt="image-20220727152038454"></p><p>复制算法会开辟一个一摸一样大小的空间。然后在原有空间的基础上做垃圾标记，也是使用沿着GCRoot的引用链，找到所有被GCRoot直接或间接引用的对象，然后做出标记。然后在被GCRoot引用的对象放入到to(新的空间)里面,将form中的空间进行清除。清除完后,将to和from进行替换操作。to变成了from,from变成了to。</p><p>优点：不会产生内存碎片</p><p>缺点: 要使用两份的空间</p><p>所以在jvm中新生代里面采用了我们复制算法，但对其进行优化，jvm中from区和to区占比为8:1，也就是jvm认为90%的新生代对象都是早生夕死的。所以才可以设计。但是存在一个问题，就是当我们的清理垃圾不够的时候，也就是说我们的from空间的值大于to空间，那么怎么进行交换呢，就需要使用我们的分配担保，也就是当内存不足时，去使用一下其他的内存空间，一般都是老年代的空间。</p><h4 id="2-4-垃圾回收算法重要概念"><a href="#2-4-垃圾回收算法重要概念" class="headerlink" title="2.4 垃圾回收算法重要概念:"></a>2.4 垃圾回收算法重要概念:</h4><h5 id="2-4-1-根节点枚举"><a href="#2-4-1-根节点枚举" class="headerlink" title="2.4.1  根节点枚举"></a>2.4.1  根节点枚举</h5><p>可达性分析算法从GCRoots集合找引用链来决定哪些对象为垃圾对象。</p><p>固定的可作为GCRoots的节点主要在全局性的引用与执行上下文。</p><p>所有的收集器在根节点枚举这一步骤是都是必须暂停用户线程，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的stw问题。</p><p>为什么需要所有的用户线程懂必须在一个能保障一致性的快照里?</p><p>就是因为枚举根节点的时候,如果其他的线程不进行暂停的话，就会产生的新的根节点，根节点的分析结果不会是准确的。所以导致了枚举根节点是必须是停顿的。</p><p>安全点:</p><p>程序执行时并非所有地方都能停下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”</p><p>安全点的选择标准:</p><blockquote><p>Safe Point 的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行的时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。</p></blockquote><p>如何让线程跑到最近的安全点然后停顿下来。两种方案：</p><ul><li>抢先式中断<ul><li>首先中断所有的线程.如果还有线程不在安全点,就恢复线程，让线程跑到安全点</li></ul></li><li>主动式中断<ul><li>设置一个中断标志,各个线程运行到saftpoint的时候主动轮询这个标志，如果中断标志为真，则将进行中断挂起。</li></ul></li></ul><p>记忆集：</p><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p><p>目的:为了避免跨代引用时,需要去全表扫描非收集器域。</p><p>因为收集器只需要通过记忆集判断出某一块非收集区域是否存在执行收集区域的指针就可以了，并不需要了解这些跨代指针的全部实现细节.</p><p>选择更为粗旷的记录粒度来节省记忆集的存储和维护成本,可供选择的记录精度:</p><p>1、对象精度:每一个记录精确到一个对象,该对象里有字段含有跨代指针</p><p>2、卡精度:每一个记录精确到一块内存区域,该区域有对象含有跨代指针。</p><p>3、字长精度:每一个记录确保到一个机器字长,该字包含跨代指针。</p><p>卡表:</p><p>第三种卡精度我们称为卡表(Card Table)的方式去实现记忆集。</p><p>卡表是记忆集的一种具体实现方式.</p><p>卡表定义了记忆集的记录精度、与堆内存的映射关系等。</p><p>卡表的实现就是一个简单的字节数组。每一个元素懂对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称为卡页。</p><p>卡页大小都是以2的N次幂的字节数.</p><p>一个卡页的内存中通常包含不止一个对象,只要卡页内有一个对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为1，称为这个元素变脏，没有则标识为0.在垃圾收集发生时,只要筛选出卡表中变脏的元素,就能轻易得出哪些卡页内存块中包含跨代指针，把它加入GCRoot中一并扫描即可。</p><p>卡表怎么变脏:其他的分代区域对象引用了本区域对象时,其对应的卡表元素就应该变脏，变脏时间点原则上就应该发生在引用类型字段复制的那一刻。</p><h3 id="3、分代垃圾回收"><a href="#3、分代垃圾回收" class="headerlink" title="3、分代垃圾回收"></a>3、分代垃圾回收</h3><p>jvm虚拟机中不会使用单一的清理算法，它会根据需要使用的不同的垃圾回收算法，就是分代算法。</p><p>jvm将堆中的内存分为新生代、老年代.</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220727153415636.png" alt="image-20220727153415636"></p><p>新生代划分为三个小区域分别是：伊甸园区、幸存区from、幸存区to。</p><p>为什么要做这样一个区域划分呢?</p><p>主要是java中的有些对象需要长时间使用，这些长时间使用的对象放入到老年代，新声代中存放一些使用完之后，可以丢弃的对象，这样就可以根据对象的生命周期的不同来使用不同的垃圾回收算法.新生代因为要处理的都是一些朝生夕死的对象，所以发生垃圾回收的比较频繁。老年区因为存储着需要长时间需要的对象，需要发生垃圾回收不是很频繁。</p><h5 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h5><ul><li>对象首先分配在新生代,当新生代的内存空间不足时,会触发minor gc，去进行垃圾回收.</li><li>伊甸园和幸存区from存活的对象使用copy算法复制到to中,存活的对象年龄加1.并且交换form和to。</li><li>minor gc会触发stop the world ，暂停其他用户的线程,等垃圾回收结束,用户线程才恢复运行</li><li>当对象寿命超过阈值时,会晋升至老年代,最大寿命时15(4bit)</li><li>在老年代空间不足,会先尝试触发minor gc，如果之后空间仍然不足,那么就会触发full gc，stw的时间更长。</li><li>老年代使用的算法有可能是标记清除也有可能是标记整理</li><li>大对象他会直接跳过新声代，直接放入到老年代</li></ul><h4 id="4、jvm的参数"><a href="#4、jvm的参数" class="headerlink" title="4、jvm的参数"></a>4、jvm的参数</h4><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220727164543590.png" alt="image-20220727164543590"></p><p>-Xms20m -Xmx20m -Xmn10m -XX:+UseSerialGC -XX:+ProintGCDetails -verbose:gc</p><h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="4-1-串行"><a href="#4-1-串行" class="headerlink" title="4.1 串行"></a>4.1 串行</h4><ul><li>单线程</li><li>堆内存较小，适合个人电脑</li></ul><p>-XX:+UserSerialGC&#x3D;Serial+SerialOld 开启串行垃圾回收器的参数</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220727185559919.png" alt="image-20220727185559919"></p><p>Serial: 新生代:复制算法</p><p>SerialOld：老年代：标记清理算法</p><p>当垃圾回收线程运行的时候,其他的用户线程会阻塞住。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="4-2-吞吐量优先（parallel-怕我no-）"><a href="#4-2-吞吐量优先（parallel-怕我no-）" class="headerlink" title="4.2 吞吐量优先（parallel(怕我no)）"></a>4.2 吞吐量优先（parallel(怕我no)）</h4><ul><li>多线程</li><li>堆内存较大，多核cpu</li><li>让单位时间内，STW的时间最短</li><li>开启吞吐量优先的参数:-XX:+UseParallelGC~-XX:+UseParallOldGC jdk1.8下默认是开启的</li><li>控制吞吐量优先的线程数:-XX:ParalleGCThreads&#x3D;n</li><li>-XX:+UseAdaptiveSizePolicy，自适应的大小调整策略.主要是调整新声代的大小</li><li>-XX:GCTimeRatio（raixio）&#x3D;ratio:根据你所设置的目标去尝试调整堆的大小 1&#x2F;(1+ratio)</li><li>-XX:MaxGCPauseMillis&#x3D;ms :暂停对毫秒数 默认值为:200毫秒</li></ul><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220727190355563.png" alt="image-20220727190355563"></p><p>Parallel scanvenge 新生代收集器，会让我们的用户线程运行到我们的安全点，然后去执行我们的垃圾回收线程，去回收垃圾。复制算法。</p><p>Prallel old老年代的收集器。</p><h4 id="4-3-响应时间优先"><a href="#4-3-响应时间优先" class="headerlink" title="4.3 响应时间优先"></a>4.3 响应时间优先</h4><ul><li>多线程</li><li>堆内存较大，多核cpu</li><li>重点:尽可能让单次STW到时间最短</li></ul><p>Cms:ConCurrentMarkSweep :并发的标记清理的垃圾回收器，是一种以获得最短回收停顿时间为目标的收集器，标记清楚算法，运作过程：初始标记,并发标记，重新标记，并发清除,收集结束后会产生大量空间碎片。</p><p>并行: 是在同一时刻执行多个事情</p><p>并发；是指在同一时间段内执行多个事情</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220727233119094.png" alt="image-20220727233119094"></p><p>流程:</p><ul><li>多个用户线程正在执行，到达安全点，会触发初始标记，初始标记只会标记一些根对象,初始标记完成后,用户线程恢复运行，垃圾回收线程会执行并发标记，这时其他的用户线程都是可以执行的,因为其他线程也在运行，就有可能你标记为的垃圾，会被改动，所以需要再次重新标记。重新标记完成之后，会触发了并发清理,清除阶段是清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个也可以与用户线程同时并发进行。</li></ul><p>参数：-XX:+UseConcMarkSweepGC~ -XX:+UseParNewGC~SerialOld</p><p>-XX:ConcGCThreads&#x3D;threads 并发线程素</p><p>-XX:+CMSScavengeBeforeRemark：当我们要去执行重新标记之前，会执行一个新声代的垃圾回收。使用ParNewGc去做。</p><p>serial：新声代的复制算法</p><p>serial old使用的是标记清理算法</p><p>只不过是单线程的，串行。</p><p>stw会有点长。</p><p>ParNew基于新声代的复制算法。</p><p>cms是基于老年代的标记清理算法。以获取最短回收停顿时间为目标的收集器。 初始表示、并发标记、重新标记、标记清理。</p><p>一个是并发。</p><p>1、无法清理浮动垃圾，线程还在使用，所以还有产生一些垃圾。</p><p>2、占用cpu资源。</p><p>3、标记清理的算法，所以会出现内存碎片的问题。</p><p>cms一些问题：</p><p>1、并发回收导致cpu资源紧张</p><p>在并发阶段,它虽然不会导致用户线程停顿,但却会因为占用了一部分线程而导致应用程序变慢，降低程序的吞吐量。cms默认开启的回收线程数是:(cpu核心数+3)&#x2F;4,当cpu核心数不足四个时,cms对用户程序的影响就可能变得很大。</p><p>2、无法清理浮动垃圾</p><p>在cms的并发标记和并发清理阶段，用户线程还在继续运行，就还会伴随有新的垃圾对象不断产生,但这一部分垃圾对象是出现在标记过程结束以后，cms无法在当次收集中处理掉它们,只好留到下一次垃圾收集时再清理掉。这一部分垃圾被称为”浮动垃圾”。</p><p>3、内存碎片问题</p><p>cms是一款基于”标记-清理”算法实现的回收器,这意味着回收结束时会有内存碎片产生。</p><p>4、并发失败</p><p>cms是基于标记-清理的算法实现的回收器，所以会产生的内存碎片，而一旦内存碎片过大时,就有可能新生代和老年代因为内存碎片过多，就会长生并发失败。</p><h4 id="4-4-G1（Garbage-first）"><a href="#4-4-G1（Garbage-first）" class="headerlink" title="4.4 G1（Garbage first）"></a>4.4 G1（Garbage first）</h4><ul><li><p><font color="red">G1目标是在延迟可控的情况下获得尽可能高的吞吐量,所以才被称为”全功能收集器”。</font></p></li><li><p>G1是一个并行回收器,它把堆内存分割为很多不相关的区域(region)。使用不同的region来表示Eden、幸存区from、幸存去to、老年代等。</p></li><li><p>G1 Gc有计划避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及所需时间的经验值),在后台维护一个优先列表，每次根据允许的收集时间,优先回收价值最大的Region。</p></li><li><p>由于这种方式的侧重点在于回收垃圾最大量的区间(Region)，所以我们给G1一个名字:垃圾优先(Garbage first)</p></li><li><p>G1是一款面向服务端应用的垃圾收集器.主要针对配备多核cpu及大容量内存多机器。</p></li><li><p>jdk中不是默认的垃圾回收器,需要使用-XX:+UseG1GC来启用</p></li></ul><p>jdk1.9产生的新的垃圾回收器。</p><p>G1的特点:</p><ul><li><p>并行与并发</p><ul><li>并行性:G1在回收期间,可以有多个gc线程同时工作,有效利用多核计算能力。此时用户线程STW。</li><li>并发性:G1拥有与应用程序交替执行的能力,部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况。</li></ul></li><li><p>分代收集</p><ul><li>从分代上看,G1依然属于分代型垃圾回收器,它会区分年轻代和老年代,年轻代依然有Eden区和幸存区。但从堆堆结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将堆内存分为若干个区域(region)，这些区域中包含了逻辑上的年轻代和老年代。</li><li>同时兼顾年轻代和老年代。</li></ul></li><li><p>空间整和</p><ul><li>cms:”标记-清楚”算法、内存碎片、若干次GC后进行一次碎片整理</li><li>G1从整体来看是基于标记-整理算法，但从局部上来看是基于复制算法来实现，所以无论如何都不会产生空间碎片。</li></ul></li><li><p>可预测的停顿</p><ul><li>这是G1的一大优势。G1能建立可预测的停顿时间模型,能让使用者明确指定在一个长度为m毫秒的时间片段内,消耗在垃圾收集上的时间不得超过n毫秒。</li><li>G1只所以能建立可预测的停顿模型，就是因为有计划地避免在整个java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小(回收所 获得的空间大小以及回收所需时间的经验值)，在后台维护了一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li></ul><p>G1的缺点:</p><p>相较于cms,G1还不具备全方位、压倒性优势。比如用户线程在运行过程中,G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载,都要比cms要高。</p><p>小内存应用上cms的表现大概率会犹豫g1.</p></li></ul><p>G1的重要参数：</p><ul><li>-XX:+UseG1GC：手动的使用g1收集器执行内存回收任务。</li><li>-XX:G1HeapRegionSize： 设置每个region的大小，值是2的幂，范围是1m到32m之间，目标是根据最小的java的堆大小划分出约2048个区域。</li><li>-XX:MaxGCPauseMillils 设置期望达到最大GC停顿时间指标.默认值是200ms。</li><li>-XX:ParallelGCThread 设置stw工作线程数的值,最多设置为8</li><li>-XX:ConcGCThreads 设置并发标记的线程数,将n设置为并发垃圾回收线程数的1&#x2F;4左右。</li><li>-XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的java堆占用率阈值。</li></ul><p>C1的基本思想：</p><p>G1将java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代代Eden区，幸存去、老年代区等,根据不同的Region采用不同的策略去进行处理。</p><p>Region中还有一类特殊的Humongous区域,专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可绑定为大对象。可以通过参数:-XX:G1HeapRegionSize设定,取值范围为1mb～32mb,且应为2的N次幂。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220729232416628.png" alt="image-20220729232416628"></p><p>G1的核心思想在于:</p><p>有计划的避免在整个java堆中进行全局域的垃圾收集。</p><p>更具体的处理思路是让G1收集器去跟踪各个region里面的垃圾堆积的价值大小,价值即回收所获得的空间大小以及回收所需时间的经验值,然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间，优先处理回收价值收益最大的region.这也就是Garbage frist的由来。</p><p>G1收集器的运作过程大致可划分为一下四个步骤：</p><ul><li>初始标记:仅仅只是标记一下GCRoots能直接关联到的对象,并且修改TAMS(top at mark start：用于记录region并发回收新对象分配区域，其中的对象默认不会被回收)，让下一阶段用户线程并发运行时,能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。</li><li>并发标记：从GCRoots开始对堆中对象进行可达性分析,递归扫描整个堆里的对象图,找出要回收的对象,这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后,还要重新处理SATB(原始快照:并发执行过程中，三色标记可能会出现对象丢失的情况，所以使用原始快照来进行解决，就是将在我们的扫描标记的过程中有可能在并发标记的过程中有可能会删除我们的引用关系，所以需要一个原始快照来记录这些被删除的对象，然后在扫描完成之后，在对这个快照里面的对象进行扫描)记录下的并发时引用变动的对象。</li><li>最终标记:对用户线程做另一个短暂的暂停,用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li><li>筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序,根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集,然后把决定回收的那一部分Region的存活对象复制到空的Region中,在清理掉整个旧Region的全部空间。这里的操作会暂停用户线程。有多条收集器线程并行完成的。</li></ul><p>可以由用户指定的提顿时间时G1收集器很强大的一个功能，设置不同的期望停顿时间,可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。</p><h3 id="实战-内存分配与回收策略"><a href="#实战-内存分配与回收策略" class="headerlink" title="实战:内存分配与回收策略"></a>实战:内存分配与回收策略</h3><p>对象的内存分配，从概念来讲,一应该都是在堆上分配,（也有栈上的）。</p><p>对象大小超过阈值，也有可能直接分配到老年代。</p><p>1、<font color="orange">对象优先分配在Eden区,但Eden区垃圾不足时，会触发minor GC</font></p><p>2、可以通过使用参数-XX:Survior-Ratio&#x3D;8决定新生代中的Eden区与幸存区的比列8:1</p><p>3、长期存活的对象将进入到老年代,虚拟机给每个对象定义了一个对象年龄(age)计数器,存储在对象头中.</p><p>4、对象通常在Eden区里诞生,如果经过第一次Minor GC后仍然存活,并且能够被幸存区容纳的话，该对象会移动到幸存区中,并且将其对象年龄设为1岁。对象在幸存区中每熬过一次GC年龄就加1岁,当它的年龄增加到一定程度,就会被晋升到老年代(15 4bit)。年龄阈值路通过参数-XX:MaxTenuringThreadOld进行设置。</p><h3 id="虚拟机中自带工具的使用"><a href="#虚拟机中自带工具的使用" class="headerlink" title="虚拟机中自带工具的使用"></a>虚拟机中自带工具的使用</h3><h4 id="jps虚拟机进程状态工具"><a href="#jps虚拟机进程状态工具" class="headerlink" title="jps虚拟机进程状态工具"></a>jps虚拟机进程状态工具</h4><p>作用：</p><ul><li>列出正在执行的虚拟机进程,并显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一id。</li></ul><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220731150125688.png" alt="image-20220731150125688"></p><h4 id="jstat-虚拟机统计信息监视工具"><a href="#jstat-虚拟机统计信息监视工具" class="headerlink" title="jstat 虚拟机统计信息监视工具"></a>jstat 虚拟机统计信息监视工具</h4><p>作用:用于监视虚拟机各种运行状态信息的命令工具。可以实现本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。</p><p>命令格式:</p><pre class=" language-bash"><code class="language-bash">jstat <span class="token punctuation">[</span>option vmid<span class="token punctuation">]</span></code></pre><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220731151137516.png" alt="image-20220731151137516"></p><h4 id="jinfo：java配置信息工具"><a href="#jinfo：java配置信息工具" class="headerlink" title="jinfo：java配置信息工具"></a>jinfo：java配置信息工具</h4><p>作用:实时查看和调整虚拟机各项参数。使用jps命令的-v参数可以参考虚拟机启动时显示执行的参数列表,没有显示执行的参数,可以通过jinfo -flag进行查询</p><pre class=" language-java"><code class="language-java">jinfo <span class="token punctuation">[</span>option<span class="token punctuation">]</span> pid</code></pre><h4 id="jmap-：java内存映像工具"><a href="#jmap-：java内存映像工具" class="headerlink" title="jmap ：java内存映像工具"></a>jmap ：java内存映像工具</h4><p>作用：用于生成堆转储快照(一般称为heapdump或dump).还可以查询finalize执行队列、java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。</p><p>jmap命令格式:</p><pre class=" language-java"><code class="language-java">jmap <span class="token punctuation">[</span>option<span class="token punctuation">]</span> vmid</code></pre><p>option选项的合法值与具体含义:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220731153507788.png" alt="image-20220731153507788"></p><h4 id="jhat：虚拟机堆转储快照分析工具"><a href="#jhat：虚拟机堆转储快照分析工具" class="headerlink" title="jhat：虚拟机堆转储快照分析工具"></a>jhat：虚拟机堆转储快照分析工具</h4><p>作用:jhat命令与jmap搭配使用，来分析jmap生成的堆转储快照.</p><pre class=" language-bash"><code class="language-bash">jhat 1.bin</code></pre><h4 id="jstack：java堆栈跟踪工具"><a href="#jstack：java堆栈跟踪工具" class="headerlink" title="jstack：java堆栈跟踪工具"></a>jstack：java堆栈跟踪工具</h4><p>作用:用于生成虚拟机当前时刻的线程快照(一般称为dump文件)。</p><p>线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合,生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致长时间挂起等。</p><p>jstack [OPTION] VMID</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220731160223031.png" alt="image-20220731160223031"></p><p>使用jstack查看线程堆栈信息。</p><pre class=" language-java"><code class="language-java">jstack vmid</code></pre><h3 id="可视化故障处理工具"><a href="#可视化故障处理工具" class="headerlink" title="可视化故障处理工具"></a>可视化故障处理工具</h3><h4 id="jHSDB：基于服务性代理堆调试工具"><a href="#jHSDB：基于服务性代理堆调试工具" class="headerlink" title="jHSDB：基于服务性代理堆调试工具"></a>jHSDB：基于服务性代理堆调试工具</h4><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220731162106875.png" alt="image-20220731162106875"></p><h4 id="jconsole-java监视与管理控制台"><a href="#jconsole-java监视与管理控制台" class="headerlink" title="jconsole: java监视与管理控制台"></a>jconsole: java监视与管理控制台</h4><p>作用:可视化监视、管理工具。通过JMX等MBean对系统进行信息收集和参数动态调整。</p><p>使用jconsole命令打开软件</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220731163755492.png" alt="image-20220731163755492"></p><h4 id="VisualVm：多合一故障处理工具"><a href="#VisualVm：多合一故障处理工具" class="headerlink" title="VisualVm：多合一故障处理工具"></a>VisualVm：多合一故障处理工具</h4><p>作用:运行监视和故障处理程序之一。</p><p>特点:</p><ul><li>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</li><li>监视应用程序的处理器、垃圾收集、堆、方法区以及线程的信息（jstat、jstack）。</li><li>dump以及分析堆转储快照（jmap、jhat）。</li><li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。</li><li>离线程序快照：收集程序的运行时配置、线程dump、内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈。</li></ul><h3 id="垃圾回收调优："><a href="#垃圾回收调优：" class="headerlink" title="垃圾回收调优："></a>垃圾回收调优：</h3><p>1、确定gc垃圾回收器。</p><p>2、使用工具查看一下gc的运行情况，gc比较频繁的区域在那。然后找打问题，然后去解决这个问题。</p><p>3、先去查看一下自身代码是否出现问题，如果出现了一次性查询过多的对象、使用了Map去缓存了太多的数据，也有可能会造成内存溢出。</p><p>4、会尝试去新生代进行调优:</p><ul><li><p>新生代的对象都是根据我们的分带假说来的，也就是所有的新生代的对象都是朝生夕死。</p></li><li><p>所有的new操作所创建的对象都会在新生代中进行分配对象，在TLAB中进行分配，也就是线程本地分配缓存区。为了解决并发创建对象的问题。使用的是隔离的策略来解决并发的问题。 </p></li><li><p>死亡对象的回收代价是零</p></li><li><p>MinorGC的时间远远低于FullGC。 </p></li><li><p>基于这些特点需要对其进行优化的话，可以适当的调整一下堆堆大小。</p></li><li><p>-Xmn堆参数可以设置我们的堆内存大小。</p></li><li><p><font color="red">新生代的大小要适当，如果新生代的内存过小，会导致我们minorGC会很频繁，不断出发minorGc会导致我们的stw，会暂停我们的用户线程，会导致我们的响应时间变长。如果minorGC过大，由会产生的问题，就会不变挤压你的老年代的空间。如果老年代的空间过小，那么就可能会触发我们的FullGC。所以新生代的选择一定要适当。然后我们的jvm给出的建议是在我们的堆空间的25以上，50%一下，可以适当进行调控。</font></p></li><li><p>合适的大小可以容纳所有的并发量*(请求-响应)的数据。</p></li><li><p>老年代的大小能保留(当前活跃对象+需要晋升对象)</p></li></ul><p>5、老年代内存其实也是越大越好的，因为大对象，长时间存活的对象，都会存储在我们的老年代中，如果老年代的内存空间不足，会尝试触发一下minorGC，如果mingc，还不能解决，那么就会触发我们的FullGC。将整个java堆进行回收。jdk1.8采用的是cms垃圾收集器。使用标记-清除算法，会产生的内存碎片。如果内存中出现大量碎片，会导致存放不下大对象，就有可能会触发我们的FullGC。所以记得有一个参数，让我们fullGC之后会执行一次我们整理内存碎片。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例:"></a>案例:</h4><p>1、FullGC和MinorGC频繁。可以去适当的调大一下-xmn新生代的大小。</p><p>2、请求高峰期发生FullGC，单次暂停时间特别长(cms)</p><p>分析:</p><p>1、cms先要去开启的gc日志 -XX:+printGC</p><p>2、去查看一下我们的cms执行过程中，出现了什么问题。</p><p>3、有可能会浪费大量内存的问题，就在于我们的重新标记，不仅需要扫描老年代，还需要去扫描我们的新生代。需要需要打开一个Remark，也就是在cms执行之前，先让我们的minorGC去清理一遍我们的新生代。这样我们的cms扫描的垃圾就会变少了。</p><h3 id="内存溢出的问题"><a href="#内存溢出的问题" class="headerlink" title="内存溢出的问题:"></a>内存溢出的问题:</h3><ul><li>误用线程池导致的内存溢出 newThreadFixedThreadPool默认的是LinkedBlockingQueue的无界的任务队列，会导致我们的内存溢出。</li><li>使用线程池会导致我们的内存溢出。newCache.因为newCache里面最大线程数是integer的最大值。导致生成大量的线程。会导致内存溢出。</li><li>一次查询太多数据</li><li>类太多</li></ul><h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><p>我们都知道java要称一次编译到处运行,那让java程序可以做到这样的就是java的虚拟机已经java的字节码文件.</p><p>类文件的结构分析:</p><pre class=" language-java"><code class="language-java">ClassFile <span class="token punctuation">{</span>    u4             magic<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Class 文件的标志</span>    u2             minor_version<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 的小版本号</span>    u2             major_version<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 的大版本号</span>    u2             constant_pool_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//常量池的数量</span>    cp_info        constant_pool<span class="token punctuation">[</span>constant_pool_count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//常量池</span>    u2             access_flags<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 的访问标记</span>    u2             this_class<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当前类</span>    u2             super_class<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//父类</span>    u2             interfaces_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//接口</span>    u2             interfaces<span class="token punctuation">[</span>interfaces_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一个类可以实现多个接口</span>    u2             fields_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 文件的字段属性</span>    field_info     fields<span class="token punctuation">[</span>fields_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一个类会可以有多个字段</span>    u2             methods_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Class 文件的方法数量</span>    method_info    methods<span class="token punctuation">[</span>methods_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一个类可以有个多个方法</span>    u2             attributes_count<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此类的属性表中的属性数</span>    attribute_info attributes<span class="token punctuation">[</span>attributes_count<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//属性表集合</span><span class="token punctuation">}</span></code></pre><h4 id="魔数（class的文件标志）"><a href="#魔数（class的文件标志）" class="headerlink" title="魔数（class的文件标志）"></a>魔数（class的文件标志）</h4><p>0~3字节,表示它是否是class类型的文件。</p><p>ca fe ba ba这是java选择标识的字符。</p><pre class=" language-java"><code class="language-java"><span class="token number">0000000</span> ca fe ba ba <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">34</span> <span class="token number">00</span> <span class="token number">23</span> 0a <span class="token number">00</span> <span class="token number">06</span> <span class="token number">00</span> <span class="token number">15</span> <span class="token number">09</span></code></pre><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>4～7字节,表示类的版本00 34(52) 表示是java 8</p><pre class=" language-java"><code class="language-java"><span class="token number">0000000</span> ca fe ba ba <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">34</span> <span class="token number">00</span> <span class="token number">23</span> 0a <span class="token number">00</span> <span class="token number">06</span> <span class="token number">00</span> <span class="token number">15</span> <span class="token number">09</span></code></pre><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><pre class=" language-java"><code class="language-java">u2 constant_pool_count <span class="token comment" spellcheck="true">//常量池的数量</span>cp_info constant_pool<span class="token punctuation">[</span>constant_pool_count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//常量池  </span></code></pre><p>常量池的数量是constant_pool_count-1(常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”).</p><p><img src="https://img-blog.csdnimg.cn/cf8144a2e469435fa648133771c37476.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeHVzaGl5dTE5OTY4MTg=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p><p>8~9字节,表示常量池长度,00 23（35）表示常量池有#1～#34项，注意#0项不计入，也没有值</p><pre class=" language-java"><code class="language-java"><span class="token number">0000000</span> ca fe ba ba <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">34</span> <span class="token number">00</span> <span class="token number">23</span> 0a <span class="token number">00</span> <span class="token number">06</span> <span class="token number">00</span> <span class="token number">15</span> <span class="token number">09</span></code></pre><p>第#1项0a表示一个Method信息,00 06和00 15（21）表示它引用了常量池中#6和#21项来获得这个方法的所属类和方法名</p><pre class=" language-java"><code class="language-java"><span class="token number">0000000</span> ca fe ba ba <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">34</span> <span class="token number">00</span> <span class="token number">23</span> 0a <span class="token number">00</span> <span class="token number">06</span> <span class="token number">00</span> <span class="token number">15</span> <span class="token number">09</span></code></pre><p>第#2项09表示一个Field信息，00 16（22）和00 17（23）表示它引用了常量池中#22和#23项来获得这个成员变量的所属类和成员变量名</p><pre class=" language-java"><code class="language-java"><span class="token number">0000000</span> ca fe ba ba <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">34</span> <span class="token number">00</span> <span class="token number">23</span> 0a <span class="token number">00</span> <span class="token number">06</span> <span class="token number">00</span> <span class="token number">15</span> <span class="token number">09</span><span class="token number">0000020</span> <span class="token number">00</span> <span class="token number">16</span> <span class="token number">00</span> <span class="token number">17</span> <span class="token number">08</span> <span class="token number">00</span> <span class="token number">18</span> 0a <span class="token number">00</span> <span class="token number">19</span> <span class="token number">00</span> 1a <span class="token number">07</span> <span class="token number">00</span> 1b <span class="token number">07</span>  </code></pre><h3 id="javap-工具"><a href="#javap-工具" class="headerlink" title="javap: 工具"></a>javap: 工具</h3><p>自己分析类文件结构太麻烦了，java提供了javap工具来反编译class文件</p><pre class=" language-java"><code class="language-java">javap <span class="token operator">-</span>v hello<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token class-name">Classfile</span> <span class="token operator">/</span>Users<span class="token operator">/</span>kevintam<span class="token operator">/</span>project<span class="token operator">/</span>hello<span class="token punctuation">.</span><span class="token keyword">class</span>  <span class="token class-name">Last</span> modified <span class="token number">2022</span><span class="token operator">-</span><span class="token number">7</span><span class="token operator">-</span><span class="token number">31</span><span class="token punctuation">;</span> size <span class="token number">415</span> bytes  MD5 checksum e9060c88e2810b27a9fbb399c4588e18  Compiled from <span class="token string">"hello.java"</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">hello</span>  minor version<span class="token operator">:</span> <span class="token number">0</span>  major version<span class="token operator">:</span> <span class="token number">52</span>  flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_SUPERConstant pool<span class="token operator">:</span>   #<span class="token number">1</span> <span class="token operator">=</span> Methodref          #<span class="token number">6</span><span class="token punctuation">.</span>#<span class="token number">15</span>         <span class="token comment" spellcheck="true">// java/lang/Object."&lt;init>":()V</span>   #<span class="token number">2</span> <span class="token operator">=</span> Fieldref           #<span class="token number">16</span><span class="token punctuation">.</span>#<span class="token number">17</span>        <span class="token comment" spellcheck="true">// java/lang/System.out:Ljava/io/PrintStream;</span>   #<span class="token number">3</span> <span class="token operator">=</span> String             #<span class="token number">18</span>            <span class="token comment" spellcheck="true">// hello world</span>   #<span class="token number">4</span> <span class="token operator">=</span> Methodref          #<span class="token number">19</span><span class="token punctuation">.</span>#<span class="token number">20</span>        <span class="token comment" spellcheck="true">// java/io/PrintStream.println:(Ljava/lang/String;)V</span>   #<span class="token number">5</span> <span class="token operator">=</span> Class              #<span class="token number">21</span>            <span class="token comment" spellcheck="true">// hello</span>   #<span class="token number">6</span> <span class="token operator">=</span> Class              #<span class="token number">22</span>            <span class="token comment" spellcheck="true">// java/lang/Object</span>   #<span class="token number">7</span> <span class="token operator">=</span> Utf8               <span class="token operator">&lt;</span>init<span class="token operator">></span>   #<span class="token number">8</span> <span class="token operator">=</span> <span class="token function">Utf8</span>               <span class="token punctuation">(</span><span class="token punctuation">)</span>V   #<span class="token number">9</span> <span class="token operator">=</span> Utf8               Code  #<span class="token number">10</span> <span class="token operator">=</span> Utf8               LineNumberTable  #<span class="token number">11</span> <span class="token operator">=</span> Utf8               main  #<span class="token number">12</span> <span class="token operator">=</span> <span class="token function">Utf8</span>               <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V  #<span class="token number">13</span> <span class="token operator">=</span> Utf8               SourceFile  #<span class="token number">14</span> <span class="token operator">=</span> Utf8               hello<span class="token punctuation">.</span>java  #<span class="token number">15</span> <span class="token operator">=</span> NameAndType        #<span class="token number">7</span><span class="token operator">:</span>#<span class="token number">8</span>          <span class="token comment" spellcheck="true">// "&lt;init>":()V</span>  #<span class="token number">16</span> <span class="token operator">=</span> Class              #<span class="token number">23</span>            <span class="token comment" spellcheck="true">// java/lang/System</span>  #<span class="token number">17</span> <span class="token operator">=</span> NameAndType        #<span class="token number">24</span><span class="token operator">:</span>#<span class="token number">25</span>        <span class="token comment" spellcheck="true">// out:Ljava/io/PrintStream;</span>  #<span class="token number">18</span> <span class="token operator">=</span> Utf8               hello world  #<span class="token number">19</span> <span class="token operator">=</span> Class              #<span class="token number">26</span>            <span class="token comment" spellcheck="true">// java/io/PrintStream</span>  #<span class="token number">20</span> <span class="token operator">=</span> NameAndType        #<span class="token number">27</span><span class="token operator">:</span>#<span class="token number">28</span>        <span class="token comment" spellcheck="true">// println:(Ljava/lang/String;)V</span>  #<span class="token number">21</span> <span class="token operator">=</span> Utf8               hello  #<span class="token number">22</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>Object  #<span class="token number">23</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>System  #<span class="token number">24</span> <span class="token operator">=</span> Utf8               out  #<span class="token number">25</span> <span class="token operator">=</span> Utf8               Ljava<span class="token operator">/</span>io<span class="token operator">/</span>PrintStream<span class="token punctuation">;</span>  #<span class="token number">26</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>io<span class="token operator">/</span>PrintStream  #<span class="token number">27</span> <span class="token operator">=</span> Utf8               println  #<span class="token number">28</span> <span class="token operator">=</span> <span class="token function">Utf8</span>               <span class="token punctuation">(</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V<span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>V    flags<span class="token operator">:</span> ACC_PUBLIC    Code<span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token number">0</span><span class="token operator">:</span> aload_0         <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Object."&lt;init>":()V</span>         <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>      LineNumberTable<span class="token operator">:</span>        line <span class="token number">1</span><span class="token operator">:</span> <span class="token number">0</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V    flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_STATIC    Code<span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token number">0</span><span class="token operator">:</span> getstatic     #<span class="token number">2</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>         <span class="token number">3</span><span class="token operator">:</span> ldc           #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// String hello world</span>         <span class="token number">5</span><span class="token operator">:</span> invokevirtual #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>         <span class="token number">8</span><span class="token operator">:</span> <span class="token keyword">return</span>      LineNumberTable<span class="token operator">:</span>        line <span class="token number">3</span><span class="token operator">:</span> <span class="token number">0</span>        line <span class="token number">4</span><span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">}</span>SourceFile<span class="token operator">:</span> <span class="token string">"hello.java"</span></code></pre><h3 id="图解的方式执行流程"><a href="#图解的方式执行流程" class="headerlink" title="图解的方式执行流程"></a>图解的方式执行流程</h3><h4 id="1、原始java代码"><a href="#1、原始java代码" class="headerlink" title="1、原始java代码"></a>1、原始java代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo3_1</span><span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> b<span class="token operator">=</span>Short<span class="token punctuation">.</span>Max_VALUE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> c<span class="token operator">=</span>a<span class="token operator">+</span>b<span class="token punctuation">;</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>编译后的字节码文件:</p><pre class=" language-java"><code class="language-java">➜ project javap <span class="token operator">-</span>v  hello<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token class-name">Classfile</span> <span class="token operator">/</span>Users<span class="token operator">/</span>kevintam<span class="token operator">/</span>project<span class="token operator">/</span>hello<span class="token punctuation">.</span><span class="token keyword">class</span>  <span class="token class-name">Last</span> modified <span class="token number">2022</span><span class="token operator">-</span><span class="token number">7</span><span class="token operator">-</span><span class="token number">31</span><span class="token punctuation">;</span> size <span class="token number">428</span> bytes  MD5 checksum dd710a6b03b3dcc1646a2c38aa2f1bc2  Compiled from <span class="token string">"hello.java"</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">hello</span>  minor version<span class="token operator">:</span> <span class="token number">0</span>  major version<span class="token operator">:</span> <span class="token number">52</span>  flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_SUPERConstant pool<span class="token operator">:</span>   #<span class="token number">1</span> <span class="token operator">=</span> Methodref          #<span class="token number">7</span><span class="token punctuation">.</span>#<span class="token number">16</span>         <span class="token comment" spellcheck="true">// java/lang/Object."&lt;init>":()V</span>   #<span class="token number">2</span> <span class="token operator">=</span> Class              #<span class="token number">17</span>            <span class="token comment" spellcheck="true">// java/lang/Short</span>   #<span class="token number">3</span> <span class="token operator">=</span> Integer            <span class="token number">32768</span>   #<span class="token number">4</span> <span class="token operator">=</span> Fieldref           #<span class="token number">18</span><span class="token punctuation">.</span>#<span class="token number">19</span>        <span class="token comment" spellcheck="true">// java/lang/System.out:Ljava/io/PrintStream;</span>   #<span class="token number">5</span> <span class="token operator">=</span> Methodref          #<span class="token number">20</span><span class="token punctuation">.</span>#<span class="token number">21</span>        <span class="token comment" spellcheck="true">// java/io/PrintStream.println:(I)V</span>   #<span class="token number">6</span> <span class="token operator">=</span> Class              #<span class="token number">22</span>            <span class="token comment" spellcheck="true">// hello</span>   #<span class="token number">7</span> <span class="token operator">=</span> Class              #<span class="token number">23</span>            <span class="token comment" spellcheck="true">// java/lang/Object</span>   #<span class="token number">8</span> <span class="token operator">=</span> Utf8               <span class="token operator">&lt;</span>init<span class="token operator">></span>   #<span class="token number">9</span> <span class="token operator">=</span> <span class="token function">Utf8</span>               <span class="token punctuation">(</span><span class="token punctuation">)</span>V  #<span class="token number">10</span> <span class="token operator">=</span> Utf8               Code  #<span class="token number">11</span> <span class="token operator">=</span> Utf8               LineNumberTable  #<span class="token number">12</span> <span class="token operator">=</span> Utf8               main  #<span class="token number">13</span> <span class="token operator">=</span> <span class="token function">Utf8</span>               <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V  #<span class="token number">14</span> <span class="token operator">=</span> Utf8               SourceFile  #<span class="token number">15</span> <span class="token operator">=</span> Utf8               hello<span class="token punctuation">.</span>java  #<span class="token number">16</span> <span class="token operator">=</span> NameAndType        #<span class="token number">8</span><span class="token operator">:</span>#<span class="token number">9</span>          <span class="token comment" spellcheck="true">// "&lt;init>":()V</span>  #<span class="token number">17</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>Short  #<span class="token number">18</span> <span class="token operator">=</span> Class              #<span class="token number">24</span>            <span class="token comment" spellcheck="true">// java/lang/System</span>  #<span class="token number">19</span> <span class="token operator">=</span> NameAndType        #<span class="token number">25</span><span class="token operator">:</span>#<span class="token number">26</span>        <span class="token comment" spellcheck="true">// out:Ljava/io/PrintStream;</span>  #<span class="token number">20</span> <span class="token operator">=</span> Class              #<span class="token number">27</span>            <span class="token comment" spellcheck="true">// java/io/PrintStream</span>  #<span class="token number">21</span> <span class="token operator">=</span> NameAndType        #<span class="token number">28</span><span class="token operator">:</span>#<span class="token number">29</span>        <span class="token comment" spellcheck="true">// println:(I)V</span>  #<span class="token number">22</span> <span class="token operator">=</span> Utf8               hello  #<span class="token number">23</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>Object  #<span class="token number">24</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>lang<span class="token operator">/</span>System  #<span class="token number">25</span> <span class="token operator">=</span> Utf8               out  #<span class="token number">26</span> <span class="token operator">=</span> Utf8               Ljava<span class="token operator">/</span>io<span class="token operator">/</span>PrintStream<span class="token punctuation">;</span>  #<span class="token number">27</span> <span class="token operator">=</span> Utf8               java<span class="token operator">/</span>io<span class="token operator">/</span>PrintStream  #<span class="token number">28</span> <span class="token operator">=</span> Utf8               println  #<span class="token number">29</span> <span class="token operator">=</span> <span class="token function">Utf8</span>               <span class="token punctuation">(</span>I<span class="token punctuation">)</span>V<span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>V    flags<span class="token operator">:</span> ACC_PUBLIC    Code<span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token number">0</span><span class="token operator">:</span> aload_0         <span class="token number">1</span><span class="token operator">:</span> invokespecial #<span class="token number">1</span>                  <span class="token comment" spellcheck="true">// Method java/lang/Object."&lt;init>":()V</span>         <span class="token number">4</span><span class="token operator">:</span> <span class="token keyword">return</span>      LineNumberTable<span class="token operator">:</span>        line <span class="token number">1</span><span class="token operator">:</span> <span class="token number">0</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    descriptor<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">[</span>Ljava<span class="token operator">/</span>lang<span class="token operator">/</span>String<span class="token punctuation">;</span><span class="token punctuation">)</span>V    flags<span class="token operator">:</span> ACC_PUBLIC<span class="token punctuation">,</span> ACC_STATIC    Code<span class="token operator">:</span>      stack<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> locals<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> args_size<span class="token operator">=</span><span class="token number">1</span>         <span class="token number">0</span><span class="token operator">:</span> bipush        <span class="token number">10</span>         <span class="token number">2</span><span class="token operator">:</span> istore_1         <span class="token number">3</span><span class="token operator">:</span> ldc           #<span class="token number">3</span>                  <span class="token comment" spellcheck="true">// int 32768</span>         <span class="token number">5</span><span class="token operator">:</span> istore_2         <span class="token number">6</span><span class="token operator">:</span> iload_1         <span class="token number">7</span><span class="token operator">:</span> iload_2         <span class="token number">8</span><span class="token operator">:</span> iadd         <span class="token number">9</span><span class="token operator">:</span> istore_3        <span class="token number">10</span><span class="token operator">:</span> getstatic     #<span class="token number">4</span>                  <span class="token comment" spellcheck="true">// Field java/lang/System.out:Ljava/io/PrintStream;</span>        <span class="token number">13</span><span class="token operator">:</span> iload_3        <span class="token number">14</span><span class="token operator">:</span> invokevirtual #<span class="token number">5</span>                  <span class="token comment" spellcheck="true">// Method java/io/PrintStream.println:(I)V</span>        <span class="token number">17</span><span class="token operator">:</span> <span class="token keyword">return</span>      LineNumberTable<span class="token operator">:</span>        line <span class="token number">3</span><span class="token operator">:</span> <span class="token number">0</span>        line <span class="token number">4</span><span class="token operator">:</span> <span class="token number">3</span>        line <span class="token number">5</span><span class="token operator">:</span> <span class="token number">6</span>        line <span class="token number">6</span><span class="token operator">:</span> <span class="token number">10</span>        line <span class="token number">7</span><span class="token operator">:</span> <span class="token number">17</span><span class="token punctuation">}</span>SourceFile<span class="token operator">:</span> <span class="token string">"hello.java"</span></code></pre><h4 id="3、常量池载入运行时常量池"><a href="#3、常量池载入运行时常量池" class="headerlink" title="3、常量池载入运行时常量池"></a>3、常量池载入运行时常量池</h4><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220731234931576.png" alt="image-20220731234931576"></p><p>运行时常量池是方法区里的一部分。</p><h4 id="4、方法字节码载入方法区"><a href="#4、方法字节码载入方法区" class="headerlink" title="4、方法字节码载入方法区"></a>4、方法字节码载入方法区</h4><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220731235538783.png" alt="image-20220731235538783"></p><h4 id="5、main线程开始运行，分配栈帧内存"><a href="#5、main线程开始运行，分配栈帧内存" class="headerlink" title="5、main线程开始运行，分配栈帧内存"></a>5、main线程开始运行，分配栈帧内存</h4><p>locals:最大操作数 所以分配了四个槽位,存储局部变量。stack:最大深度为2，操作数栈的多少,用于存储数据和字节码指令。由我们的执行引擎去一行一行的去读取方法区里面的执行指令。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220731235711973.png" alt="image-20220731235711973"></p><h4 id="6、执行引擎开始执行字节码"><a href="#6、执行引擎开始执行字节码" class="headerlink" title="6、执行引擎开始执行字节码"></a>6、执行引擎开始执行字节码</h4><p>bipush        10</p><ul><li>将一个byte压入操作数栈(其长度会补齐4个字节)，类似的指令还有</li><li>sipush将一个short压入操作数栈(其长度会补齐4个字节)</li><li>idc将一个int压入操作数栈</li><li>Idc2_w将一个long压入操作数栈(分两次压入，因为long是8个字节)</li><li>这里小的数字都是和字节码指令存在一起,超过short范围的数字存入了常量池</li></ul><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801001453677.png" alt="image-20220801001453677"></p><p>Istore_1</p><ul><li>将操作数栈顶数据弹出，存入局部变量表的slot 1</li></ul><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801002224424.png" alt="image-20220801002224424"></p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801002338148.png" alt="image-20220801002338148"></p><p>idc #3 接下来应该是给b变量赋值</p><ul><li>从常量池加载#3数据到操作数栈</li><li>注意Short.MAX_VALUE是32767,所以32768&#x3D;Short.MAX_VALUE+1实际是在编译期间计算好的</li></ul><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801002630959.png" alt="image-20220801002630959"></p><p>Istore_2</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801002829273.png" alt="image-20220801002829273"></p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801002916708.png" alt="image-20220801002916708"></p><p>完成a、b的赋值,现在要执行的就是a+b的操作。</p><p>iload1：将局部变量1糟位的值读取到数栈中。iload2，是将2多值读到数栈中</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801003201107.png" alt="image-20220801003201107"></p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801003222104.png" alt="image-20220801003222104"></p><p>使用iadd执行来做a+b的操作</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801003314123.png" alt="image-20220801003314123"></p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801003346714.png" alt="image-20220801003346714"></p><p>istore 3将数栈中的值取出来放到槽位3中</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801003447008.png" alt="image-20220801003447008"></p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801003700806.png" alt="image-20220801003700806"></p><p>getstatic #41 去常量池去找成员变量</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801003818310.png" alt="image-20220801003818310"></p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801003839468.png" alt="image-20220801003839468"></p><p>iload 3</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801003925851.png" alt="image-20220801003925851"></p><p>ivokevirtual #5</p><ul><li>找到常量池 #5</li><li>定位到方法区 java&#x2F;io&#x2F;PrintStram.println:(I)v方法</li><li>生成新的栈帧(分配locals、stack等)</li><li>传递参数,执行新栈帧中的字节码</li></ul><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801004146878.png" alt="image-20220801004146878"></p><ul><li>执行完毕，弹出栈帧</li><li>清除main操作数栈内容</li></ul><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801004316155.png" alt="image-20220801004316155">最后进行return操作</p><ul><li>完成main方法调用，弹出main栈帧</li><li>程序结束</li></ul><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul><li>将类的字节码载入方法区中,内部采用c++的instanKlass描述java类,它的重要field有:<ul><li>_java_mirrot即java的类镜像,例如对String来说,就是String.class，作用是把klass暴露给java使用</li><li>_super即父类</li><li>_fields即成员变量</li><li>_methods即方法</li><li>_constants即常量池</li><li>_class_loader即类加载器</li><li>_vtable虚方法表</li><li>_itable接口方法表</li></ul></li><li>如果这个类还有父类没有加载，先加载父类</li><li>加载和链接可能是交替运行的</li></ul><blockquote><p>注意</p><p>instanceKlass这样的元数据是存储在方法区(1.8后的元空间内),但_java_mirror是存储在堆中</p><p>可以通过前面介绍的HSDB工具查看</p></blockquote><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801131753026.png" alt="image-20220801131753026"></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul><li><p>验证:验证类是否符合jvm规范,安全性检查。</p></li><li><p>准备:为static变量分配空间，设置默认值</p><ul><li>static变量在jdk 7 之前存储与instanceKlass末尾,从JDK7开始，存储与_java_mirror末尾</li><li>static变量分配空间和赋值是两个步骤,分配空间在准备阶段完成,赋值在初始化阶段完成</li><li>如果static变量是final的基本类型，那么编译阶段值就确定了，赋值在准备阶段完成</li><li>如果static变脸是final的，但属于引用类型，那么赋值也会在初始化阶段完成</li></ul></li><li><p>解析:将常量池中的符号引用解析为直接引用</p><ul><li>符号引用就是仅仅只是一个符号，它并不知道这个对象所处的内存地址，</li><li>解析的作用就是将这个符号引用变为直接引用，将这个符号位变成正在的对象的内存地址</li></ul></li></ul><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><clinit>()V方法</p><p>初始化即调用<clinit>()V，虚拟机会保证这个类的构造方法的线程安全</p><h4 id="发生的时机"><a href="#发生的时机" class="headerlink" title="发生的时机"></a>发生的时机</h4><p>概括来说,类初始化是懒惰的</p><ul><li>main方法所在的类,总会被首先初始化</li><li>首次访问这个类的静态变量或静态方法时</li><li>子类初始化，如果父类还没初始化，会引发</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName</li><li>new 会导致初始化</li></ul><p>不会导致类初始化的情况</p><ul><li>访问类的static final静态变量（静本类型和字符串）不会触发初始化</li><li>类对象.class不会触发初始化</li><li>创建该类的数组不会触发初始化</li><li>类加载器的loadClass方法</li><li>Class.forName的参数2位false时</li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>以JDK8为例:</p><table><thead><tr><th>名称</th><th>加载哪都类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader</td><td>JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td><td>上级为bootstrap,显示为null</td></tr><tr><td>Application ClassLoader</td><td>class path</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>使用Bootstrap类加载器加载类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">test1</span> <span class="token punctuation">{</span>   <span class="token keyword">static</span> <span class="token punctuation">{</span>       System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"static test1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">test2</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span>test1<span class="token operator">></span> aClass <span class="token operator">=</span> test1<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拿到是那个类加载器进行加载的</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出</p><pre class=" language-java"><code class="language-java">java <span class="token operator">-</span>Xbootclasspath<span class="token operator">/</span>a<span class="token operator">:</span><span class="token punctuation">.</span> xxxxxxxx</code></pre><ul><li>-Xbootclasspath表示设置bootclasspoah</li><li>其中&#x2F;a:.表示将当前目录追加至bootclasspath之后</li><li>可以用这个办法替换核心类<ul><li>java -Xbootclasspath:<new bootclasspath></li><li>java -Xbootclasspath&#x2F;a:&lt;追加路径&gt;</li><li>java -Xbootclasspath&#x2F;p:&lt;追加路径&gt;</li></ul></li></ul><p>打成jar包的命令：</p><pre class=" language-java"><code class="language-java">jar <span class="token operator">-</span>cvf my<span class="token punctuation">.</span>jar xxxxxx</code></pre><h3 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h3><p>它是类加载器的加载类的一个规则。</p><p>加载流程:</p><p> 一个类加载器查找class和resource时，是通过“委托模式”进行的，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。</p><p>顺序:发现委托是从下向上,然后具体查找过程却是自上至下。</p><p>源码:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span>    <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// First, check if the class has already been loaded</span>        <span class="token comment" spellcheck="true">//1、检查该类是否已经被加载</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> t0 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment" spellcheck="true">//2、有上级的话，委托上级loadClass</span>                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                  <span class="token comment" spellcheck="true">//3、如果没有上级了,则委托BootstrapClassLoader</span>                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>                <span class="token comment" spellcheck="true">//如果找不到类则抛出一个classNotfountExection</span>                <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果仍然没有找到，请按顺序调用findClass方法(每个类加载自己的扩展)来进行加载</span>                <span class="token keyword">long</span> t1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// this is the defining class loader; record the stats</span>                <span class="token comment" spellcheck="true">//记录耗时</span>                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h4><p>我们在使用jdbc时,都需要加载Driver驱动,不知道你注意到没有,不写</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.mysql.jdbc.Driver"</span><span class="token punctuation">)</span></code></pre><p>也是可以让com.mysql.jdbc.Driver正确加载到，你知道原因吗</p><p>让我们追踪一下源码看看:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DriverManager</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//已注册的 JDBC 驱动程序列表</span>      <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> CopyOnWriteArrayList<span class="token operator">&lt;</span>DriverInfo<span class="token operator">></span> registeredDrivers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CopyOnWriteArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/**     * Load the initial JDBC drivers by checking the System property     * jdbc.properties and then use the {@code ServiceLoader} mechanism     */</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token function">loadInitialDrivers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"JDBC DriverManager initialized"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过调用这个DriverManager的classLoader发现这个类是由我们的Bootstrap来进行加载的.</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>DriverManager<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>null</code></pre><p>打印null,表示它的类加载是Bootstrap ClassLoader,会到JAVA_HOME&#x2F;jre&#x2F;lib下搜索类,但这个路径显然是没有mysql的jar包的,这样问题就来了，在DriverManager的静态代码快中,怎么能正确加载com.mysql.jdbc.Driver呢?</p><p>继续看loadInitialDrivers：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loadInitialDrivers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String drivers<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            drivers <span class="token operator">=</span> AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">public</span> String <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> System<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"jdbc.drivers"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            drivers <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// If the driver is packaged as a Service Provider, load it.</span>        <span class="token comment" spellcheck="true">// Get all the drivers through the classloader</span>        <span class="token comment" spellcheck="true">// exposed as a java.sql.Driver.class service.</span>        <span class="token comment" spellcheck="true">// ServiceLoader.load() replaces the sun.misc.Providers()</span>        <span class="token comment" spellcheck="true">//1、使用ServerLoader机制记载驱动,即SPI</span>        AccessController<span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token operator">&lt;</span>Void<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> Void <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ServiceLoader<span class="token operator">&lt;</span>Driver<span class="token operator">></span> loadedDrivers <span class="token operator">=</span> ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>Driver<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Iterator<span class="token operator">&lt;</span>Driver<span class="token operator">></span> driversIterator <span class="token operator">=</span> loadedDrivers<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/* Load these drivers, so that they can be instantiated.                 * It may be the case that the driver class may not be there                 * i.e. there may be a packaged driver with the service class                 * as implementation of java.sql.Driver but the actual class                 * may be missing. In that case a java.util.ServiceConfigurationError                 * will be thrown at runtime by the VM trying to locate                 * and load the service.                 *                 * Adding a try catch block to catch those runtime errors                 * if driver not available in classpath but it's                 * packaged as service and that service is there in classpath.                 */</span>                <span class="token keyword">try</span><span class="token punctuation">{</span>                    <span class="token keyword">while</span><span class="token punctuation">(</span>driversIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        driversIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>Throwable t<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// Do nothing</span>                <span class="token punctuation">}</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"DriverManager.initialize: jdbc.drivers = "</span> <span class="token operator">+</span> drivers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//2、使用jdbc.driver定义的驱动名加载驱动</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>drivers <span class="token operator">==</span> null <span class="token operator">||</span> drivers<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> driversList <span class="token operator">=</span> drivers<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"number of Drivers:"</span> <span class="token operator">+</span> driversList<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String aDriver <span class="token operator">:</span> driversList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"DriverManager.Initialize: loading "</span> <span class="token operator">+</span> aDriver<span class="token punctuation">)</span><span class="token punctuation">;</span>                Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>aDriver<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span>                              <span class="token comment" spellcheck="true">//这个就是使用appClassLoader来进行记载</span>                              <span class="token comment" spellcheck="true">//这里打破了双亲委派机制,因为按照机制来说的，应该是使用BootstrapClassLoader来进行加载，而不是使用appClassLoader来进行记载</span>                        ClassLoader<span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"DriverManager.Initialize: load failed: "</span> <span class="token operator">+</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>有的时候，jdk需要打破这个双亲委派机制,让应用程序加载器来加载类,否者有些类是无法找到的。</p><p>在来看看ServiceLoader机制</p><p>仔细说说这个Service Provider Interface(SPI)是一种服务发现机制。</p><p>它通过在ClassPath路径下的META-INF&#x2F;services文件夹查找文件，自动加载文件里所定义的类。</p><p>约定如下,在jar包的META-INF&#x2F;services包下,以接口全限定名名为文件,文件内容是实现类名称</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801170120400.png" alt="image-20220801170120400"></p><p>这样就可以使用</p><pre class=" language-java"><code class="language-java">ServiceLoader<span class="token operator">&lt;</span>接口类型<span class="token operator">></span> allImpls<span class="token operator">=</span>ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>接口类型<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator<span class="token operator">&lt;</span>接口类型<span class="token operator">></span> iter<span class="token operator">=</span>allImpls<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>来得到实现类，体现的是面向接口编程+解藕的思想,在下面一些框架中都运用了此思想:</p><ul><li>JDBC</li><li>Servlet初始化器</li><li>Spring 容器</li></ul><p>接着看ServiceLoader.load方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span><span class="token operator">&lt;</span>s<span class="token operator">></span> ServiceLoader<span class="token operator">&lt;</span>s<span class="token operator">></span> <span class="token function">load</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>S<span class="token operator">></span> service<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//获取线程上下文类加载器</span>  ClassLoader c1<span class="token operator">=</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//jvm会把我们的应用加载器赋值给它</span>  <span class="token keyword">return</span> ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span>c1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以得知Driver是打破了双亲委派机制的，因为他是使用系统加载器，去委托了应用加载器去进行加载。</p><h4 id="破坏双亲委派机制两种方式"><a href="#破坏双亲委派机制两种方式" class="headerlink" title="破坏双亲委派机制两种方式"></a>破坏双亲委派机制两种方式</h4><p>1、就是使用Driver里面的线程上下文加载器来进行破坏。</p><p>可以通过Thread.currentThread.getClassLoader,可以拿到我们的应用加载器。然后使用它进行加载即可。</p><p>2、通过使用SPI(Service Provide Interface）来进行打破,可以使用ServiceLoader.loader进行加载。</p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>问问自己,什么时候需要自定义类加载器</p><p>1、想加载非classpath、随意路径下中的类文件</p><p>2、都是通过接口来进行实现，希望解耦时,常用在框架设计</p><p>3、这些类希望予以隔离,不同应用的同名类都可以加载，不冲突，常用于tomact容器</p><p>实现步骤:</p><ul><li>继承ClassLoader父类</li><li>要遵从双亲委派机制,重写findClass方法<ul><li>注意不是重写loadClass方法,否则不会走双亲委托机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的defineClass方法来加载类</li><li>使用者调用该类加载器的loadClass方法</li></ul><p>示例:</p><p>自定义的类加载器:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>kevintam<span class="token punctuation">.</span>load<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ByteArrayOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>Files<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span>Paths<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2022/8/1 * 自定义类加载器 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//路径,拿到某个文件的字节码文件</span>        String path<span class="token operator">=</span><span class="token string">"/Users/kevintam/classpath/"</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">".class"</span><span class="token punctuation">;</span>        ByteArrayOutputStream os <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拿到一个输出流</span>            Files<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>Paths<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">,</span>os<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> os<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到字节码文件</span>            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>bytes<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>bytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span><span class="token string">"类文件找不到"</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="运行期优化"><a href="#运行期优化" class="headerlink" title="运行期优化"></a>运行期优化</h2><h3 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>先来个例子:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JIT1</span><span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">200</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">long</span> start<span class="token operator">=</span>System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">long</span> end<span class="token operator">=</span>System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\t%d\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span><span class="token punctuation">(</span>end<span class="token operator">-</span>start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>出现的结果:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220801231753811.png" alt="image-20220801231753811"></p><p>原因是什么呢？</p><p>JVM将执行状态分成了5个层次</p><ul><li>0层,解释执行</li><li>1层，使用c1即时编译器执行(不带profiling)</li><li>2层，使用c1即时编译器编译执行(带基本的profiling)</li><li>3层,使用c1即时编译器编译执行（带完全的profiling）</li><li>4层，使用c2即时编译器编译执行</li></ul><blockquote><p>profiling是指在运行过程中收集一些程序执行状态的数据,例如[方法的调用次数],【循环的回边次数】等</p></blockquote><p>即时编译器(JIT)与解释器等区别</p><ul><li>解释器是将字节码解释为机器码,下次即时遇到相同的字节码,仍会执行重复的解释</li><li>JIT是将一些字节码编译为机器码,并存入Code Cache，下次遇到相同的代码,直接执行,无需再编译</li><li>解释器是将字节码解释为针对所有平台都通用的机器码</li><li>JIT会根据平台类型，生成平台特定的机器码</li></ul><p>对于占据大部分的不常用的代码,我们无需耗费时间将其编译成机器码,而是采取解释执行的方式运行,另一方面，对于仅占据小部分的热点代码,我们则可以将其编译成机器码，以达到理想的运行速度。执行效率上简单比较一下Interpreter&lt;c1&lt;c2,总的目标是发现热点代码(hotspot名称的由来),优化之</p><p>刚才的一种优化手段称之为[逃逸分析],发现新建的对象是否逃逸。可以使用-XX:-DoEscapeAnalvsis关闭。</p><p>逃逸分析:通过逃逸分析后的对象,可将这些对象直接在栈上进行分配,而非堆上。极大的降低了GC次数,从而提升程序整体的执行效率。</p><h4 id="方法内连"><a href="#方法内连" class="headerlink" title="方法内连"></a>方法内连</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">return</span> i<span class="token operator">*</span>i<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>如果发现square是热点方法,并且长度不太长时,会进行内联，所谓的内联就是把方法内代码拷贝、粘贴到调用者的位置:</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token operator">*</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>还能够进行重复折叠的优化</p><pre class=" language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">81</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2021/12/01/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/12/01/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>代理模式是属于我们的结构型模式中的。</p><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下 7 种:</p><ul><li>代理模式</li><li>适配器模式</li><li>装饰者模式</li><li>外观模式</li><li>组合模式</li><li>享元模式</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><p>Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生 成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构:"></a>结构:</h2><p>代理(Proxy)模式分为三种角色:</p><ul><li>抽象主题(Subject类):通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li><li>真实主题(Real Subject)类:实现了抽象主题中的具体业务,是代理对象所代表的真实对象，是最终要引用的对象。</li><li>代理(Proxy)类 : 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访 问、控制或扩展真实主题的功能。</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>我们通过案例来感受一下静态代理。</p><p>【例】火车站卖票</p><p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230329210558234.png" alt="image-20230329210558234"></p><p>代码如下:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//卖票接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SellTickets</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//火车站 火车站具有卖票功能，所以需要实现SellTickets接口 public class TrainStation implements SellTickets {</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"火车站卖票"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//代售点</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyPoint</span> <span class="token keyword">implements</span> <span class="token class-name">SellTickets</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> TrainStation station <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TrainStation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理点收取一些服务费用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> station<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//测试类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ProxyPoint pp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxyPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pp<span class="token punctuation">.</span><span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象 和目标对象的中介。同时也对sell方法进行了增强(代理点收取一些服务费用)。</p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类 Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法 (newProxyInstance方法)来获取代理对象。</p><p>代码如下:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//卖票接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SellTickets</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//火车站 火车站具有卖票功能，所以需要实现SellTickets接口 </span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TrainStation</span> <span class="token keyword">implements</span> <span class="token class-name">SellTickets</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sell</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"火车站卖票"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//代理工厂,用来创建代理对象</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TrainStation trainStation<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ProxyFactory</span><span class="token punctuation">(</span>TrainStation trainStation<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>trainStation <span class="token operator">=</span> trainStation<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> SellTicket <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token punctuation">(</span>SellTicket<span class="token punctuation">)</span> Proxy<span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>ProxyFactory<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>SellTicket<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/**             * @param proxy 代理对象             * @param method 代理的方法             * @param args 其他参数信息             * @return             * @throws Throwable             */</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object proxy<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//去执行了动态代理的方法</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"动态代理实现:收取代理的费用"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Object invoke <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>trainStation<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> invoke<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>jdk的动态代理的实现的步骤:</p><p>1、因为我们的JDK的动态代理是基于我们的接口来进行实现。这个接口就是我们的抽象主题。</p><p>2、代理对象的接口，代理对象的实现类去实现代理对象的接口。这个实现类我们称为真实主题(Real Subject)类</p><p>3、代理类声明一个抽象主题类，然后让用我们的构造器去进行赋值操作.</p><p>4、声明一个getProxyObject方法，然后在里面调用Proxy.newProxyInstance对象，传入三个参数:第一个是类加载器，第二个class数组也就是我们的抽象主题类的接口数组，第三个是InvocationHandler，就是我们的具体增强的代码就是在这里写。</p><h2 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a><strong>CGLIB</strong> 动态代理</h2><p>同样是上面的案例，我们再次使用CGLIB代理实现。</p><p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用 了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p><p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提 供了很好的补充。</p><p>CGLIB是第三方提供的包，所以需要引入jar包的坐标:</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>cglib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>cglib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>代码如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 代理模式<span class="token punctuation">;</span><span class="token keyword">import</span> net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>Enhancer<span class="token punctuation">;</span><span class="token keyword">import</span> net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodInterceptor<span class="token punctuation">;</span><span class="token keyword">import</span> net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>MethodProxy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/14 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CglibProxy</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TrainStation trainStation<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CglibProxy</span><span class="token punctuation">(</span>TrainStation trainStation<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>trainStation <span class="token operator">=</span> trainStation<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> TrainStation <span class="token function">getProxyObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Enhancer enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//cglib是基于我们的继承来实现</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>TrainStation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TrainStation obj <span class="token operator">=</span> <span class="token punctuation">(</span>TrainStation<span class="token punctuation">)</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//代理实现类</span>    <span class="token comment" spellcheck="true">/**     * @param o 代理对象     * @param method 方法     * @param objects 当前对象的参数     * @param methodProxy 代理方法     * @return     * @throws Throwable     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> TrainStation <span class="token function">intercept</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> Method method<span class="token punctuation">,</span> Object<span class="token punctuation">[</span><span class="token punctuation">]</span> objects<span class="token punctuation">,</span> MethodProxy methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"代理点收取一些服务费用(CGLIB动态代理方式)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object invokeSuper <span class="token operator">=</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> objects<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行了方法的参数</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>TrainStation<span class="token punctuation">)</span> invokeSuper<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>实现步骤:</p><p>1、实现MethodInterceptor接口，实现我们的intercept方法。然后在我们的方法做一些具体的增强。</p><p>2、创建一个getProxyObject方法。创建一个Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</p><pre class=" language-java"><code class="language-java">Enhancer enhancer<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置父类的字节码对象</span>enhancer<span class="token punctuation">.</span><span class="token function">setSuperClass</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置回调函数</span>enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建代理对象</span>enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p><strong>三种代理的对比</strong></p><ul><li>jdk代理和CGLIB代理</li></ul><p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在 JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p><p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率 低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代 理，如果没有接口使用CGLIB代理。</p><ul><li>动态代理和静态代理</li></ul><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理(InvocationHandler.invoke)。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2021/10/31/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/10/31/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>又被称为发布-订阅(Publish&#x2F;Subscribe)模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h2><p>在观察者模式中有如下角色:</p><ul><li>Subject:抽象主题(抽象被观察者)，抽象主题角色把所有观察者对象保存在一个集合里，每 个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li><li>ConcreteSubject:具体主题(具体被观察者)，该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li><li>Observer:抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li><li>ConcrereObserver:具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><h2 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a><strong>案例实现</strong></h2><p>【例】微信公众号</p><p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p><p>类图如下:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230331204640613.png" alt="image-20230331204640613"></p><p>代码如下:<br>定义抽象观察者类，里面定义一个更新的方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WeixinUser</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 微信用户名</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">WeixinUser</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"接收到了这个消息:"</span><span class="token operator">+</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>定义抽象主题类，提供了attach、detach、notify三个方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//发布者 抽象主题类 发布信息</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//增加订阅者</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attach</span><span class="token punctuation">(</span>Observer observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//删除订阅者</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">detach</span><span class="token punctuation">(</span>Observer observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通知订阅者更新消息</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>微信公众号是具体主题(具体被观察者)，里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/31 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SubscriptionSubject</span> <span class="token keyword">implements</span> <span class="token class-name">Subject</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//储存订阅公众号的微信用户</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Observer<span class="token operator">></span> weixinUserlist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Observer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">attach</span><span class="token punctuation">(</span>Observer observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        weixinUserlist<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">detach</span><span class="token punctuation">(</span>Observer observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        weixinUserlist<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Observer observer <span class="token operator">:</span> weixinUserlist<span class="token punctuation">)</span> <span class="token punctuation">{</span>            observer<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>测试程序:</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SubscriptionSubject subscriptionSubject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubscriptionSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建微信用户</span>        WeixinUser user1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">WeixinUser</span><span class="token punctuation">(</span><span class="token string">"孙悟空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        WeixinUser user2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">WeixinUser</span><span class="token punctuation">(</span><span class="token string">"猪悟能"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        WeixinUser user3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">WeixinUser</span><span class="token punctuation">(</span><span class="token string">"沙悟净"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//订阅我们的微笑公众号</span>        subscriptionSubject<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        subscriptionSubject<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        subscriptionSubject<span class="token punctuation">.</span><span class="token function">attach</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//更新消息</span>        subscriptionSubject<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token string">"大家好"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>其实是比较像我们的rabbitmq中的广播模式的。就是将我们的消息发送到交换机，然后让我们的交换机以广播的形式转发给所有的绑定在这个交换机的队列中。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h2><p>优点:</p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li></ul><p>缺点:</p><ul><li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li><li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h2><ol><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象.</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li></ol><h2 id="JDK中提供的实现"><a href="#JDK中提供的实现" class="headerlink" title="JDK中提供的实现"></a>JDK中提供的实现</h2><p>在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p><p>1、Observable类</p><p>Observable 类是抽象目标类(被观察者)，它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。</p><ul><li>void addObserver(Observer o) 方法:用于将新的观察者对象添加到集合中。</li><li>void notifyObservers(Object arg) 方法:调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</li><li>void setChange() 方法:用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。</li></ul><p>2、Observer接口</p><p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知， 并调用 update 方法，进行相应的工作。</p><p>【例】警察抓小偷 警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下: 小偷是一个被观察者，所以需要继承Observable类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 观察者模式<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Observable<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/31 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Thief</span> <span class="token keyword">extends</span> <span class="token class-name">Observable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Thief</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">steal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小偷:我偷东西了，有没有人来抓我!!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">setChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//changed = true</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>警察是一个观察者，所以需要让其实现Observer接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 观察者模式<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Observable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Observer<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/31 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Policemen</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Policemen</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Observable o<span class="token punctuation">,</span> Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"警察:"</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>Thief<span class="token punctuation">)</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，我已经盯你很久 了，你可以保持沉默，但你所说的将成为呈堂证供 !!!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>测试代码:</p><pre class=" language-java"><code class="language-java">        Thief thief <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thief</span><span class="token punctuation">(</span><span class="token string">"老王"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Policemen policemen <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Policemen</span><span class="token punctuation">(</span><span class="token string">"张安"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        thief<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>policemen<span class="token punctuation">)</span><span class="token punctuation">;</span>        thief<span class="token punctuation">.</span><span class="token function">steal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用:"></a>实际应用:</h2><blockquote><p>就是我们的用户在进行注册后，我们会发送一封欢迎加入的信息。</p></blockquote><h4 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h4><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230331213742541.png" alt="image-20230331213742541" style="zoom:50%;" /><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>String userName<span class="token punctuation">,</span> String passWord<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1、根据用户名密码保存在数据库</span>        Long userId <span class="token operator">=</span> <span class="token function">saveUser</span><span class="token punctuation">(</span>userName<span class="token punctuation">,</span> passWord<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2、如果上一步有结果则发送一封欢迎邮件</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>userId <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            Mail<span class="token punctuation">.</span><span class="token function">sendEmail</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Long <span class="token function">saveUser</span><span class="token punctuation">(</span>String userName<span class="token punctuation">,</span> String passWord<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> 1L<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面的注册接口实现了两件事，注册和发送邮件，很明显违反了单一职责原则，但假设这个注册需求是不是经常变动的，这样写也没有什么问题，但是假如需求变动，比如不仅要发送邮件，还得发送<a href="https://cloud.tencent.com/product/sms?from=20065&from_column=20065">短信</a>，那还这样写，那register接口会变得很复杂。</p><p>那应该如何简化呢？没错，就是观察者模式。</p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230331214448745.png" alt="image-20230331214448745" style="zoom:50%;" /><h4 id="观察者模式实现"><a href="#观察者模式实现" class="headerlink" title="观察者模式实现"></a>观察者模式实现</h4><p>我们直接套用 JDK 的实现。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 用户登录——被观察者 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserControllerObservable</span> <span class="token keyword">extends</span> <span class="token class-name">Observable</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>String userName<span class="token punctuation">,</span> String passWord<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1、根据用户名密码保存在数据库</span>        Long userId <span class="token operator">=</span> <span class="token function">saveUser</span><span class="token punctuation">(</span>userName<span class="token punctuation">,</span> passWord<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2、如果上一步有结果则通知所有观察者</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>userId <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">setChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span>userName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Long <span class="token function">saveUser</span><span class="token punctuation">(</span>String userName<span class="token punctuation">,</span> String passWord<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> 1L<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Observable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Observer<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 发送邮件——观察者 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MailObserver</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Observable o<span class="token punctuation">,</span> Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送邮件:"</span> <span class="token operator">+</span> arg <span class="token operator">+</span> <span class="token string">"欢迎你"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 发送手机短信——观察者 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SMSObserver</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Observable o<span class="token punctuation">,</span> Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送短信："</span> <span class="token operator">+</span> arg <span class="token operator">+</span> <span class="token string">"欢迎你"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过观察者模式改写后，后面用户注册，就算在增加别的操作，我们也只需要增加一个观察者即可，而注册接口 register 不会有任何改动。</p><h4 id="异步模式优化"><a href="#异步模式优化" class="headerlink" title="异步模式优化"></a>异步模式优化</h4><p>注册之后进行的两步操作：发送邮件和发送短信，上面我们通过观察者模式改写之后，虽然流程很清晰，但是我们发现是顺序执行的，但其实这两步操作没有先后顺序，于是，我们可以改成异步模式，增加执行效率。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 发送邮件——观察者 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MailObserver</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> Executor executor <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Observable o<span class="token punctuation">,</span> Object arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发送邮件:"</span> <span class="token operator">+</span> arg <span class="token operator">+</span> <span class="token string">"欢迎你"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2021/07/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/07/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h3><p>需求:设计一个咖啡店点餐系统。</p><p>设计一个咖啡类(Coffee)，并定义其两个子类(美式咖啡【AmericanCoffee】和拿铁咖啡 【LatteCoffee】);再设计一个咖啡店类(CoffeeStore)，咖啡店具有点咖啡的功能。</p><p>具体类的设计如下:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230322222915518.png" alt="image-20230322222915518"></p><p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。 如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象， 直接在工厂里更换该对象即可，达到了与对象解耦的目的;所以说，工厂模式最大的优点就是:<strong>解耦</strong>。</p><p>在本教程中会介绍三种工厂的使用</p><ul><li>简单工厂模式(不属于GOF的23种经典设计模式) </li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式:"></a>简单工厂模式:</h3><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构:"></a>结构:</h3><p>简单工厂包含如下角色:</p><ul><li>抽象产品:定义了产品的规范，描述了产品的主要特性和功能</li><li>具体产品:实现或者继承了抽象类产品的子类</li><li>具体工厂:提供了创建产品的方法，调用者通过该方法来获取产品。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h3><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230322222915518.png" alt="image-20230322222915518"></p><p>工厂类代码如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleCoffeeFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Coffee <span class="token function">createCoffee</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Coffee coffee <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"americano"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            coffee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmericanoCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"latte"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            coffee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LatteCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> coffee<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>工厂(factory)处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的 orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就 解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和 SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p><p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修 改操作。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><p>优点:</p><p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避<br>免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户<br>代码修改的可能性，更加容易扩展。</p><p>缺点:</p><p>每次添加新的产品时，都需要去我们的工厂类中添加代码，违背了”开背原则”。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a><strong>工厂方法模式</strong></h3><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延</p><p>迟到其工厂的子类。</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a><strong>结构</strong></h3><p>工厂方法模式的主要角色:</p><ul><li>抽象工厂(Abstract Factory):提供了创建产品的接口，调用者通过它访问具体工厂的工厂 方法来创建产品。 </li><li>具体工厂(ConcreteFactory):主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 </li><li>抽象产品(Product):定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品(ConcreteProduct):实现了抽象产品角色所定义的接口，由具体工厂来创建，它同 具体工厂之间一一对应。</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a><strong>实现</strong></h3><p>使用工厂方法模式对上例进行改进，类图如下:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230322223844656.png" alt="image-20230322223844656"></p><p>代码如下: </p><p>抽象工厂:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">{</span>    Coffee <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>具体工厂:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LatteCoffeeFactory</span> <span class="token keyword">implements</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Coffee <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LatteCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AmericanCoffeeFactory</span> <span class="token keyword">implements</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Coffee <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AmericanCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>咖啡店类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CoffeeStore</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> CoffeeFactory factory<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CoffeeStore</span><span class="token punctuation">(</span>CoffeeFactory factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>factory <span class="token operator">=</span> factory<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Coffee <span class="token function">orderCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Coffee coffee <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coffee<span class="token punctuation">.</span><span class="token function">addMilk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coffee<span class="token punctuation">.</span><span class="token function">addsugar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> coffee<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，<br>这样就解决了简单工厂模式的缺点。<br>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的<br>优点，而且克服了它的缺点。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程;</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，<br>满足开闭原则;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-动态监控进程</title>
      <link href="/2021/06/13/linux-%E5%8A%A8%E6%80%81%E7%9B%91%E6%8E%A7/"/>
      <url>/2021/06/13/linux-%E5%8A%A8%E6%80%81%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>top 与 ps 命令很相似。它们都用来显示正在执行的进程。Top 与 ps 最大的不同之处，在于 top 在执行一段时间可以更新正在运行的的进程。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre class=" language-linux"><code class="language-linux">top [选项]</code></pre><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt="截图"></p><p> 选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d 秒数</td><td>指定top命令每隔几秒进行刷新.默认是3秒</td></tr><tr><td>-i</td><td>使top不显示任何闲置或者僵死进程</td></tr><tr><td>-p</td><td>通过指定监控id来仅仅监控某个进程的状态.</td></tr></tbody></table><p> 交互操作说明：</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以cpu使用率排序,默认就是此项</td></tr><tr><td>M</td><td>以内存的使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>q</td><td>退出操作</td></tr></tbody></table><p>应用实例<br>案例 1.监视特定用户, 比如我们监控 tom 用户</p><pre class=" language-linux"><code class="language-linux">top：输入此命令，按回车键，查看执行的进程。u：然后输入“u”回车，再输入用户名，即可,</code></pre><p>案例 2：终止指定的进程, 比如我们要结束 tom 登录</p><pre class=" language-linux"><code class="language-linux">top：输入此命令，按回车键，查看执行的进程。k：然后输入“k”回车，再输入要结束的进程 ID 号</code></pre><p>案例 3:指定系统状态更新的时间(每隔 10 秒自动更新), 默认是 3 秒</p><pre class=" language-linux"><code class="language-linux">top -d 10</code></pre><h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><p>查看系统网络情况 netstat</p><p>基本语法</p><pre class=" language-linux"><code class="language-linux">netstat [选项]</code></pre><p>选项说明</p><pre class=" language-linux"><code class="language-linux">-an 按一定顺序排列输出-p 显示哪个进程在调用</code></pre><p>应用案例<br>请查看服务名为 sshd 的服务的信息。</p><pre class=" language-linux"><code class="language-linux">netstat -anp | grep sshd</code></pre><h3 id="检测主机连接命令-ping："><a href="#检测主机连接命令-ping：" class="headerlink" title="检测主机连接命令 ping："></a>检测主机连接命令 ping：</h3><p>是一种网络检测工具，它主要是用检测远程主机是否正常，或是两部主机间的网线或网卡故障。<br>如: ping 对方 ip 地址</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-服务管理</title>
      <link href="/2021/06/09/linux-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2021/06/09/linux-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="linux服务管理"><a href="#linux服务管理" class="headerlink" title="linux服务管理"></a>linux服务管理</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍:"></a>介绍:</h4><p>服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysqld , sshd防火墙等)，因此我们又称为守护进程，是 Linux 中非常重要的知识点。</p><h4 id="service-管理指令"><a href="#service-管理指令" class="headerlink" title="service 管理指令"></a>service 管理指令</h4><ol><li>service 服务名 [start | stop | restart | reload | status]</li><li>在 CentOS7.0 后 很多服务不再使用 service ,而是 systemctl</li><li>service 指令管理的服务在 &#x2F;etc&#x2F;init.d 查看</li></ol><h4 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名:"></a>查看服务名:</h4><p><strong>使用 setup -&gt; 系统服务 就可以看到全部。（作用可以在setup中更改开机即启动的服务）</strong></p><h4 id="服务的运行级别-runlevel"><a href="#服务的运行级别-runlevel" class="headerlink" title="服务的运行级别(runlevel):"></a>服务的运行级别(runlevel):</h4><p>Linux 系统有 7 种运行级别(runlevel)：常用的是 级别 3 和 和 5</p><p>Linux 系统有 7 种运行级别(runlevel)：常用的是 级别 3 和 和 5<br>运行级别 0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动<br>运行级别 1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆<br>运行级别 2：多用户状态(没有 NFS)，不支持网络<br>运行级别 3：完全的多用户状态(有 NFS)，无界面，登陆后进入控制台命令行模式<br>运行级别 4：系统未使用，保留<br>运行级别 5：X11 控制台，登陆后进入图形 GUI 模式<br>运行级别 6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动</p><h4 id="CentOS7-后运行级别说明"><a href="#CentOS7-后运行级别说明" class="headerlink" title="CentOS7 后运行级别说明"></a>CentOS7 后运行级别说明</h4><p>在 &#x2F;etc&#x2F;initab进行了简化 ，如下:</p><pre class=" language-linux"><code class="language-linux">multi-user.target: analogous to runlevel 3graphical.target: analogous to runlevel 5#查看当前级别systemctl get-default#修改运行级别systemctl set-default TARGET.target</code></pre><h4 id="chkconfig-指令"><a href="#chkconfig-指令" class="headerlink" title="chkconfig 指令"></a>chkconfig 指令</h4><p>通过 chkconfig 命令可以给服务的各个运行级别设置自 启动&#x2F;关闭chkconfig 指令管理的服务在 &#x2F;etc&#x2F;init.d 查看<br>注意: Centos7.0 后，很多服务使用 systemctl 管理.</p><p>chkconfig 基本语法</p><pre class=" language-linux"><code class="language-linux">查看服务 chkconfig --list [| grep xxx]chkconfig 服务名 --listchkconfig --level 5 服务名 on/off</code></pre><p>案例演示 : 对 network 服务 进行各种操作, 把 network 在 3 运行级别,关闭自启动</p><pre class=" language-linux"><code class="language-linux">chkconfig --level 3 network offchkconfig --level 3 network on</code></pre><p>使用细节<br>chkconfig 重新设置服务后自启动或关闭，需要重启机器 reboot 生效.</p><h4 id="systemctl-管理指令-重点"><a href="#systemctl-管理指令-重点" class="headerlink" title="systemctl 管理指令(重点)"></a>systemctl 管理指令(重点)</h4><p>基本语法：</p><pre class=" language-linux"><code class="language-linux">systemctl [start | stop | restart | status] 服务名systemctl 指令管理的服务在 /usr/lib/systemd/system 查看</code></pre><p> systemctl 设置服务的自启动状态</p><pre class=" language-bash"><code class="language-bash">systemctl list-unit-files <span class="token punctuation">[</span> <span class="token operator">|</span> <span class="token function">grep</span> 服务名<span class="token punctuation">]</span> <span class="token punctuation">(</span>查看服务开机启动状态, <span class="token function">grep</span> 可以进行过滤<span class="token punctuation">)</span>systemctl <span class="token function">enable</span> 服务名 <span class="token punctuation">(</span>设置服务开机启动<span class="token punctuation">)</span>systemctl disable 服务名 <span class="token punctuation">(</span>关闭服务开机启动<span class="token punctuation">)</span>systemctl is-enabled 服务名 <span class="token punctuation">(</span>查询某个服务是否是自启动的<span class="token punctuation">)</span></code></pre><p>应用案列:</p><p>查看当前防火墙的状况，关闭防火墙和重启防火墙。&#x3D;&gt; firewalld.service<br>systemctl status firewalld; systemctl stop firewalld; systemctl start firewalld</p><h4 id="打开或者关闭指定端口-重点"><a href="#打开或者关闭指定端口-重点" class="headerlink" title="打开或者关闭指定端口(重点)"></a>打开或者关闭指定端口(重点)</h4><p>   在真正的生产环境，往往需要将防火墙打开，但问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。比如 80、22、8080 等，这个又怎么做呢？</p><p>示意图:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/mall/service.png" alt="截图"></p><p> <strong>firewall 指令:</strong></p><ol><li>打开端口: firewall-cmd –permanent –add-port&#x3D;端口号&#x2F;协议</li><li>关闭端口: firewall-cmd –permanent –remove-port&#x3D;端口号&#x2F;协议</li><li>重新载入,才能生效 : firewall-cmd –reload</li><li>查询端口是否开放: firewall-cmd –query-port&#x3D;端口&#x2F;协议</li></ol><p>应用案例：</p><ol><li>启用防火墙， 测试 111 端口是否能 telnet , 不行</li><li>开放 111 端口</li></ol><pre class=" language-linux"><code class="language-linux">firewall-cmd --permanent --add-port=111/tcp ; 需要 firewall-cmd --reload</code></pre><ol start="3"><li>再次关闭 111 端口</li></ol><pre class=" language-linux"><code class="language-linux">firewall-cmd --permanent --remove-port=111/tcp ; 需要 firewall-cmd --reload</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas</title>
      <link href="/2021/05/14/Arthas/"/>
      <url>/2021/05/14/Arthas/</url>
      
        <content type="html"><![CDATA[<h1 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h1><p>当我们系统遇到JVM或者内存溢出等问题的时候，如何对我们的程序进行有效的监控和排查，就发现了几个比较常用的工具，比如JDK自带的 jconsole、jvisualvm还有一个最好用的工具——jprofiler，但是这个是收费的，或者除了很有钱的公司，一般很少人会用这个。</p><p>因为这个工具都是具有图像界面。所有会存在一个缺点,都必须在服务器项目进程中配置相关的监控参数。然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上的环境的网络是隔离的，本地的监控工具根据连不上线上环境。并且JproFile这样的商业工具，是需要付费的。</p><p>那么有没有一款工具不需要远程连接，也不需要配置监控参数，同时也提供了丰富的性能监控工具。就是我们的Arthas。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><p>Arthas 是Alibaba开源的Java诊断工具，采用命令行交互模式，提供了较为丰富的功能，主要还是他是免费里面的算是好用且功能比较强大的一个JVM排查的插件，在了解这个利器之后，发现还是挺好用的，而且支持的功能也比较全面，那么Arthas到底可以为我们做哪些事情呢？</p><ol><li>提供性能看板，包括线程、cpu、内存等信息，并且会定时的刷新。</li><li>根据各种条件查看线程快照。找出cpu占用率最高的n个线程</li><li>输出jvm的各种信息，如gc算法、jdk版本、ClassPath等</li><li>遇到问题无法在线上 debug，热部署加日志直接替换</li><li>查看某个类的静态属性，也可以通过ognl语法执行一些语句</li><li>查看已加载的类的详细信息，这个类从哪个jar包加载的，查看类的方法的信息</li><li>dump 类的字节码到指定目录</li><li>直接反编译指定的类</li><li>快速定位应用的热点，生成火焰图</li><li>可以监控到JVM的实时运行状态</li></ol><p>以前，你碰到这些问题，解决的办法大多是，修改代码，重新上线。但是在大公司里，上线的流程是非常繁琐的，如果为了多加一行日志而重新发布版本，无疑是非常折腾人的。但是阿里巴巴开源的Arthas有了更为优雅的线上调试方法。</p><p>Arthas 支持JDK6，同时可以在 <code>Linux/Mac/Windows</code>上运行，自动Tab 补全功能，更方便我们定位问题和诊断</p><p>下载地址：<a href="https://arthas.gitee.io/download.html">https://arthas.gitee.io/download.html</a><br>你可以下载zip的包我下载的是arthas-packaging-3.5.0-bin.zip<br>或者通过命令去下载</p><pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> https://alibaba.github.io/arthas/arthas-boot.jar</code></pre><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>当我们下载好之后，我们直接通过命令启动就可以<code>java -jar arthas-boot.jar</code>，但是在此之前我们需要通过检测的代码来挂靠到Arthas上面</p><p>1、启动一个java程序:</p><pre class=" language-bash"><code class="language-bash">curl -O https://arthas.aliyun.com/math-game.jarjava -jar math-game.jar</code></pre><p>2、启动arthas</p><p>在命令行下面执行:</p><pre class=" language-bash"><code class="language-bash">curl -O https://arthas.aliyun.com/arthas-boot.jarjava -jar arthas-boot.jar</code></pre><ul><li>执行该程序的用户需要和目标进程具有相同的权限。比如以<code>admin</code>用户来执行：<code>sudo su admin &amp;&amp; java -jar arthas-boot.jar</code> 或 <code>sudo -u admin -EH java -jar arthas-boot.jar</code>。</li><li>如果 attach 不上目标进程，可以查看<code>~/logs/arthas/</code> 目录下的日志。</li><li>如果下载速度比较慢，可以使用 aliyun 的镜像：<code>java -jar arthas-boot.jar --repo-mirror aliyun --use-http</code></li><li><code>java -jar arthas-boot.jar -h</code> 打印更多参数信息。</li></ul><p>选择应用 java 进程：</p><pre class=" language-java"><code class="language-java">$ $ java <span class="token operator">-</span>jar arthas<span class="token operator">-</span>boot<span class="token punctuation">.</span>jar<span class="token operator">*</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token number">35542</span>  <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token number">71560</span> math<span class="token operator">-</span>game<span class="token punctuation">.</span>jar</code></pre><p><code>math-game</code>进程是第 2 个，则输入 2，再输入<code>回车/enter</code>。Arthas 会 attach 到目标进程上，并输出日志：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> Try to attach process 71560<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> Attach process 71560 success.<span class="token punctuation">[</span>INFO<span class="token punctuation">]</span> arthas-client connect 127.0.0.1 3658  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---. /  O  \ <span class="token operator">|</span>  .--. <span class="token string">''</span>--.  .--<span class="token string">'|  '</span>--<span class="token string">'  | /  O  \ '</span>   .-<span class="token string">'|  .-.  ||  '</span>--<span class="token string">'.'</span>   <span class="token operator">|</span>  <span class="token operator">|</span>   <span class="token operator">|</span>  .--.  <span class="token operator">||</span>  .-.  <span class="token operator">|</span><span class="token variable"><span class="token variable">`</span><span class="token keyword">.</span>  <span class="token variable">`</span></span>-.<span class="token operator">|</span>  <span class="token operator">|</span> <span class="token operator">|</span>  <span class="token operator">||</span>  <span class="token operator">|</span>\  \    <span class="token operator">|</span>  <span class="token operator">|</span>   <span class="token operator">|</span>  <span class="token operator">|</span>  <span class="token operator">|</span>  <span class="token operator">||</span>  <span class="token operator">|</span> <span class="token operator">|</span>  <span class="token operator">|</span>.-<span class="token string">'    |`--'</span> `--<span class="token string">'`--'</span> <span class="token string">'--'</span>   `--<span class="token string">'   `--'</span>  `--<span class="token string">'`--'</span> `--<span class="token string">'`-----'</span>wiki       https://arthas.aliyun.com/doc                                        tutorials  https://arthas.aliyun.com/doc/arthas-tutorials.html                  version    3.6.7                                                                main_class                                                                      pid        1911825                                                              <span class="token function">time</span>       2023-03-29 23:38:43  </code></pre><p>web浏览器的输入:</p><p>ip:8563端口是固定的。</p><p>查看日志: cat ~&#x2F;logs&#x2F;arthas&#x2F;arthas.log</p><p>参看帮助:java -jar arts-boot.jar -h</p><p>推出 quit exit</p><h3 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h3><h4 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令:"></a>基础指令:</h4><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230329234640384.png" alt="image-20230329234640384" style="zoom:50%;" /><h4 id="JVM相关的指令"><a href="#JVM相关的指令" class="headerlink" title="JVM相关的指令:"></a>JVM相关的指令:</h4><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230329235241681.png" alt="image-20230329235241681"></p><h4 id="dashboard参数说明，如果不指定，会实时进行显示。"><a href="#dashboard参数说明，如果不指定，会实时进行显示。" class="headerlink" title="dashboard参数说明，如果不指定，会实时进行显示。"></a>dashboard参数说明，如果不指定，会实时进行显示。</h4><table><thead><tr><th align="right">参数名称</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="right">[i:]</td><td align="left">刷新实时数据的时间间隔 (ms)，默认 5000ms</td></tr><tr><td align="right">[n:]</td><td align="left">刷新实时数据的次数</td></tr></tbody></table><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>arthas@1941640<span class="token punctuation">]</span>$ dashboard -i 1000 -n 4</code></pre><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230330000051836.png" alt="image-20230330000051836"></p><h4 id="Thread：查看当前线程信息，查看线程的堆栈"><a href="#Thread：查看当前线程信息，查看线程的堆栈" class="headerlink" title="Thread：查看当前线程信息，查看线程的堆栈"></a>Thread：查看当前线程信息，查看线程的堆栈</h4><table><thead><tr><th align="right">参数名称</th><th align="left">参数说明</th></tr></thead><tbody><tr><td align="right"><em>id</em></td><td align="left">线程 id</td></tr><tr><td align="right">[n:]</td><td align="left">指定最忙的前 N 个线程并打印堆栈</td></tr><tr><td align="right">[b]</td><td align="left">找出当前阻塞其他线程的线程</td></tr><tr><td align="right">[i <code>&lt;value&gt;</code>]</td><td align="left">指定 cpu 使用率统计的采样间隔，单位为毫秒，默认值为 200</td></tr><tr><td align="right">[–all]</td><td align="left">显示所有匹配的线程</td></tr></tbody></table><p>这里的 cpu 使用率与 linux 命令<code>top -H -p &lt;pid&gt;</code> 的线程<code>%CPU</code>类似，一段采样间隔时间内，当前 JVM 里各个线程的增量 cpu 时间与采样间隔时间的比例。</p><pre class=" language-bash"><code class="language-bash">thread -1 直接使用我们的线程id来进行查看thread -n 列出最忙的几个线程并打印堆栈thread -b 找出当前阻塞其他线程的线程</code></pre><h4 id="sysprop-查看当前JVM的系统属性"><a href="#sysprop-查看当前JVM的系统属性" class="headerlink" title="sysprop:查看当前JVM的系统属性"></a>sysprop:查看当前JVM的系统属性</h4><p>了解一下即可。</p><h4 id="heapdump"><a href="#heapdump" class="headerlink" title="heapdump:"></a>heapdump:</h4><p>dump java heap, 类似 jmap 命令的 heap dump 功能。</p><p>dump 到指定文件</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>arthas@58205<span class="token punctuation">]</span>$ heapdump /tmp/dump.hprofDumping heap to /tmp/dump.hprof<span class="token punctuation">..</span>.Heap dump <span class="token function">file</span> created</code></pre><h3 id="class-x2F-classloader-相关"><a href="#class-x2F-classloader-相关" class="headerlink" title="class&#x2F;classloader 相关"></a>class&#x2F;classloader 相关</h3><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230330001049327.png" alt="image-20230330001049327"></p><h4 id="sc-查看JVM以加载的类信息"><a href="#sc-查看JVM以加载的类信息" class="headerlink" title="sc:查看JVM以加载的类信息"></a>sc:查看JVM以加载的类信息</h4><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>arthas@1941640<span class="token punctuation">]</span>$ sc demo.*demo.MathGameAffect<span class="token punctuation">(</span>row-cnt:1<span class="token punctuation">)</span> cost <span class="token keyword">in</span> 11 ms.</code></pre><h3 id="sm：查看已加载类的方法信息"><a href="#sm：查看已加载类的方法信息" class="headerlink" title="sm：查看已加载类的方法信息"></a>sm：查看已加载类的方法信息</h3><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>arthas@1941640<span class="token punctuation">]</span>$ sm java.lang.Stringjava.lang.String <span class="token operator">&lt;</span>init<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">[</span>BII<span class="token punctuation">)</span>Vjava.lang.String <span class="token operator">&lt;</span>init<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">[</span>BLjava/nio/charset/Charset<span class="token punctuation">;</span><span class="token punctuation">)</span>Vjava.lang.String <span class="token operator">&lt;</span>init<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">[</span>BLjava/lang/String<span class="token punctuation">;</span><span class="token punctuation">)</span>Vjava.lang.String <span class="token operator">&lt;</span>init<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">[</span>BIILjava/nio/charset/Charset<span class="token punctuation">;</span><span class="token punctuation">)</span>Vjava.lang.String <span class="token operator">&lt;</span>init<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">[</span>BIILjava/lang/String<span class="token punctuation">;</span><span class="token punctuation">)</span>V</code></pre><h4 id="jad-反编译指定已加载类的源码"><a href="#jad-反编译指定已加载类的源码" class="headerlink" title="jad:反编译指定已加载类的源码"></a>jad:反编译指定已加载类的源码</h4><p><code>jad</code> 命令将 JVM 中实际运行的 class 的 byte code 反编译成 java 代码，便于你理解业务逻辑；</p><ul><li>在 Arthas Console 上，反编译出来的源码是带语法高亮的，阅读更方便</li><li>当然，反编译出来的 java 代码可能会存在语法错误，但不影响你进行阅读理解</li></ul><h4 id="mc：编译-java文件生成-class。"><a href="#mc：编译-java文件生成-class。" class="headerlink" title="mc：编译.java文件生成.class。"></a>mc：编译<code>.java</code>文件生成<code>.class</code>。</h4><pre class=" language-bash"><code class="language-bash">mc /tmp/Test.java</code></pre><h4 id="redefine：加载外部的-class文件，redefine-jvm-已加载的类。"><a href="#redefine：加载外部的-class文件，redefine-jvm-已加载的类。" class="headerlink" title="redefine：加载外部的.class文件，redefine jvm 已加载的类。"></a>redefine：加载外部的<code>.class</code>文件，redefine jvm 已加载的类。</h4><p>推荐使用retransform</p><pre class=" language-bash"><code class="language-bash">retransform /tmp/Test.class</code></pre><h4 id="classloader：查看classloader的继承树，类加载信息"><a href="#classloader：查看classloader的继承树，类加载信息" class="headerlink" title="classloader：查看classloader的继承树，类加载信息"></a>classloader：查看classloader的继承树，类加载信息</h4><p><code>classloader</code> 命令将 JVM 中所有的 classloader 的信息统计出来，并可以展示继承树，urls 等。</p><p>可以让指定的 classloader 去 getResources，打印出所有查找到的 resources 的 url。对于<code>ResourceNotFoundException</code>比较有用。</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>arthas@1941640<span class="token punctuation">]</span>$ classloader name                                       numberOfInstances  loadedCount                                                                Total        BootstrapClassLoader                       1                  2896         com.taobao.arthas.agent.ArthasClassloader  1                  2467         sun.misc.Launcher<span class="token variable">$ExtClassLoader</span>           1                  64           sun.reflect.DelegatingClassLoader          13                 13           sun.misc.Launcher<span class="token variable">$AppClassLoader</span>           1                  4           Affect<span class="token punctuation">(</span>row-cnt:5<span class="token punctuation">)</span> cost <span class="token keyword">in</span> 5 ms.</code></pre><h4 id="monitor-x2F-watch-x2F-trace-相关"><a href="#monitor-x2F-watch-x2F-trace-相关" class="headerlink" title="monitor&#x2F;watch&#x2F;trace 相关"></a>monitor&#x2F;watch&#x2F;trace 相关</h4><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230330001921336.png" alt="image-20230330001921336"></p><h4 id="profiler-x2F-火焰图"><a href="#profiler-x2F-火焰图" class="headerlink" title="profiler&#x2F;火焰图"></a>profiler&#x2F;火焰图</h4><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230330001943611.png" alt="image-20230330001943611"></p><p>官方文档:<a href="https://arthas.gitee.io/doc/profiler.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E">https://arthas.gitee.io/doc/profiler.html#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="/2021/05/14/%E6%B3%A8%E8%A7%A3/"/>
      <url>/2021/05/14/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>注解为我们在代码中添加信息提供一种形式化的方法，我们可以在某个时刻非常方便的使用这些数据。将的通俗一点，就是为这个方法增加的说明或功能。例如：@Overvide这个注解就用来说明这个方式重写父类的。</p><h2 id="2、JDK提供的注解"><a href="#2、JDK提供的注解" class="headerlink" title="2、JDK提供的注解"></a>2、JDK提供的注解</h2><p>Java目前内置了三种注解@Override、@Deprecated、@SuppressWarnnings</p><ul><li>@Override：用于标识方法，标识该方法属于重写父类的方法</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>SOURCE<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Override</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li>@Deprecated：用于标识方法或类，标识该类或方法已过时，建议不要使用</li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token punctuation">{</span>CONSTRUCTOR<span class="token punctuation">,</span> FIELD<span class="token punctuation">,</span> LOCAL_VARIABLE<span class="token punctuation">,</span> METHOD<span class="token punctuation">,</span> PACKAGE<span class="token punctuation">,</span> PARAMETER<span class="token punctuation">,</span> TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Deprecated</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><ul><li>@SuppressWarnnings:用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告</li></ul><pre class=" language-java"><code class="language-java"><span class="token function">Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>TYPE<span class="token punctuation">,</span> FIELD<span class="token punctuation">,</span> METHOD<span class="token punctuation">,</span> PARAMETER<span class="token punctuation">,</span> CONSTRUCTOR<span class="token punctuation">,</span> LOCAL_VARIABLE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>SOURCE<span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SuppressWarnings</span> <span class="token punctuation">{</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="3、元注解"><a href="#3、元注解" class="headerlink" title="3、元注解"></a>3、元注解</h2><p>Java提供了四种元注解，即修饰注解的注解。观察上面源码可以发现三种，即：@Target、@Retention、@Document、@Inherited。主要作用如下：</p><p><img src="https://img-blog.csdn.net/20180621194031710?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hleXJpYW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p><h2 id="4、如何自定义注解"><a href="#4、如何自定义注解" class="headerlink" title="4、如何自定义注解"></a>4、如何自定义注解</h2><p>使用@interface定义注解，会自动继承java.lang.annotation.Annotation接口，类似于类自动继承Object一样。注解中的每个方法表示一个配置参数，返回类型即是参数类型，可以通过default标识参数默认值。定义方式如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * target表示该注解能标注的地方 */</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">CustomAnnotation</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//每一个方法就表示我们的配置参数,返回类型即是参数类型</span><span class="token comment" spellcheck="true">//    可以通过default标识参数默认值</span>    String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"默认值"</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="5、注解中的参数类型"><a href="#5、注解中的参数类型" class="headerlink" title="5、注解中的参数类型"></a>5、注解中的参数类型</h2><p>注解中的参数只支持如下类型：</p><ul><li>所有的基本类型：byte、short、char、int、long、float、double</li><li>String类型</li><li>Class类型</li><li>enum类型</li><li>Annotation类型</li><li>以上类型的数组</li></ul><p>如果定义其他类型的参数编译器会报错。</p><h2 id="6、使用注解的注意点"><a href="#6、使用注解的注意点" class="headerlink" title="6、使用注解的注意点"></a>6、使用注解的注意点</h2><ul><li>如果注解只有一个参数，最好取名value，这样在使用的时候可以直接指定属性值。例如：@Test(“hello”)</li><li>只能使用public和默认权限修饰符修饰参数</li><li>参数默认值：注解参数必须有确定的值。要么在定义的时候给默认值；要么在使用注解的时候指定参数值。</li></ul><h2 id="7、注解处理器"><a href="#7、注解处理器" class="headerlink" title="7、注解处理器"></a>7、注解处理器</h2><p>如果没有读取注解的方法，那么该注解就没有任何意义。使用注解的过程中，注解处理器是必不可少的，Java里反射机制，完成对注解的处理 。</p><h4 id="7-1-注解处理类库"><a href="#7-1-注解处理类库" class="headerlink" title="7.1 注解处理类库:"></a>7.1 注解处理类库:</h4><p>Java通过反射机制获取类、方法、属性上的注解，因此java.lang.reflect提供AnnotationElement支持注解，主要方法如下：</p><ul><li>boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass)：判断该元素是否被annotationClass注解修饰</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//isAnnotationPresent：获取一下该注解是否标注在该类上</span>        <span class="token keyword">boolean</span> present <span class="token operator">=</span> Annotation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>CustomAnnotation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>present<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li><T extends Annotation> T getAnnotation(Class<T> annotationClass)：获取该元素上annotationClass类型的注解，如果没有返回null</li></ul><pre class=" language-java"><code class="language-java">CustomAnnotation annotation <span class="token operator">=</span> AnnotationTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>CustomAnnotation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotation<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>Annotation[] getAnnotations()：返回该元素上所有的注解</li></ul><pre class=" language-java"><code class="language-java">Annotation<span class="token punctuation">[</span><span class="token punctuation">]</span> annotations <span class="token operator">=</span> CustomAnnotation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Annotation annotation <span class="token operator">:</span> annotations<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>annotation<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ul><li><T extends Annotation> T[] getAnnotationsByType(Class<T> annotationClass)：返回该元素上指定类型所有的注解</li></ul><pre class=" language-java"><code class="language-java"> CustomAnnotation<span class="token punctuation">[</span><span class="token punctuation">]</span> annotationsByType <span class="token operator">=</span> AnnotationTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getAnnotationsByType</span><span class="token punctuation">(</span>CustomAnnotation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>CustomAnnotation customAnnotation <span class="token operator">:</span> annotationsByType<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>customAnnotation<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ul><li>Annotation[] getDeclaredAnnotations()：返回直接修饰该元素的所有注解</li></ul><pre class=" language-java"><code class="language-java">  Annotation<span class="token punctuation">[</span><span class="token punctuation">]</span> declaredAnnotations <span class="token operator">=</span> AnnotationTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredAnnotations</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Annotation declaredAnnotation <span class="token operator">:</span> declaredAnnotations<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>declaredAnnotation<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span></code></pre><ul><li><T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass)：返回直接修饰该元素的所有注解</li></ul><pre class=" language-java"><code class="language-java"> CustomAnnotation<span class="token punctuation">[</span><span class="token punctuation">]</span> declaredAnnotationsByType <span class="token operator">=</span> AnnotationTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredAnnotationsByType</span><span class="token punctuation">(</span>CustomAnnotation<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>CustomAnnotation customAnnotation <span class="token operator">:</span> declaredAnnotationsByType<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>customAnnotation<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解:"></a>自定义注解:</h3><p>通过注解进行赋值和通过注解进行校验。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 性别赋值 * @author zzs */</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Inherited</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">InitSex</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * sex enum     * @author zzs     */</span>    <span class="token keyword">enum</span> SEX_TYPE <span class="token punctuation">{</span>MAN<span class="token punctuation">,</span> WOMAN<span class="token punctuation">}</span>    SEX_TYPE <span class="token function">sex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> SEX_TYPE<span class="token punctuation">.</span>MAN<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>年龄校验:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>kevintam<span class="token punctuation">.</span>study<span class="token punctuation">.</span>annotation<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/27 */</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>FIELD<span class="token punctuation">,</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Inherited</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">ValidateAge</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 最小值     * @return     */</span>    <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">18</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 最大值     * @return     */</span>    <span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">99</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 默认值     * @return     */</span>    <span class="token keyword">int</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>反射实现注解:</p><pre class=" language-java"><code class="language-java"> Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">intiStudent</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 年龄为0，校验为通过情况</span>        <span class="token keyword">boolean</span> checkResult <span class="token operator">=</span> <span class="token function">checkStudent</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printResult</span><span class="token punctuation">(</span>checkResult<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 重新设置年龄，校验通过情况</span>        student<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        checkResult <span class="token operator">=</span> <span class="token function">checkStudent</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printResult</span><span class="token punctuation">(</span>checkResult<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">intiStudent</span><span class="token punctuation">(</span>Student student<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取Student类中所有的属性(getFields无法获得private属性)</span>        Field<span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> Student<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历所有属性</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Field field <span class="token operator">:</span> fields<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果属性上有此注解，则进行赋值操作</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>InitSex<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                InitSex init <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>InitSex<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 设置属性的性别值</span>                field<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>student<span class="token punctuation">,</span> init<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"完成属性值的修改，修改值为:"</span> <span class="token operator">+</span> init<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">checkStudent</span><span class="token punctuation">(</span>Student student<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取Student类中所有的属性(getFields无法获得private属性)</span>        Field<span class="token punctuation">[</span><span class="token punctuation">]</span> fields <span class="token operator">=</span> Student<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历所有属性</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Field field <span class="token operator">:</span> fields<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果属性上有此注解，则进行赋值操作</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span>ValidateAge<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                ValidateAge validateAge <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>ValidateAge<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>age <span class="token operator">&lt;</span> validateAge<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> age <span class="token operator">></span> validateAge<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"年龄值不符合条件"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printResult</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> checkResult<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>checkResult<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"校验通过"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"校验未通过"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程管理</title>
      <link href="/2021/05/14/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2021/05/14/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="进程管理（重点）"><a href="#进程管理（重点）" class="headerlink" title="进程管理（重点）"></a>进程管理（重点）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>在 LINUX 中，每个执行的程序都称为一个进程。每一个进程都分配一个 ID 号(pid,进程号)。&#x3D;&gt;windows &#x3D;&gt; linux</li><li>每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</li><li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。</li></ol><h4 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h4><p>ps 命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数.</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/image-20210514173753530.png" alt="image-20210514173753530"></p><h4 id="ps-详解"><a href="#ps-详解" class="headerlink" title="ps 详解"></a>ps 详解</h4><ol><li>指令：ps –aux|grep xxx ，比如我看看有没有 sshd 服务</li><li>指令说明<ul><li>System V 展示风格</li><li>USER：用户名称</li><li>PID：进程号</li><li>%CPU：进程占用 CPU 的百分比</li><li>%MEM：进程占用物理内存的百分比</li><li>VSZ：进程占用的虚拟内存大小（单位：KB）</li><li>RSS：进程占用的物理内存大小（单位：KB）</li><li>TT：终端名称,缩写 .</li><li>STAT：进程状态，其中 S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</li><li>STARTED：进程的启动时间</li><li>TIME： CPU 时间，即进程使用 CPU 的总时间</li><li>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</li></ul></li></ol><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>要求：以全格式显示当前所有的进程，查看进程的父进程。 查看 sshd 的父进程信息</p><pre class=" language-linux"><code class="language-linux">ps -ef 是以全格式显示当前所有的进程-e 显示所有进程。-f 全格式ps -ef|grep sshdroot       942     1  0 Mar16 ?        00:02:16 /usr/sbin/sshd -Droot     17779   942  0 17:06 ?        00:00:00 sshd: root@pts/1root     27343   942  0 17:56 ?        00:00:00 sshd: root [priv]sshd     27344 27343  0 17:56 ?        00:00:00 sshd: root [net]是 BSD 风格UID：用户 IDPID：进程 IDPPID：父进程 IDC：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高STIME：进程启动的时间TTY：完整的终端名称TIME：CPU 时间CMD：启动进程所用的命令和参数</code></pre><h4 id="终止进程-kill-和-killall"><a href="#终止进程-kill-和-killall" class="headerlink" title="终止进程 kill 和 killall"></a>终止进程 kill 和 killall</h4><blockquote><p>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用 kill 命令来完成此项任务</p></blockquote><p>基本语法:</p><pre class=" language-linux"><code class="language-linux">kill [选项] 进程号（功能描述：通过进程号杀死/终止进程）killall 进程名称（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）</code></pre><p>常用选项:</p><p>-9 :表示强迫进程立即停止</p><p>应用案例:</p><p>案例 1. ：踢掉某个非法登录用户</p><pre class=" language-linux"><code class="language-linux">kill 进程号 , 比如 kill 11421</code></pre><p>案例 2: 终止远程登录服务 sshd, 在适当时候再次重启 sshd 服务</p><pre class=" language-linux"><code class="language-linux">kill sshd 对应的进程号; /bin/systemctl start sshd.service</code></pre><p>案例 3: 终止多个 gedit , 演示 killall gedit</p><pre class=" language-linux"><code class="language-linux">通过进程的名字来终止进程</code></pre><p>案例 4：强制杀掉一个终端, 指令 kill -9 bash 对应的进程号</p><pre class=" language-linux"><code class="language-linux">kill -9 bash</code></pre><h4 id="查看进程树-pstree"><a href="#查看进程树-pstree" class="headerlink" title="查看进程树 pstree"></a>查看进程树 pstree</h4><p>基本语法</p><pre class=" language-linux"><code class="language-linux">pstree [选项] ,可以更加直观的来看进程信息</code></pre><p>常用选项</p><p>-p :显示进程的 PID<br>-u :显示进程的所属用户</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2021/05/08/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/05/08/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><p>先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。</p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230330231602743.png" alt="image-20230330231602743" style="zoom:50%;" /><p>作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea 进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义:"></a><strong>定义:</strong></h3><p>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h2><p>策略模式的主要角色如下:</p><ul><li>抽象策略(Strategy)类:这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略(Concrete Strategy)类:实现了抽象策略定义的接口，提供具体的算法实现或行 为。</li></ul><h2 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a><strong>案例实现</strong></h2><p>例】促销活动</p><p>一家百货公司在定年度的促销活动。针对不同的节日(春节、中秋节、圣诞节)推出不同的促销活动，由促销员将促销活动展示给客户。类图如下:</p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230330231740576.png" alt="image-20230330231740576" style="zoom:50%;" /><p>代码如下:</p><p>抽象策略(Strategy)类:</p><p>定义百货公司所有促销活动的共同接口</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>定义具体策略角色(Concrete Strategy):每个节日具体的促销活动</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StrategyB</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"满200元减50元"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StrategyA</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"买一送一"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>定义环境角色:也就是怎么使用?用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SalesMan</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//持有抽象策略角色的引用 private Strategy strategy;</span>    <span class="token keyword">public</span> <span class="token function">SalesMan</span><span class="token punctuation">(</span>Strategy strategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//向客户展示促销活动</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">salesManShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        strategy<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点:"></a>优缺点:</h2><p>优点:</p><ul><li><p>策略类之间可以自由切换</p><p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p></li><li><p>易于扩展</p><p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原 则“</p></li><li><p>避免使用多重条件选择语句(if else)，充分体现面向对象设计思想。</p></li></ul><p>缺点:</p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h2><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条<br>  件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ul><h2 id="在项目中具体使用细节："><a href="#在项目中具体使用细节：" class="headerlink" title="在项目中具体使用细节："></a>在项目中具体使用细节：</h2><p>在项目中的登录功能中，我们一般项目的登录是具有多种登录方式，比如说手机号验证码登录、账号密码登录、就是我们的微信登录等。所以一般实现的方式就是我们和前端之间约定使用一个字段，来表示你具体使用的那种登录方式，比如说:可以有一个login_type的属性，每次前端提交请求时，将对应的请求方式一起封装到的login_type这个属性中，比如说账号密码的方法我们的login_type就是我们的password模式、比如说我们的微信登录方式，可以使用我们的login_type的wx模式。这样一种实现，我们的后端就知道你请求的是哪一种具体的登录行为。</p><p>我们就可以通过我们的if else。进行判断，然后让它分别去调用不用等登录方式。</p><p>这是我们的一般的设计登录的方式，但是这种方式，如果说我们需要将加一种登录方式，就需要去更改我们的源码。需要加一个if else。这样不经违背我们的开闭原则，而且会让我们的代码的格式不是很美观。</p><p>所以一般我们可以使用策略模式对其进行优化。</p><p>我们可以定义一个抽象策略类，在这个抽象策略类中定义一个executor这样一个方法，进行执行。</p><p>然后让我们的登录方法去实现我们的抽象策略类。我们的登录方式就是我们的具体的策略类。</p><p>然后加上我们的@Service方法，将我们的登录方式注入到我们的ioc容器中。添加上我们的名称。比如说是:passwordService,我们拿到login_type之后，将它的值进行拼接。可以我们就可以拿到对应的service进行执行。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AuthService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 认证方式     * @param authParamsDto 统一请求的类型     * @return     */</span>    <span class="token keyword">public</span> XcUserExt <span class="token function">execute</span><span class="token punctuation">(</span>AuthParamsDto authParamsDto<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">  <span class="token comment" spellcheck="true">//根据我们的请求的类型不同可以有不同的参数</span>        String authType <span class="token operator">=</span> authParamsDto<span class="token punctuation">.</span><span class="token function">getAuthType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AuthService authService <span class="token operator">=</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>authType <span class="token operator">+</span> <span class="token string">"_authService"</span><span class="token punctuation">,</span> AuthService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//完成认证</span>        XcUserExt execute <span class="token operator">=</span> authService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>authParamsDto<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell脚本</title>
      <link href="/2021/04/28/shell%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/04/28/shell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h3 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h3><p>Shell是一个命令行解释器,它为用户提供了一个向linux内核发送请求以便运行程序的界面系统级程序,</p><p>用户可以用shell来启动、挂机、停止甚至是编写一些程序.</p><h4 id="Shell-脚本的执行方式"><a href="#Shell-脚本的执行方式" class="headerlink" title="Shell 脚本的执行方式"></a>Shell 脚本的执行方式</h4><h5 id="脚本的格式要求"><a href="#脚本的格式要求" class="headerlink" title="脚本的格式要求"></a>脚本的格式要求</h5><ul><li>脚本以#!&#x2F;bin&#x2F;bash 开头</li><li>脚本需要有可执行权限</li></ul><h4 id="编写一个shell脚本"><a href="#编写一个shell脚本" class="headerlink" title="编写一个shell脚本"></a>编写一个shell脚本</h4><p>需求说明：创建一个 Shell 脚本，输出 hello world!</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashecho "hello world ~~~" #在控制台打印出hello world~~~</code></pre><p>将其hello.sh文件的权限增加可运行的权限(第一种执行)</p><pre class=" language-shell"><code class="language-shell">chmod u+x hello.sh#运行./hello.sh #相对路径 也可以采用绝对路径</code></pre><p>(第二种执行)执行用shell命令来执行</p><pre class=" language-shell"><code class="language-shell">sh hello.sh[root@VM-0-17-centos shell]# sh hello.shhello world ~~~</code></pre><h3 id="Shell-的变量"><a href="#Shell-的变量" class="headerlink" title="Shell 的变量"></a>Shell 的变量</h3><h4 id="Shell-变量介绍"><a href="#Shell-变量介绍" class="headerlink" title="Shell 变量介绍"></a>Shell 变量介绍</h4><ol><li>Linux Shell 中的变量分为，系统变量和用户自定义变量。</li><li>系统变量：$HOME、$PWD、$SHELL、$USER 等等，比如： echo $HOME 等等..</li><li>显示当前 shell 中所有变量：set</li></ol><h4 id="shell-变量的定义"><a href="#shell-变量的定义" class="headerlink" title="shell 变量的定义"></a>shell 变量的定义</h4><p><strong>基本语法:</strong></p><ol><li>定义变量：变量名&#x3D;值</li><li>撤销变量：unset 变量</li><li>声明静态变量：readonly 变量，注意：不能 unset</li></ol><p><strong>快速入门</strong></p><pre class=" language-shell"><code class="language-shell">#1) 案例 1：定义变量 AA=100#输出加上$ 定义变量不需要加上$echo A=$A#2) 案例 2：撤销变量 Aunset A#3) 案例 3：声明静态的变量 B=2，不能 unsetreadonly B=2#一旦unset 就会报错var.sh: line 12: unset: B: cannot unset: readonly variable</code></pre><h4 id="变量定义的规则"><a href="#变量定义的规则" class="headerlink" title="变量定义的规则"></a>变量定义的规则</h4><ol><li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头。5A&#x3D;200(×)</li><li>等号两侧不能有空格</li><li>变量名称一般习惯为大写， 这是一个规范，我们遵守即可</li></ol><p>将命令的返回值赋给变量</p><ol><li>A&#x3D;<code>&#39;date&#39;</code>反引号，运行里面的命令，并把结果返回给变量 A</li><li>A&#x3D;$(date) 等价于反引号</li></ol><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><ol><li>export 变量名&#x3D;变量值 （功能描述：将 shell 变量输出为环境变量&#x2F;全局变量）</li><li>source 配置文件 （功能描述：让修改后的配置信息立即生效）</li><li>echo $变量名 （功能描述：查询环境变量的值）</li></ol><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><ol><li>在&#x2F;etc&#x2F;profile 文件中定义 TOMCAT_HOME 环境变量</li><li>查看环境变量 TOMCAT_HOME 的值</li><li>在另外一个 shell 程序中使用 TOMCAT_HOME</li><li>注意：在输出 TOMCAT_HOME 环境变量前，需要让其生效</li><li>source &#x2F;etc&#x2F;profile</li></ol><pre class=" language-shell"><code class="language-shell">export TOMECAT_HOME=/opt/tomactsource /etc/profile</code></pre><h3 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><blockquote><p>当我们执行一个 shell 脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量<br>比如 ： .&#x2F;myshell.sh 100 200 , 这个就是一个执行 shell 的命令行，可以在 myshell 脚本中获取到参数信息</p></blockquote><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>$n （功能描述：n 为数字，$0 代表命令本身，$1-$9 代表第一到第九个参数，十以上的参数，十以上的参数需要用<br>大括号包含，如${10}）</p><p>$* （功能描述：这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体）</p><p>$@（功能描述：这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待）</p><p>$#（功能描述：这个变量代表命令行中所有参数的个数）</p><pre class=" language-shell"><code class="language-shell">#!/bin/bashecho "$0 $1 $2"echo "所有的参数 $*"echo "$@"echo "参数的个数 $#"#输出 ./myshell.sh 200 300[root@VM-0-17-centos shell]# ./myshell.sh 200 300./myshell.sh 200 300所有的参数 200 300200 300参数的个数 2</code></pre><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><ol><li>“$((运算式))”或“$[运算式]”或者 expr m + n &#x2F;&#x2F;expression 表达式</li><li>注意 expr 运算符间要有空格, 如果希望将 expr 的结果赋给某个变量，使用 &#96;&#96;</li><li>expr m - n</li><li>expr *, &#x2F;, % 乘，除，取余</li></ol><pre class=" language-shell"><code class="language-shell">#!/bin/bash#案列一:计算(2+3)x4的值#使用第一种表达式RES1=$(((2+3)*4))echo "res1=$RES1"#第二种写法RES2=$[(2+3)*4]echo "第二种写法:RES2=$RES2"#第三种写法TEMP=`expr 2 + 3`echo "temp=$TEMP"#拿到参数并相加SUM=$[$1+$2]echo "SUM=$SUM"</code></pre><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h4><p>基本语法</p><pre class=" language-shell"><code class="language-shell">[ condition ]（注意 condition 前后要有空格）#非空返回 true，可使用$?验证（0 为 true，>1 为 false）应用实例[ hspEdu ] 返回 true[ ] 返回 false[ condition ] && echo OK || echo notok 条件满足，执行后面的语句</code></pre><h4 id="判断语句-1"><a href="#判断语句-1" class="headerlink" title="判断语句"></a>判断语句</h4><pre class=" language-shell"><code class="language-shell">常用判断条件1.= 字符串比较2.两个整数的比较-lt 小于-le 小于等于 little equal-eq 等于-gt 大于-ge 大于等于-ne 不等于3) 按照文件权限进行判断-r 有读的权限-w 有写的权限-x 有执行的权限4) 按照文件类型进行判断-f 文件存在并且是一个常规的文件-e 文件存在-d 文件存在并是一个目录应用实例案例 1："ok"是否等于"ok"判断语句：使用 =案例 2：23 是否大于等于 22判断语句：使用 -ge案例 3：/root/shcode/aaa.txt 目录中的文件是否存在判断语句： 使用 -f#!/bin/bash#案例 1："ok"是否等于"ok"#判断语句：使用 =if [ "ok" = "ok" ]then       echo "equls"fi#案例 2：23 是否大于等于 22#判断语句：使用 -geif [ 23 -ge 22 ]then  echo "大与"fi#案例 3：/root/shcode/aaa.txt 目录中的文件是否存在#判断语句： 使用 -fif [ -f /home/shell/a.txt ]then       echo "存在"fi</code></pre><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if-判断"><a href="#if-判断" class="headerlink" title="if 判断"></a>if 判断</h4><pre class=" language-shell"><code class="language-shell">基本语法if [ 条件判断式 ]then代码fi或者 , 多分支if [ 条件判断式 ]then代码elif [条件判断式]then代码fi注意事项：[ 条件判断式 ]，中括号和条件判断式之间必须有空格</code></pre><p>应用实例 ifCase.sh<br>案例：请编写一个 shell 程序，如果输入的参数，大于等于 60，则输出 “及格了”，如果小于 60,则输出 “不及格”</p><pre class=" language-shell"><code class="language-shell">#!/bin/bash#请编写一个 shell 程序，如果输入的参数，大于等于 60，则输出 "及格了"，如果小于 60,则输出 "不及格"if [ $1 -ge 60 ]then  echo "及格了"elif [ $1 -lt 60 ]then echo "不及格"fi</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p><strong>基本的 while 循环语句：</strong></p><pre class=" language-shell"><code class="language-shell">#!/bin/bashint=1while(($int<=5))do  echo $int  let "int++"done  </code></pre><p>while循环可用于读取键盘信息:</p><pre class=" language-shell"><code class="language-shell">echo '按下<CTRL-D>推出'echo -n '输入你最喜欢的电影'while read FILMdo echo "是的！$FILM是一个好电影"done </code></pre><p>无限循环:</p><pre class=" language-shell"><code class="language-shell">while truedo   commanddone  </code></pre><p>for循环：</p><p>通过下面三个简单的示例认识 for 循环语句最基本的使用，实际上 for 循环语句的功能比下面你看到的示例展现的要大得多。</p><p>输出当前列表中的数据:</p><pre class=" language-shell"><code class="language-shell">for loop in 1 2 3 4 5do echo "the value is:$loop"done </code></pre><p>产生10个随机数:</p><pre class=" language-shell"><code class="language-shell">for i in{0..9}do   echo $RANDOMdone  </code></pre><p>输出1到5</p><p>通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要,下面来看一个例子：</p><h3 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h3><p>不带参数没有返回值的函数</p><pre class=" language-shell"><code class="language-shell">#不带参数没有返回值的函数hello(){  echo "这是我的第一个shell函数"}echo "-----函数开始执行-----"#函数的执行 helloecho "-----函数执行完毕-----"</code></pre><p>输出的结果:</p><pre class=" language-shell"><code class="language-shell">-----函数开始执行-----这是我的第一个shell函数-----函数执行完毕-----</code></pre><p>有返回值的函数:</p><p>输入两个数字之后相加并返回结果：</p><pre class=" language-shell"><code class="language-shell">funWithReturn(){  echo "输入第一个数字:"  read aNum  echo "输入第二个数字:"  read bNum  echo "两个数字分别是$aNum,bNum"  return $(($aNum+$bNum))}funWithReturn#可以用？表示函数的返回结果echo "输入的两个数字之和为$?"</code></pre><p>带有参数:</p><pre class=" language-shell"><code class="language-shell">funWithParam(){  echo "第一个参数为 $1 !"      echo "第二个参数为 $2 !"#      取第10个参数      echo "第十个参数为 $10 !"      echo "第十个参数为 ${10} !"      echo "第十一个参数为 ${11} !"#      取参数的总数      echo "参数总数有 $# 个!"#      拿到所有的参数$*      echo "作为一个字符串输出所有参数 $* !"}funWithParam 1 2 3 4 5 6 7 8 9 34 73</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux组的介绍</title>
      <link href="/2021/04/27/linux%E7%BB%84%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/04/27/linux%E7%BB%84%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="linux组的介绍"><a href="#linux组的介绍" class="headerlink" title="linux组的介绍"></a>linux组的介绍</h3><p>在linux中每个用户必须属于一个组,不能独立于组外。在linux中每个文件有所有组、所在组、其它组的概念</p><ul><li>所有者</li><li>所在组</li><li>其它组</li><li>改变用户所在的组</li></ul><h4 id="文件-x2F-目录-所有者"><a href="#文件-x2F-目录-所有者" class="headerlink" title="文件&#x2F;目录 所有者"></a>文件&#x2F;目录 所有者</h4><p>一般为文件的创建者,谁创建了该文件,就自然的称为该文件的所有者</p><ul><li>查看文件的所有者</li></ul><pre class=" language-code"><code class="language-code">指令:ls -ahl</code></pre><ul><li>修改文件的所有者</li></ul><pre class=" language-code"><code class="language-code">指令:chown用户名 文件名案列:chown root txh</code></pre><h4 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h4><pre class=" language-code"><code class="language-code">groupadd 组名</code></pre><p>应用案例:</p><p>创建一个组名tom</p><pre class=" language-code"><code class="language-code">groupadd tom</code></pre><p>将hello.txt加入到该组之中</p><pre class=" language-code"><code class="language-code">useradd -g tom hello.txt</code></pre><p>修改文件所在组</p><p>基本指令:</p><pre class=" language-code"><code class="language-code">chgrp 组名 文件名</code></pre><h4 id="其它组"><a href="#其它组" class="headerlink" title="其它组"></a>其它组</h4><p>除文件的所有者和所在组的用户外,系统的其它用户都是文件的其它组</p><h4 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h4><p>在添加用户时,可以指定将该用户添加到哪个组中,同样的用root的管理权限可以改变某个用户所在的组。</p><ul><li>改变用户所在组</li></ul><p>usermod -g 新组名 用户名</p><p>usermod -d 目录名 用户名 改变该用户登录的初始目录。</p><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><p>ls -l命令的显示的内容如下:</p><pre class=" language-code"><code class="language-code">[txh@VM-0-17-centos home]$ ls -ltotal 20-rw-r--r--  1 root root    0 Apr 23 23:15 cat.txt-rw-r--r--  1 root root   26 Apr 19 22:33 hello.txtdrwxr-xr-x 11 txh  txh  4096 Apr 26 23:23 hexodrwxr-xr-x  2 root root 4096 Apr 26 19:49 kevintam-rw-r--r--  1 root root  125 Apr 23 23:17 pc.tar.gz-rw-r--r--  1 root root    0 Apr 23 23:16 pig.txtdrwx------ 10 txh  txh  4096 Apr 14 14:13 txh</code></pre><p>drwxr-xr-x 0 -9位说明</p><ol><li>第0位说明文件的类型（d,-,l,c,b）</li></ol><ul><li>l是链接,相当于windows的快捷方式</li><li>d是目录,相当于windows的文件夹</li><li>c是字符设备文件,鼠标,键盘</li><li>b是块设备，比如硬盘</li><li>-表示是个普通文件</li></ul><ol start="2"><li>第1-3位确定所有者（该文件的所有者）拥有该文件的权限</li><li>第4-6位确定所属组（同用户组的）拥有该文件的权限</li><li>第7-9位确定其他用户拥有该文件的权限</li></ol><blockquote><p> rwx作用到文件</p></blockquote><p>[r]代表可读(read):可以读取,查看</p><p>[w]代表可写(write):可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限,才能删除该文件。</p><p>[x]代表可执行(execute):可以被执行</p><blockquote><p> rwx作用到目录</p></blockquote><p>[r]代表可读（read）:可以读取,ls查看目录内容</p><p>[w]代表可写（write）:可以修改,对目录内创建+删除+重命名目录</p><p>[x]代表可执行（execute）:可以进行该目录</p><p><strong>案列分析:</strong></p><pre class=" language-code"><code class="language-code">-rw-r--r--  1 root root    0 Apr 23 23:15 cat.txt-表示是一个普通文件rw- 表示文件拥有者权限是读和写r-- 表示同组的用户对该文件拥有读的权限r-- 其他的用户只有读的权限1  文件:表示是硬链接数 目录:表示子目录数+文件数(第一个root)root 表示文件的所有者(第二个root)root 表示文件的所在组0 文件的大小(字节)Apr 23 23:15 表示最后的修改日期cat.txt 文件名</code></pre><h4 id="修改权限-chmod"><a href="#修改权限-chmod" class="headerlink" title="修改权限-chmod"></a>修改权限-chmod</h4><p>基本说明:</p><p>通过chmod指令,可以修改文件或者目录的权限</p><p>第一种方式:+、-、&#x3D;变更权限</p><p>​     u:所有者 g:所在组 o:其他人 a:所有人(u、g、o的总和)</p><ul><li>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件&#x2F;目录</li><li>chmod o+w 文件&#x2F;目录名</li><li>chmod a-x 文件&#x2F;目录名</li></ul><p><strong>注意:&#x3D;直接赋予 -除去权限 +增加权限</strong></p><p>案列:给cat.txt文件的所有者读写执行的权限,在给是在组读执行权限,给其他组读执行权限</p><pre class=" language-code"><code class="language-code">chmod u=rwx,g=rx,o=rx cat.txt</code></pre><p>给cat.txt文件的所有者除去执行的权限,增加组写的权限</p><pre class=" language-code"><code class="language-code">chmod u-x,g+w cat.txt</code></pre><p>第二种方式:通过数字变更权限</p><p>r&#x3D;4 w&#x3D;2 x&#x3D;1 rwx&#x3D;4+2+1&#x3D;7</p><p>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件目录名</p><p>相当于chmod 751 文件目录名</p><h4 id="修改文件所有者-chown"><a href="#修改文件所有者-chown" class="headerlink" title="修改文件所有者-chown"></a>修改文件所有者-chown</h4><p>chown newowner 文件&#x2F;目录 改变所有者</p><p>chown newowner:newgroup 文件&#x2F;目录 改变所有者和所在组 -R 如果是目录 则使其下所有子文件或目录递归生效</p><p>案例演示:</p><p>请将&#x2F;home&#x2F;cat.txt 文件的所有者修改成txh</p><pre class=" language-code"><code class="language-code">chown txh /home/cat.txt</code></pre><h4 id="修改文件所在组-chgrp"><a href="#修改文件所在组-chgrp" class="headerlink" title="修改文件所在组-chgrp"></a>修改文件所在组-chgrp</h4><p>基本介绍:</p><p>chgrp newgroup 文件&#x2F;目录 改变所在组</p><p>案例演示:</p><p>请将&#x2F;home&#x2F;cat.txt 文件的所在组修改成shaolin（少林）</p><pre class=" language-code"><code class="language-code">chgrp shaolin /home/cat.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="/2021/04/26/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95/"/>
      <url>/2021/04/26/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><h2 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h2><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象 行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式分为:</p><ul><li>模板方法模式</li><li>策略模式</li><li>命令模式</li><li>职责链模式</li><li>状态模式</li><li>观察者模式</li><li>迭代器模式</li><li>访问者模式</li><li>备忘录模式</li><li>解释器模式</li></ul><p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><p>在面向对象程序设计过程中，程序员常常会遇到这种情况:设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p><p>例如，去银行办理业务一般要经过以下4个流程:取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>模板方法(Template Method)模式包含以下主要角色:</p><ul><li><p>抽象类:负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p><ul><li><p>模板方法:定义了算法的骨架，按某种顺序调用其包含的基本方法。</p></li><li><p>基本方法:是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种:</p></li><li><p>抽象方法(Abstract Method) :一个抽象方法由抽象类声明、由其具体子类实现。</p></li><li><p>具体方法(Concrete Method) :一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p></li><li><p>钩子方法(Hook Method) :在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为 boolean类型。</p></li></ul></li><li><p>具体子类(Concrete Class):实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p></li></ul><h2 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现:"></a>案例实现:</h2><p>【例】炒菜</p><p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下:</p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230330223154024.png" alt="image-20230330223154024" style="zoom:50%;" /><p>代码实现:</p><p>定义一个模版方法,就是炒菜的模版方法，里面的放油、热油、放菜、放配料、翻炒等步骤。其中的放油、热油、翻炒等都可以写成基本方法，然后我们的放菜、放配料可以写成我们的抽象方法。然后定义一个模板方法，在里面面定义我们的实现算法的具体步骤。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 模版方法<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/30 */</span><span class="token comment" spellcheck="true">//炒菜的模版方法</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractClass</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//倒油</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pourOil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"倒油"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//第二步:热油是一样的，所以直接实现</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">heatOil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"热油"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//第三步:倒蔬菜是不一样的(一个下包菜，一个是下菜心)</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">pourVegetable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//第四步:倒调味料是不一样</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">pourSauce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//第五步:翻炒是一样的，所以直接实现</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">fry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"炒啊炒啊炒到熟啊"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cookProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">pourOil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">heatOil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pourVegetable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">pourSauce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fry</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>具体子类.继承我们的模版方法:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 模版方法<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/30 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteClass_BaoCai</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractClass</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pourVegetable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"下锅的蔬菜是包菜"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pourSauce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"下锅的酱料是辣椒"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 模版方法<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/30 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteClass_CaiXin</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractClass</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pourVegetable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"下锅的蔬菜是菜心"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pourSauce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"下锅的酱料是蒜蓉"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Client：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 模版方法<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/30 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ConcreteClass_BaoCai concreteClassBaoCai <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteClass_BaoCai</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteClassBaoCai<span class="token punctuation">.</span><span class="token function">cookProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ConcreteClass_CaiXin concreteClassCaiXin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteClass_CaiXin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        concreteClassCaiXin<span class="token punctuation">.</span><span class="token function">cookProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>打印的步骤:</p><pre class=" language-java"><code class="language-java">倒油热油下锅的蔬菜是包菜下锅的酱料是辣椒炒啊炒啊炒到熟啊倒油热油下锅的蔬菜是菜心下锅的酱料是蒜蓉炒啊炒啊炒到熟啊</code></pre><blockquote><p> 注意:为防止恶意操作，一般模板方法都加上 final 关键词。</p></blockquote><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点:"></a>优缺点:</h2><p><strong>优点:</strong></p><p>提高代码复用性</p><ul><li><p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p></li><li><p>实现了反向控制</p><p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并 符合“开闭原则”。</p></li></ul><p>缺点:</p><ul><li><p>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽<br>  象。</p></li><li><p>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</p></li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h2><ul><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2021/04/25/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/04/25/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边 的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插 入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机 充电器(将220v转换为5v的电压)，读卡器等，其实就是使用到了适配器模式。</p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230329214720360.png" alt="image-20230329214720360" style="zoom:50%;" /><p>定义:</p><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的哪些类能一起工作。</p><p>适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构:"></a>结构:</h2><p>适配器模式(Adapter)包含以下主要角色:</p><ul><li>目标接口(Target)：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配器类(Adaptee)类:它是被访问和适配的现存组件库中的组件接口。</li><li>适配器类(Adapter)类:它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a><strong>类适配器模式</strong></h2><p>实现方式:定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><p>例子:读卡器</p><p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。</p><p>类图如下:</p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230329220927477.png" alt="image-20230329220927477" style="zoom:50%;" /><p>定义目标接口:</p><p>SD卡</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//SD卡的接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SDCard</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//读取SD卡方法</span>    String <span class="token function">readSD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//写入SD卡功能</span>    <span class="token keyword">void</span> <span class="token function">writeSD</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>SD卡的实现类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SDCardImpl</span> <span class="token keyword">implements</span> <span class="token class-name">SDCard</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">readSD</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String msg <span class="token operator">=</span> <span class="token string">"sd card read a msg :hello word SD"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> msg<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeSD</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span><span class="token punctuation">{</span>     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sd card write msg : "</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>TF卡的接口:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//TF卡接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">TFCard</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//读取TF卡方法</span>   String <span class="token function">readTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//写入TF卡功能</span>   <span class="token keyword">void</span> <span class="token function">writeTF</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>TF卡的实现类:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//TF卡实现类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TFCardImpl</span> <span class="token keyword">implements</span> <span class="token class-name">TFCard</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">readTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String msg <span class="token operator">=</span><span class="token string">"tf card read msg : hello word tf card"</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> msg<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeTF</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"tf card write a msg : "</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>电脑类:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//电脑类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Computer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">readSD</span><span class="token punctuation">(</span>SDCard sdCard<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>sdCard <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"sd card null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sdCard<span class="token punctuation">.</span><span class="token function">readSD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>定义适配器类(SD兼容TF)</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//定义适配器类(SD兼容TF)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SDAdapterTF</span> <span class="token keyword">extends</span> <span class="token class-name">TFCardImpl</span> <span class="token keyword">implements</span> <span class="token class-name">SDCard</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">readSD</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"adapter read tf card "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">readTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeSD</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"adapter write tf card"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">writeTF</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p><h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a><strong>对象适配器模式</strong></h2><p>实现方式:对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SDAdapterTF</span>  <span class="token keyword">implements</span> <span class="token class-name">SDCard</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> TFCard tfCard<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">SDAdapterTF</span><span class="token punctuation">(</span>TFCard tfCard<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>tfCard <span class="token operator">=</span> tfCard<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">getSD</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> tfCard<span class="token punctuation">.</span><span class="token function">getTF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeSD</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"adapter write tf card"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tfCard<span class="token punctuation">.</span><span class="token function">readTf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h2><p>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</p><p>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2021/04/22/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/04/22/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a><strong>建造者模式</strong></h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230329184755372.png" alt="image-20230329184755372"></p><ul><li><p>分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对 象。这个模式适用于:某个对象的构建过程复杂的情况。</p></li><li><p>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象;相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</p></li><li><p>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p></li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构:"></a>结构:</h2><p>建造者(Builder)模式包含如下角色:</p><ul><li>抽象建造者类(Builder):这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的部件对象的创建</li><li>具体建造者类:实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</li><li>产品类(Product):要创建的复杂对象。</li><li>指挥者类(Director):调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</li></ul><p>类图如下:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230329192131765.png" alt="image-20230329192131765"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h2><p><strong>创建共享单车</strong></p><p>生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质<br>的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。</p><p>这里Bike是产品，包含车架，车座等组件;Builder是抽象建造者，MobikeBuilder和 OfoBuilder是具体的建造者;Director是指挥者。类图如下:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230329192229940.png" alt="image-20230329192229940"></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 建造者模式<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/29 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bike</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//车架</span>    <span class="token keyword">private</span> String frame<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//座位</span>    <span class="token keyword">private</span> String seat<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> frame<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setFrame</span><span class="token punctuation">(</span>String frame<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>frame <span class="token operator">=</span> frame<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getSeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> seat<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSeat</span><span class="token punctuation">(</span>String seat<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>seat <span class="token operator">=</span> seat<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>builder类，抽象建造者类里面规定这个对象的创建：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> Bike mBike <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bike</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildSeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> Bike <span class="token function">createBike</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>具体建造类:具体建造者类,去实现我们的Builder类，提供具体的实现</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MobikeBuilder</span> <span class="token keyword">extends</span> <span class="token class-name">Builder</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mBike<span class="token punctuation">.</span><span class="token function">setFrame</span><span class="token punctuation">(</span><span class="token string">"铝合金车架"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildSeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mBike<span class="token punctuation">.</span><span class="token function">setSeat</span><span class="token punctuation">(</span><span class="token string">"真皮车座"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Bike <span class="token function">createBike</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mBike<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 建造者模式<span class="token punctuation">.</span>bicycle<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/29 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OfoBuilder</span> <span class="token keyword">extends</span> <span class="token class-name">Builder</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mBike<span class="token punctuation">.</span><span class="token function">setFrame</span><span class="token punctuation">(</span><span class="token string">"碳纤维车架"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildSeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mBike<span class="token punctuation">.</span><span class="token function">setSeat</span><span class="token punctuation">(</span><span class="token string">"橡胶车座"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Bike <span class="token function">createBike</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mBike<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>指挥者类:调用具体建造者来创建复杂对象的各个部分。来确定怎么去创建对象</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Builder mBuilder<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Director</span><span class="token punctuation">(</span>Builder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mBuilder <span class="token operator">=</span> builder<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Bike <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mBuilder<span class="token punctuation">.</span><span class="token function">buildFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mBuilder<span class="token punctuation">.</span><span class="token function">buildSeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> mBuilder<span class="token punctuation">.</span><span class="token function">createBike</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>注意:</strong></p><p>上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 抽象 builder 类</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> Bike mBike <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bike</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildSeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> Bike <span class="token function">createBike</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Bike <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">buildFrame</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">BuildSeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createBike</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p><strong>说明:</strong></p><p>这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果 construct() 过于复杂，建议还是封装到 Director 中。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h2><ul><li>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</li><li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li></ul><p>缺点:</p><p>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h2><p>建造者(Builder)模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p><ul><li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li><li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表<br>  示是独立的。</li></ul><h2 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a><strong>模式扩展</strong></h2><p>建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。</p><p>重构前代码如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String cpu<span class="token punctuation">;</span>    <span class="token keyword">private</span> String screen<span class="token punctuation">;</span>    <span class="token keyword">private</span> String memory<span class="token punctuation">;</span>    <span class="token keyword">private</span> String mainboard<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Phone</span><span class="token punctuation">(</span>String cpu<span class="token punctuation">,</span> String screen<span class="token punctuation">,</span> String memory<span class="token punctuation">,</span> Stringmainboard<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cpu <span class="token operator">=</span> cpu<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>screen <span class="token operator">=</span> screen<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>memory <span class="token operator">=</span> memory<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mainboard <span class="token operator">=</span> mainboard<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getCpu</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cpu<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCpu</span><span class="token punctuation">(</span>String cpu<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cpu <span class="token operator">=</span> cpu<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getScreen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> screen<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setScreen</span><span class="token punctuation">(</span>String screen<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>screen <span class="token operator">=</span> screen<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> memory<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMemory</span><span class="token punctuation">(</span>String memory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>memory <span class="token operator">=</span> memory<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getMainboard</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> mainboard<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMainboard</span><span class="token punctuation">(</span>String mainboard<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mainboard <span class="token operator">=</span> mainboard<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Phone{"</span> <span class="token operator">+</span>                <span class="token string">"cpu='"</span> <span class="token operator">+</span> cpu <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">", screen='"</span> <span class="token operator">+</span> screen <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">", memory='"</span> <span class="token operator">+</span> memory <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">", mainboard='"</span> <span class="token operator">+</span> mainboard <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢?代码的可读性及使用的成本 就是比较高。</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Phone phone <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token punctuation">(</span><span class="token string">"intel"</span><span class="token punctuation">,</span><span class="token string">"三星屏幕"</span><span class="token punctuation">,</span><span class="token string">"金士顿"</span><span class="token punctuation">,</span><span class="token string">"华硕"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>重构后代码:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 建造者模式<span class="token punctuation">.</span>Simple<span class="token punctuation">.</span>Builder<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/29 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String cpu<span class="token punctuation">;</span>    <span class="token keyword">private</span> String screen<span class="token punctuation">;</span>    <span class="token keyword">private</span> String memory<span class="token punctuation">;</span>    <span class="token keyword">private</span> String mainboard<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Phone</span><span class="token punctuation">(</span>builder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cpu <span class="token operator">=</span> builder<span class="token punctuation">.</span>cpu<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>screen <span class="token operator">=</span> builder<span class="token punctuation">.</span>screen<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>memory <span class="token operator">=</span> builder<span class="token punctuation">.</span>memory<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mainboard <span class="token operator">=</span> builder<span class="token punctuation">.</span>mainboard<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">builder</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> String cpu<span class="token punctuation">;</span>        <span class="token keyword">private</span> String screen<span class="token punctuation">;</span>        <span class="token keyword">private</span> String memory<span class="token punctuation">;</span>        <span class="token keyword">private</span> String mainboard<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> builder <span class="token function">cpu</span><span class="token punctuation">(</span>String val<span class="token punctuation">)</span><span class="token punctuation">{</span>            cpu<span class="token operator">=</span>val<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> builder <span class="token function">screen</span><span class="token punctuation">(</span>String val<span class="token punctuation">)</span><span class="token punctuation">{</span>            screen<span class="token operator">=</span>val<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> builder <span class="token function">memory</span><span class="token punctuation">(</span>String val<span class="token punctuation">)</span><span class="token punctuation">{</span>            memory<span class="token operator">=</span>val<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> builder <span class="token function">mainboard</span><span class="token punctuation">(</span>String val<span class="token punctuation">)</span><span class="token punctuation">{</span>            mainboard<span class="token operator">=</span>val<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Phone <span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Phone</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Phone{"</span> <span class="token operator">+</span>                <span class="token string">"cpu='"</span> <span class="token operator">+</span> cpu <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">", screen='"</span> <span class="token operator">+</span> screen <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">", memory='"</span> <span class="token operator">+</span> memory <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">", mainboard='"</span> <span class="token operator">+</span> mainboard <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                <span class="token string">'}'</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Phone builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">cpu</span><span class="token punctuation">(</span><span class="token string">"intel"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">screen</span><span class="token punctuation">(</span><span class="token string">"三星屏幕"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">memory</span><span class="token punctuation">(</span><span class="token string">"金士顿"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mainboard</span><span class="token punctuation">(</span><span class="token string">"华硕"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比<br>较高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>1、建造者模式是通过将我们的复杂创建对象的过程进行一个分离。意在通过一步一步地精确构造创建出一个复杂的对象。</p><p>2、建造者模式注重的是部件构建的过程。而我们的工厂模式注重的是整体对象的创建方式</p><p>3、建造者模式主要角色:</p><ul><li>抽象建造者类(Builder):这个接口规定要实现复杂对象的哪些部分的创建，并不涉及具体的部件对象的创建</li><li>具体建造者类:实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</li><li>产品类(Product):要创建的复杂对象。</li><li>指挥者类(Director):调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</li></ul><p>4、可以将我们的指挥者类和我们的抽象建造者类进行合并操作。</p><p>5、比较常见的操作就是:就是创建我们的对象的时候，使用静态内部类builder去构建一个复杂的对象。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解压和压缩命令</title>
      <link href="/2021/04/22/%E8%A7%A3%E5%8E%8B%E5%92%8C%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/22/%E8%A7%A3%E5%8E%8B%E5%92%8C%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="解压和压缩命令"><a href="#解压和压缩命令" class="headerlink" title="解压和压缩命令"></a>解压和压缩命令</h3><blockquote><p> 压缩和解压类</p></blockquote><pre class=" language-code"><code class="language-code"> gzip/gunzip 指令</code></pre><p>gzip 用于压缩文件，gunzip用于解压的</p><p>基本语法:</p><pre class=" language-code"><code class="language-code">gzip 文件 (功能描述:压缩文件,只能将文件压缩为*.gz文件)gunzip 文件.gz (解压缩文件命令</code></pre><p>应用实例:</p><p>案列1: gzip压缩,将&#x2F;home下的hello.txt文件进行压缩</p><pre class=" language-linux"><code class="language-linux">gzip /home/hello.txt  #压缩</code></pre><p>案列2:gunzip压缩,将&#x2F;home下的hello.txt.gz文件进行解压缩.</p><pre class=" language-bash"><code class="language-bash">gunzip /home/hello.txt.gz <span class="token comment" spellcheck="true">#解压</span></code></pre><h3 id="zip-x2F-unzip指令"><a href="#zip-x2F-unzip指令" class="headerlink" title="zip&#x2F;unzip指令"></a>zip&#x2F;unzip指令</h3><blockquote><p> zip用于压缩文件，unzip用于解压的，这个在项目打爆发布中很有用.</p></blockquote><p>基本语法:</p><pre class=" language-linux"><code class="language-linux">zip [选项] xxx.zip 将要压缩的内容  （功能描述:压缩文件和目录的命令）unzip [选项] xxx.zip (功能描述:解压缩文件)</code></pre><p>zip常用选项</p><p>-r: 递归压缩，即压缩目录</p><p>unzip的常用选项</p><p>-d &lt;目录&gt;:指定解压后文件的存放目录</p><p>案例:</p><p>案例一:将&#x2F;home下的所有文件&#x2F;进行压缩成myhome.zip</p><pre class=" language-linux"><code class="language-linux">zip -r myhome/  </code></pre><p>案例二:将myhome.zip压缩到&#x2F;opt&#x2F;temp下.</p><pre class=" language-linux"><code class="language-linux">unzip -d /opt/temp myhome.zip  </code></pre><h3 id="tar指令-最常用的命令"><a href="#tar指令-最常用的命令" class="headerlink" title="tar指令(最常用的命令)"></a>tar指令(最常用的命令)</h3><p>tar指令是打包指令,最后打包后的文件是.tar.gz的文件</p><p>基本语法：</p><blockquote><p>tar [选项] xxx.tar.gz 打包的内容  （功能描述:打包目录,压缩后的文件选项说明）</p></blockquote><table><thead><tr><th>选项</th><th align="center">功能</th></tr></thead><tbody><tr><td>-c</td><td align="center">产生.tar打包文件</td></tr><tr><td>-v</td><td align="center">显示详细信息</td></tr><tr><td>-f</td><td align="center">指定压缩后的文件名</td></tr><tr><td>-z</td><td align="center">用gzip对文档进行压缩或解压</td></tr><tr><td>-x</td><td align="center">解包.tar文件</td></tr></tbody></table><p>应用案例：</p><p>案例一:压缩多个文件,将&#x2F;home&#x2F;pig.txt和&#x2F;home&#x2F;cat.txt压缩成pc.tar.gz</p><pre class=" language-linux"><code class="language-linux">[root@VM-0-17-centos home]# tar -zcvf pc.tar.gz cat.txt pig.txtcat.txtpig.txt[root@VM-0-17-centos home]# lscat.txt  hello.txt  hexo  kevintam  pc.tar.gz  pig.txt  txh</code></pre><p>案例二：将&#x2F;home的文件夹压缩成myhome.tar.gz</p><pre class=" language-linux"><code class="language-linux">[root@VM-0-17-centos home]# tar -zcvf myhome.tar.gz /home/ #包括/home</code></pre><p>案例三：将pc.tar.gz解压到当前目录.</p><pre class=" language-linux"><code class="language-linux">[root@VM-0-17-centos home]# tar -zxvf pc.tar.gz cat.txtpig.txt[root@VM-0-17-centos home]# lscat.txt  hello.txt  hexo  kevintam  pc.tar.gz  pig.txt  txh</code></pre><p>案例四：将myhome.tar.gz 解压到&#x2F;opt&#x2F;temm目录下</p><pre class=" language-linux"><code class="language-linux">tar -zxvf /home/myhome.tar.gz -C /opt/tem2</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="/2021/04/18/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/04/18/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在现实生活中，常常会出现这样的事例:一个请求有多个对象可以处理，但每个对象的处理条件或权限 不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓 名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传 花”游戏等。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a><strong>定义:</strong></h2><p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链;当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>简单点来说，就是将我们的请求发送者和我们的处理者进行分离。然后将我们的多个处理者，以链表进行连接。所以需要我们每个处理者里面有一个指针用于指向下一个处理者。这样就可以构成一个责任链模式。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a><strong>结构</strong></h2><p>职责链模式主要包含以下角色:</p><ul><li>抽象处理者(Handler)角色:定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者(Concrete Handler)角色:实现抽象处理者的处理方法，判断能否处理本次请 求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类(Client)角色:创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节 和请求的传递过程。</li></ul><p>简单来说这个抽象处理者角色就是我们的service的接口，然后我们为了可以将这些接口进行连接形成一个向链表形式数据结构。需要将这个角色中存在一个指针，也就是这个后继连接。</p><h2 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a><strong>案例实现</strong></h2><p>现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可;请假1天到3天的假还需要部门经理同意;请求3天到7天还需要总经理同意才行。</p><p>类图如下:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230331002647767.png" alt="image-20230331002647767"></p><p>请求系统:</p><p>1、请求条</p><p>2、处理请求条的人、组长、经理等</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 责任链模式<span class="token punctuation">.</span>请假<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/15 * 请假条 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LeaveRequest</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer num<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//请假的天数</span>    <span class="token keyword">private</span> String content<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//请求内容</span>    <span class="token keyword">public</span> <span class="token function">LeaveRequest</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> Integer num<span class="token punctuation">,</span> String content<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>content <span class="token operator">=</span> content<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Integer <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNum</span><span class="token punctuation">(</span>Integer num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> content<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setContent</span><span class="token punctuation">(</span>String content<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>content <span class="token operator">=</span> content<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>抽象处理类:Handler</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>     <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> NUM_ONE <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> NUM_THREE <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> NUM_SEVEN <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Integer numStart<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//请假的起始</span>    <span class="token keyword">private</span> Integer numEnd<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//请假的终点</span>    <span class="token comment" spellcheck="true">//向链式存储一样</span>    <span class="token keyword">private</span> Handler nextHandler<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//领导上面还有领导</span>    <span class="token comment" spellcheck="true">//设置请假天数范围 上不封顶</span>    <span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> numStart<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>numStart <span class="token operator">=</span> numStart<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//设置请假天数范围</span>    <span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token keyword">int</span> numStart<span class="token punctuation">,</span> <span class="token keyword">int</span> numEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>numStart <span class="token operator">=</span> numStart<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>numEnd <span class="token operator">=</span> numEnd<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">//以链表形式进行处理</span>    <span class="token comment" spellcheck="true">//设置上级领导</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextHandler</span><span class="token punctuation">(</span>Handler nextHandler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler <span class="token operator">=</span> nextHandler<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">submit</span><span class="token punctuation">(</span>LeaveRequest leave<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>numStart<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//只要我们的num大于我们的起始天数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>leave<span class="token punctuation">.</span><span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>numStart<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleLeave</span><span class="token punctuation">(</span>leave<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler <span class="token operator">&amp;&amp;</span> leave<span class="token punctuation">.</span><span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> numEnd<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>leave<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//继续提交</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"流程结束"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//真正处理的方法</span>    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">handleLeave</span><span class="token punctuation">(</span>LeaveRequest leave<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>小组长只能处理1～3天的假:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 责任链模式<span class="token punctuation">.</span>请假<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/15 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GroupLeader</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//小组长只有三天的请求权利</span>    <span class="token keyword">public</span> <span class="token function">GroupLeader</span><span class="token punctuation">(</span><span class="token keyword">int</span> numStart<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>Handler<span class="token punctuation">.</span>NUM_ONE<span class="token punctuation">,</span> Handler<span class="token punctuation">.</span>NUM_THREE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">handleLeave</span><span class="token punctuation">(</span>LeaveRequest leave<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>leave<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"请假"</span> <span class="token operator">+</span> leave<span class="token punctuation">.</span><span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token string">"天,"</span> <span class="token operator">+</span> leave<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小组长审批:同意。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>部门经理能处理3～7天的假:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 责任链模式<span class="token punctuation">.</span>请假<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/31 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Manager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>Handler<span class="token punctuation">.</span>NUM_THREE<span class="token punctuation">,</span> Handler<span class="token punctuation">.</span>NUM_SEVEN<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">handleLeave</span><span class="token punctuation">(</span>LeaveRequest leave<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>leave<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"请假"</span> <span class="token operator">+</span> leave<span class="token punctuation">.</span><span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>                <span class="token string">"天,"</span> <span class="token operator">+</span> leave<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"部门经理审批:同意。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>测试类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 责任链模式<span class="token punctuation">.</span>请假<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/31 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//请假条来一张</span>        LeaveRequest leave <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LeaveRequest</span><span class="token punctuation">(</span><span class="token string">"小花"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">"身体不适"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//各位领导</span>        GroupLeader groupLeader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GroupLeader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Manager manager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        groupLeader<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>manager<span class="token punctuation">)</span><span class="token punctuation">;</span>        groupLeader<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>leave<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>接口显示:</p><pre class=" language-java"><code class="language-java">小花请假<span class="token number">5</span>天<span class="token punctuation">,</span>身体不适。小组长审批<span class="token operator">:</span>同意。小花请假<span class="token number">5</span>天<span class="token punctuation">,</span>身体不适。部门经理审批<span class="token operator">:</span>同意。流程结束</code></pre><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h2><p><strong>优点:</strong></p><ul><li>降低了对象之间的耦合度</li></ul><p>该模式降低了请求发送者和接收者的耦合度。</p><ul><li>增强了系统的可扩展性</li></ul><p>可以根据需要增加新的请求处理类，满足开闭原则。</p><ul><li>增强了给对象指派职责的灵活性</li></ul><p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p><ul><li>责任链简化了对象之间的连接</li></ul><p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</p><p><strong>缺点:</strong></p><p>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</p><p>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</p><h2 id="实战使用"><a href="#实战使用" class="headerlink" title="实战使用:"></a>实战使用:</h2><blockquote><p>在我们的项目中，我们有一个需求就是将前端传入的视频格式进行编码或加水印的操作。</p></blockquote><p>如果是我们往常方式就是直接使用一个if、else进行判断，得到前端的上传的文件名，然后通过我们equlas进行比较，从而去到对应的utils进行处理。ffmepg这个工具来进行处理。</p><p>使用责任链模式加上我们的构建者模式进行优化。</p><p>责任链模式是将我们的视频处理的工具类，以链表形式进行连接。</p><p>然后将我们的视频传入到我们的责任链格式中，然后去到对应的这个处理者进行处理。</p><p>构建者模式的作用:就是将我们的处理者，构建成一个链表的形式.</p><p>代码实现:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 责任链模式<span class="token punctuation">.</span>视频处理<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/15 * 视频处理 */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> Handler nextHandler<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下一个视频处理</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextHandler</span><span class="token punctuation">(</span>Handler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler <span class="token operator">=</span> handler<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//构建者模式</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> Handler hand<span class="token punctuation">;</span>        <span class="token keyword">private</span> Handler tail<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//建造成一个链式</span>        <span class="token keyword">public</span> Builder <span class="token function">addHandler</span><span class="token punctuation">(</span>Handler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>hand<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//初始化头节点</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>hand<span class="token operator">=</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token operator">=</span>handler<span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//让我们的后指针指向下一个节点</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将我们的mp4链接到我们后面</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token operator">=</span>handler<span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>            hand<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>具体的处理类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 责任链模式<span class="token punctuation">.</span>视频处理<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/15 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AVIHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">".avi"</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"avi格式得到处理"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            nextHandler<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>client的测试类:</p><pre class=" language-java"><code class="language-java"> Handler<span class="token punctuation">.</span>Builder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AVIHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Mp4Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Mp3Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                                <span class="token punctuation">.</span><span class="token function">addHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ResultHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token string">"zhangsan.avi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>走进linux系统</title>
      <link href="/2021/04/18/%E8%B5%B0%E8%BF%9Blinux%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/04/18/%E8%B5%B0%E8%BF%9Blinux%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="走近Linux系统"><a href="#走近Linux系统" class="headerlink" title="走近Linux系统"></a>走近Linux系统</h2><blockquote><p>开机登录</p></blockquote><p>开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p><p>开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！</p><p>一般来说，用户的登录方式有三种：</p><ul><li>命令行登录</li><li>ssh登录</li><li>图形界面登录</li></ul><p>最高权限账户为 root，可以操作一切！</p><blockquote><p>关机</p></blockquote><p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>关机指令为：shutdown ；</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sync</span> <span class="token comment" spellcheck="true"># 将数据由内存同步到硬盘中。</span><span class="token function">shutdown</span> <span class="token comment" spellcheck="true"># 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><span class="token function">shutdown</span> –h 10 <span class="token comment" spellcheck="true"># 这个命令告诉大家，计算机将在10分钟后关机</span><span class="token function">shutdown</span> –h now <span class="token comment" spellcheck="true"># 立马关机</span><span class="token function">shutdown</span> –h 20:25 <span class="token comment" spellcheck="true"># 系统会在今天20:25关机</span><span class="token function">shutdown</span> –h +10 <span class="token comment" spellcheck="true"># 十分钟后关机</span><span class="token function">shutdown</span> –r now <span class="token comment" spellcheck="true"># 系统立马重启</span><span class="token function">shutdown</span> –r +10 <span class="token comment" spellcheck="true"># 系统十分钟后重启</span><span class="token function">reboot</span> <span class="token comment" spellcheck="true"># 就是重启，等同于 shutdown –r now</span>halt <span class="token comment" spellcheck="true"># 关闭系统，等同于shutdown –h now 和 poweroff</span></code></pre><p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p><blockquote><p>系统目录结构</p></blockquote><p>登录系统后，在当前命令窗口下输入命令：</p><pre class=" language-linux"><code class="language-linux">ls /</code></pre><p>你会看到如下图所示：</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/linux.JPG" alt="图片"></p><p>树状目录结构：（Linux的一切资源都挂载在这个 &#x2F; 根节点下）</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="图片"></p><p><strong>以下是对这些目录的解释：</strong></p><ul><li>&#x2F;bin(常用)：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li>&#x2F;boot：(常用) 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li>&#x2F;dev: dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li>&#x2F;etc(常用) :这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li><li>&#x2F;home(常用)：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li>&#x2F;lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</li><li>&#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li>&#x2F;media(常用)： linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li>&#x2F;mnt(常用)：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</li><li>&#x2F;opt(常用)：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li>&#x2F;proc[不能动]：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li><li>&#x2F;root：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li>&#x2F;sbin： s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li>&#x2F;srv[不能动]： 该目录存放一些服务启动之后需要提取的数据。</li><li>&#x2F;sys[不能动]：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li><li>&#x2F;tmp： 这个目录是用来存放一些临时文件的。</li><li>&#x2F;usr： 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li><li>&#x2F;usr&#x2F;bin:  系统用户使用的应用程序。</li><li>&#x2F;usr&#x2F;sbin: 超级用户使用的比较高级的管理程序和系统守护程序。</li><li>&#x2F;usr&#x2F;src: 内核源代码默认的放置目录。</li><li>&#x2F;usr&#x2F;local&#x2F;:这是另一个给主机安装软件所安排的目录.一盘是通过编译源码方式来安装的程序</li><li>&#x2F;var(常用)：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li>&#x2F;run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常见的目录命令</title>
      <link href="/2021/04/17/linux%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%AE%E5%BD%95%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/17/linux%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%AE%E5%BD%95%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="常用的基本命令（必掌握）"><a href="#常用的基本命令（必掌握）" class="headerlink" title="常用的基本命令（必掌握）"></a>常用的基本命令（必掌握）</h3><h4 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h4><h4 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h4><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 &#x2F;。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="网图"></p><p><strong>绝对路径：</strong></p><p>路径的写法，由根目录 &#x2F; 写起，例如：&#x2F;usr&#x2F;share&#x2F;doc 这个目录。</p><p><strong>相对路径：</strong></p><p>路径的写法，不是由 &#x2F; 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成：cd ..&#x2F;man 这就是相对路径的写法啦！</p><h4 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h4><p>接下来我们就来看几个常见的处理目录的命令吧：</p><ul><li>ls: 列出目录</li><li>cd：切换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><h4 id="ls-（列出目录）"><a href="#ls-（列出目录）" class="headerlink" title="ls （列出目录）"></a>ls （列出目录）</h4><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><pre><code>[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称</code></pre><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将目录下的所有文件列出来(含属性与隐藏档)</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls -al ~</span></code></pre><h4 id="cd-（切换目录）"><a href="#cd-（切换目录）" class="headerlink" title="cd （切换目录）"></a>cd （切换目录）</h4><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><pre><code>cd [相对路径或绝对路径]</code></pre><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 切换到用户目录下</span><span class="token punctuation">[</span>root@VM-0-17-centos /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd home</span><span class="token comment" spellcheck="true"># 使用 mkdir 命令创建 tom 目录</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir tom</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>kevintam  tom<span class="token comment" spellcheck="true"># 进入  tom 目录</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd tom/</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token comment" spellcheck="true"># 回到上一级</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd ..</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token comment" spellcheck="true"># 回到根目录</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /</span><span class="token punctuation">[</span>root@VM-0-17-centos /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token comment" spellcheck="true"># 表示回到自己的家目录，亦即是 /root 这个目录</span><span class="token punctuation">[</span>root@VM-0-17-centos /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd ~</span><span class="token punctuation">[</span>root@VM-0-17-centos ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span></code></pre><h4 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd ( 显示目前所在的目录 )"></a>pwd ( 显示目前所在的目录 )</h4><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><pre><code>[root@kuangshen kuangstudy]#pwd [-P]</code></pre><p>选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。</p><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 单纯显示出目前的工作目录</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># pwd</span>/home/tom<span class="token comment" spellcheck="true"># 如果是链接，要显示真实地址，可以使用 -P参数</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># pwd -P</span>/home/tom</code></pre><h4 id="mkdir-（创建新目录）"><a href="#mkdir-（创建新目录）" class="headerlink" title="mkdir （创建新目录）"></a>mkdir （创建新目录）</h4><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><pre><code>mkdir [-mp] 目录名称</code></pre><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 进入我们用户目录下</span><span class="token punctuation">[</span>root@VM-0-17-centos /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd home/</span><span class="token comment" spellcheck="true"># 创建一个 test 文件夹</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir test</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>kevintam  <span class="token function">test</span>  tom<span class="token comment" spellcheck="true"># 创建多层级目录</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir test1/test2</span>mkdir: cannot create directory ‘test1/test2’: No such <span class="token function">file</span> or directory<span class="token comment" spellcheck="true"># &lt;== 没办法直接创建此目录啊！</span><span class="token comment" spellcheck="true"># 加了这个 -p 的选项，可以自行帮你创建多层目录！</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir -p  test1/test2</span></code></pre><h4 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir ( 删除空的目录 )"></a>rmdir ( 删除空的目录 )</h4><p>语法：</p><pre><code>rmdir [-p] 目录名称</code></pre><p>选项与参数：**-p ：**连同上一级『空的』目录也一起删除</p><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 看看有多少目录存在？</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls -l</span>total 16drwxr-xr-x 2 root root 4096 Feb 26 14:45 kevintamdrwxr-xr-x 2 root root 4096 Feb 26 14:51 <span class="token function">test</span>drwxr-xr-x 3 root root 4096 Feb 26 14:51 test1drwxr-xr-x 2 root root 4096 Feb 26 14:46 tom<span class="token comment" spellcheck="true"># 可直接删除掉，没问题</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rmdir test</span><span class="token comment" spellcheck="true"># 因为尚有内容，所以无法删除！</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rmdir test1/</span>rmdir: failed to remove ‘test1/’: Directory not empty<span class="token comment" spellcheck="true"># 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rmdir -p test1/test2/</span></code></pre><p>注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录.</p><h4 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp ( 复制文件或目录 )"></a>cp ( 复制文件或目录 )</h4><p>语法：</p><pre><code>[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory</code></pre><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 找一个有文件的目录，我这里找到 root目录</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /root</span><span class="token punctuation">[</span>root@kuangshen ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>install.sh<span class="token punctuation">[</span>root@kuangshen ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /home</span><span class="token comment" spellcheck="true"># 复制 home目录下的hello 到 opt目录下</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp -r hello /opt/</span><span class="token comment" spellcheck="true"># 再次复制，加上-i参数，增加覆盖询问？</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp -r hello /opt/</span>cp: overwrite ‘/opt/hello/hello.txt’? y <span class="token comment" spellcheck="true"># n不覆盖，y为覆盖</span><span class="token comment" spellcheck="true">#不提示是否覆盖</span>\cp -r /root/install.sh /home</code></pre><h4 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm ( 移除文件或目录 )"></a>rm ( 移除文件或目录 )</h4><p>语法：</p><pre><code>rm [-fir] 文件或目录</code></pre><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span><span class="token punctuation">[</span>root@VM-0-17-centos opt<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rm -rf hello</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rm hello.txt </span>rm: remove regular empty <span class="token function">file</span> ‘hello.txt’? y<span class="token comment" spellcheck="true"># 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</span><span class="token comment" spellcheck="true"># 尽量不要在服务器上使用 rm -rf /</span></code></pre><h4 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv  ( 移动文件与目录，或修改名称 )"></a>mv  ( 移动文件与目录，或修改名称 )</h4><p>语法：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mv [-fiu] source destination</span><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mv [options] source1 source2 source3 .... directory</span><span class="token comment" spellcheck="true">#如果是在一个目录下的移动就是重命名</span></code></pre><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 复制一个文件到当前目录</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp /root/install.sh /home</span><span class="token comment" spellcheck="true"># 创建一个文件夹 test</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir test</span><span class="token comment" spellcheck="true"># 将复制过来的文件移动到我们创建的目录，并查看</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mv install.sh test</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span><span class="token function">test</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd test</span><span class="token punctuation">[</span>root@kuangshen test<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>install.sh<span class="token comment" spellcheck="true"># 将文件夹重命名，然后再次查看！</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># touch cat</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mv cat pig</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>kevintam  pig  tom</code></pre><h4 id="创建一个空的文件"><a href="#创建一个空的文件" class="headerlink" title="创建一个空的文件"></a>创建一个空的文件</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">touch</span> <span class="token punctuation">[</span>文件名称<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#指令</span></code></pre><p>测试</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@VM-0-17-centos kevintam<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># touch hello.java</span><span class="token punctuation">[</span>root@VM-0-17-centos kevintam<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>hello.java</code></pre><h4 id="查看文件的内容"><a href="#查看文件的内容" class="headerlink" title="查看文件的内容"></a>查看文件的内容</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token comment" spellcheck="true">#查看文件的内容</span>-n <span class="token comment" spellcheck="true">#显示行号</span><span class="token comment" spellcheck="true">#查看/etc/profile的文件 -n就是查看行号.</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat -n /etc/profile</span><span class="token comment" spellcheck="true"># | more 管道命令 按回车键往下走 输入空格 会直接下一页</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat -n /etc/profile | more</span></code></pre><p>more指令是一个vi编辑的文本过滤器，他以全屏的方式按页显示内容</p><p>more中常见的快捷键</p><ul><li>空格键: 往下翻一页</li><li>enter ：往下走一段</li><li>q：立刻离开</li><li>ctrl+f：向下滚动一屏</li><li>ctrl+b：返回上一屏</li><li>&#x3D;：输出当前行号</li><li>：f  输出当前的行号和文件名</li></ul><p>cat和more通常组合使用</p><h4 id="less-指令"><a href="#less-指令" class="headerlink" title="less 指令"></a>less 指令</h4><p>less指令支持用来分屏查看文件内容。通常使用在大文件的查看</p><p>常用指令：</p><ul><li>空格键:向下翻到一页</li><li>q：离开less指令</li><li>&#x2F;字符：查询字符</li><li>[pagedown]：向下翻动一页</li><li>[pageup]：向上翻动一页</li></ul><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>输出内容到控制台</p><pre class=" language-bash"><code class="language-bash">echo<span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>输出内容<span class="token punctuation">]</span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo $HOSTNAME</span>VM-0-17-centos<span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo "hello world~~"</span>hello world~~</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token function">head</span><span class="token comment" spellcheck="true">#文件的开头</span><span class="token comment" spellcheck="true">#看5行的代码</span><span class="token function">head</span> -n 5<span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># head -n 5 /etc/profile</span><span class="token comment" spellcheck="true"># /etc/profile</span><span class="token comment" spellcheck="true"># System wide environment and startup programs, for login setup</span><span class="token comment" spellcheck="true"># Functions and aliases go in /etc/bashrc</span><span class="token function">tail</span>  -f<span class="token comment" spellcheck="true">#文件尾的内容 实时的监控文件</span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span>和<span class="token operator">>></span>指令<span class="token comment" spellcheck="true">#输出重定向和追加</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo "hello world" > data.txt #会覆盖该文件里的数据</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo "java" >> data.txt #在原数据的基础上会追加内容</span></code></pre><h4 id="查看当前日期"><a href="#查看当前日期" class="headerlink" title="查看当前日期"></a>查看当前日期</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">cal</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cal</span>     March 2021     Su Mo Tu We Th Fr Sa    1  2  3  4  5  6 7  8  9 10 11 12 1314 15 16 17 18 19 2021 22 23 24 25 26 2728 29 30 31</code></pre><h4 id="In指令"><a href="#In指令" class="headerlink" title="In指令"></a>In指令</h4><p>软链接也称为符号链接,类似于windows里的快捷方式,主要存放了链接其他文件的路径</p><p>基本语法</p><pre class=" language-shell"><code class="language-shell">in -s 原文件或目录(功能描述：给原文件创建一个软链接) 连接到的目录</code></pre><p>引用案列</p><p>案列1:在&#x2F;home目录下创建一个软链接myroot,连接到&#x2F;root目录</p><p>案列2:删除软链接myroot</p><pre class=" language-shell"><code class="language-shell">in -s /root /myrootrm /home/myroot #删除这个目录即可</code></pre><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>查看已执行过历史命令,也可以执行历史命令</p><p>基本语法</p><p>history (功能描述:查看已经执行过历史命令)</p><pre class=" language-shell"><code class="language-shell">history</code></pre><p>案列1:显示所有的历史命令</p><pre class=" language-shell"><code class="language-shell">history</code></pre><p>案列2:显示最近使用过的10个指令</p><pre class=" language-shell"><code class="language-shell">history 10</code></pre><p>案列3：执行历史编号为5的指令</p><pre class=" language-shell"><code class="language-shell">!5</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
