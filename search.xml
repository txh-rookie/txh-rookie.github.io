<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>支付宝支付</title>
      <link href="/2023/03/23/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98/"/>
      <url>/2023/03/23/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98/</url>
      
        <content type="html"><![CDATA[<h2 id="支付接口的调研"><a href="#支付接口的调研" class="headerlink" title="支付接口的调研:"></a>支付接口的调研:</h2><h3 id="微信支付接口调研"><a href="#微信支付接口调研" class="headerlink" title="微信支付接口调研:"></a>微信支付接口调研:</h3><p>一般情况下，一个网站要支持在线支付功能通常接入第三方支付平台，比如：微信支付、支付宝、其它的聚合支付平台。</p><p>本项目的需求实现手机扫码支付，现在对微信、支付宝的支付接口进行调研。</p><p>微信目前提供的支付方式如下：</p><p>地址：<a href="https://pay.weixin.qq.com/static/product/product_index.shtml">https://pay.weixin.qq.com/static/product/product_index.shtml</a></p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160603449.png" alt="image-20230323160603449"></p><ol><li><p>付款码支付是指用户展示微信钱包内的“付款码”给商户系统扫描后直接完成支付，适用于线下场所面对面收银的场景，例如商超、便利店、餐饮、医院、学校、电影院和旅游景区等具有明确经营地址的实体场所。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160633442.png" alt="image-20230323160633442"></p></li><li><p>SAPI支付是指商户通过调用微信支付提供的JSAPI接口，在支付场景中调起微信支付模块完成收款</p><p>线下场所：调用接口生成二维码，用户扫描二维码后在微信浏览器中打开页面后完成支付</p><p>公众号场景：用户在微信公众账号内进入商家公众号，打开某个主页面，完成支付</p><p>PC网站场景：在网站中展示二维码，用户扫描二维码后在微信浏览器中打开页面后完成支付</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160650164.png" alt="image-20230323160650164"></p></li><li><p>小程序支付是指商户通过调用微信支付小程序支付接口，在微信小程序平台内实现支付功能；用户打开商家助手小程序下单，输入支付密码并完成支付后，返回商家小程序。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160710635.png" alt="image-20230323160710635"></p></li><li><p>Native支付是指商户系统按微信支付协议生成支付二维码，用户再用微信“扫一扫”完成支付的模式。该模式适用于PC网站、实体店单品或订单、媒体广告支付等场景。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160729715.png" alt="image-20230323160729715"></p></li><li><p>APP支付是指商户通过在移动端应用APP中集成开放SDK调起微信支付模块来完成支付。适用于在移动端APP中集成微信支付功能的场景。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160750086.png" alt="image-20230323160750086"></p></li><li><p>刷脸支付是指用户在刷脸设备前通过摄像头刷脸、识别身份后进行的一种支付方式，安全便捷。适用于线下实体场所的收银场景，如商超、餐饮、便利店、医院、学校等。</p></li></ol><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160805994.png" alt="image-20230323160805994"></p><p>以上接口native和JSAPI都可以实现pc网站实现扫码支付，两者区别是什么？怎么选择？</p><p>JSAPI除了在pc网站扫码支付还可以实现公众号页面内支付，可以实现在H5页面唤起微信客户端完成支付。</p><p>本项目选择JSAPI支付接口。</p><p>接口文档：<a href="https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_1.shtml">https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_1_1.shtml</a></p><p>如果要微信的话需要开通账号认证。</p><h3 id="支付宝接口调研"><a href="#支付宝接口调研" class="headerlink" title="支付宝接口调研:"></a>支付宝接口调研:</h3><p>支付宝支付产品如下：</p><p>文档：<a href="https://b.alipay.com/signing/productSetV2.htm">https://b.alipay.com/signing/productSetV2.htm</a></p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323160945145.png" alt="image-20230323160945145"></p><p>与本项目需求相关的接口：电脑网站支付、手机网站支付。</p><p>1、电脑网站支付</p><p>PC网站轻松收款，资金马上到账：用户在商家PC网站消费，自动跳转支付宝PC网站收银台完成付款。 交易资金直接打入商家支付宝账户，实时到账。</p><p><img src="https://gw.alipayobjects.com/mdn/rms_e15e15/afts/img/A*bbMhQJxew7wAAAAAAAAAAABjARQnAQ" alt="img"></p><p>2、手机网站支付</p><p><img src="https://gw.alipayobjects.com/mdn/rms_e15e15/afts/img/A*KhnKRKr3vsEAAAAAAAAAAABjARQnAQ" alt="img"></p><p>用户在商家手机网站消费，通过浏览器自动跳转支付宝APP或支付宝网页完成付款。 轻松实现和APP支付相同的支付体验。</p><p>对比两种支付方式：手机网站支付方式可以在H5网页唤起支付宝，手机扫码支付可以使用手机网站支付方式来完成，相比电脑网站支付形式更灵活。</p><p>本项目选择手机网站支付方式。</p><p>文档：<a href="https://opendocs.alipay.com/open/02ivbt">https://opendocs.alipay.com/open/02ivbt</a></p><h3 id="准备开发环境"><a href="#准备开发环境" class="headerlink" title="准备开发环境"></a>准备开发环境</h3><p>第三方支付接口流程大同小异，考虑开发及教学的方便性，支付宝提供支付宝沙箱环境开发支付接口，在教学中接入支付宝手机网站支付接口。</p><p>1、配置沙箱环境</p><p>沙箱环境是支付宝开放平台为开发者提供的与生产环境完全隔离的联调测试环境，开发者在沙箱环境中完成的接口调用不会对生产环境中的数据造成任何影响。</p><p>接入手机网站支付需要具备如下条件：</p><p>•    申请前必须拥有经过实名认证的支付宝账户；</p><p>•    企业或个体工商户可申请；</p><p>•    需提供真实有效的营业执照，且支付宝账户名称需与营业执照主体一致；</p><p>•    网站能正常访问且页面显示完整，网站需要明确经营内容且有完整的商品信息；</p><p>•    网站必须通过ICP备案。如为个体工商户，网站备案主体需要与支付宝账户主体名称一致；</p><p>•    如为个体工商户，则团购不开放，且古玩、珠宝等奢侈品、投资类行业无法申请本产品。</p><p>详细参见：<a href="https://docs.open.alipay.com/203">https://docs.open.alipay.com/203</a></p><p>本文档使用支付宝沙箱进行开发测试，这里主要介绍支付宝沙箱环境配置。</p><p>详细参见：<a href="https://docs.open.alipay.com/200/105311/">https://docs.open.alipay.com/200/105311/</a></p><h3 id="创建一个订单服务"><a href="#创建一个订单服务" class="headerlink" title="创建一个订单服务"></a>创建一个订单服务</h3><p>创建订单服务过程study-plus-orders到自己的过程目录。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323195840976.png" alt="image-20230323195840976"></p><h3 id="支付接口测试"><a href="#支付接口测试" class="headerlink" title="支付接口测试"></a>支付接口测试</h3><p>手机网站支付接入流程详细参见：<a href="https://docs.open.alipay.com/203/105285/">https://docs.open.alipay.com/203/105285/</a></p><h4 id="1、接口交互流程如下："><a href="#1、接口交互流程如下：" class="headerlink" title="1、接口交互流程如下："></a>1、接口交互流程如下：</h4><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323203611508.png" alt="image-20230323203611508"></p><p>1）用户在商户的H5网站下单支付后，商户系统按照<a href="https://docs.open.alipay.com/203/107090">手机网站支付接口alipay.trade.wap.pay</a>API的参数规范生成订单数据</p><p>2）前端页面通过Form表单的形式请求到支付宝。此时支付宝会自动将页面跳转至支付宝H5收银台页面，如果用户手机上安装了支付宝APP，则自动唤起支付宝APP。</p><p>3）输入支付密码完成支付。</p><p>4）用户在支付宝APP或H5收银台完成支付后，会根据商户在手机网站支付API中传入的前台回跳地址return_url自动跳转回商户页面，同时在URL请求中以Query String的形式附带上支付结果参数，详细回跳参数见“手机网站支付接口alipay.trade.wap.pay”<a href="https://docs.open.alipay.com/203/107090#s2">前台回跳参数</a>。</p><p>5）支付宝还会根据原始支付API中传入的异步通知地址notify_url，通过POST请求的形式将支付结果作为参数通知到商户系统，详情见<a href="https://docs.open.alipay.com/203/105286">支付结果异步通知</a>。</p><h4 id="2、接口定义"><a href="#2、接口定义" class="headerlink" title="2、接口定义:"></a>2、接口定义:</h4><p>文档:<a href="https://opendocs.alipay.com/open/203/107090">https://opendocs.alipay.com/open/203/107090</a></p><p>接口定义：外部商户请求支付宝创建订单并支付</p><p>公共参数</p><p><strong>请求地址</strong>：</p><p>开发中使用沙箱地址：<a href="https://openapi.alipaydev.com/gateway.do">https://openapi.alipaydev.com/gateway.do</a></p><p>请求参数：</p><p>详细查阅<a href="https://opendocs.alipay.com/open/203/107090">https://opendocs.alipay.com/open/203/107090</a></p><p>一部分由sdk设置，一部分需要编写程序时指定。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323204204833.png" alt="image-20230323204204833"></p><p>其它扩展参数参见接口文档。</p><h4 id="3、示例代码"><a href="#3、示例代码" class="headerlink" title="3、示例代码"></a>3、示例代码</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest httpRequest<span class="token punctuation">,</span>                   HttpServletResponse httpResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>    AlipayClient alipayClient <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">//获得初始化的AlipayClient</span>    AlipayTradeWapPayRequest alipayRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlipayTradeWapPayRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建API对应的request</span>    alipayRequest<span class="token punctuation">.</span><span class="token function">setReturnUrl</span><span class="token punctuation">(</span><span class="token string">"http://domain.com/CallBack/return_url.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    alipayRequest<span class="token punctuation">.</span><span class="token function">setNotifyUrl</span><span class="token punctuation">(</span><span class="token string">"http://domain.com/CallBack/notify_url.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在公共参数中设置回跳和通知地址</span>    alipayRequest<span class="token punctuation">.</span><span class="token function">setBizContent</span><span class="token punctuation">(</span><span class="token string">"{"</span> <span class="token operator">+</span>            <span class="token string">"    \"out_trade_no\":\"20150320010101002\","</span> <span class="token operator">+</span>            <span class="token string">"    \"total_amount\":88.88,"</span> <span class="token operator">+</span>            <span class="token string">"    \"subject\":\"Iphone6 16G\","</span> <span class="token operator">+</span>            <span class="token string">"    \"product_code\":\"QUICK_WAP_WAY\""</span> <span class="token operator">+</span>            <span class="token string">"  }"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//填充业务参数</span>    String form <span class="token operator">=</span> alipayClient<span class="token punctuation">.</span><span class="token function">pageExecute</span><span class="token punctuation">(</span>alipayRequest<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用SDK生成表单</span>    httpResponse<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html;charset="</span> <span class="token operator">+</span> AlipayServiceEnvConstants<span class="token punctuation">.</span>CHARSET<span class="token punctuation">)</span><span class="token punctuation">;</span>    httpResponse<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>form<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接将完整的表单html输出到页面</span>    httpResponse<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="4、下单执行流程"><a href="#4、下单执行流程" class="headerlink" title="4、下单执行流程"></a>4、<strong>下单执行流程</strong></h4><p>根据接口描述，支付宝下单接口的执行流程如下：</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323204555884.png" alt="image-20230323204555884"></p><h4 id="5、支付接口测试"><a href="#5、支付接口测试" class="headerlink" title="5、支付接口测试"></a>5、<strong>支付接口测试</strong></h4><p><strong>编写下单代码</strong></p><p>根据接口流程，首先在订单服务编写测试类请求支付宝下单的接口。</p><p>在订单服务api工程添加依赖：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alipay.sdk<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>alipay-sdk-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.7.73.ALL<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!-- 支付宝SDK依赖的日志 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>commons-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-logging<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>下载示例代码<a href="https://opendocs.alipay.com/open/203/105910">https://opendocs.alipay.com/open/203/105910</a></p><p>代码Demo编写:请求支付宝，拿起我们的请求页面</p><pre class=" language-java"><code class="language-java"> <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/playTest"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doPost</span><span class="token punctuation">(</span>HttpServletRequest httpRequest<span class="token punctuation">,</span>                       HttpServletResponse httpResponse<span class="token punctuation">)</span> <span class="token keyword">throws</span> ServletException<span class="token punctuation">,</span> IOException<span class="token punctuation">,</span> AlipayApiException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 测试的接口参数为:         * 1、url请求的地址         * 2、appid商户id         * 3、私钥         * 4、请求格式         * 5、编码         * 6、支付宝公钥         * 7、加密方式         */</span>        AlipayClient alipayClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultAlipayClient</span><span class="token punctuation">(</span>AlipayConfig<span class="token punctuation">.</span>URL<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>APPID<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>RSA_PRIVATE_KEY<span class="token punctuation">,</span> AlipayConfig<span class="token punctuation">.</span>FORMAT<span class="token punctuation">,</span> AlipayConfig<span class="token punctuation">.</span>CHARSET<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>ALIPAY_PUBLIC_KEY<span class="token punctuation">,</span>AlipayConfig<span class="token punctuation">.</span>SIGNTYPE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获得初始化的AlipayClient</span>        AlipayTradeWapPayRequest alipayRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlipayTradeWapPayRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建API对应的request</span><span class="token comment" spellcheck="true">//        alipayRequest.setReturnUrl("http://domain.com/CallBack/return_url.jsp");</span><span class="token comment" spellcheck="true">//        alipayRequest.setNotifyUrl("http://domain.com/CallBack/notify_url.jsp");//在公共参数中设置回跳和通知地址</span>        <span class="token comment" spellcheck="true">//out_trade_no商户的订单号</span><span class="token comment" spellcheck="true">//        total_amount订单的总金额</span>        <span class="token comment" spellcheck="true">//subject 订单标题。</span>        alipayRequest<span class="token punctuation">.</span><span class="token function">setBizContent</span><span class="token punctuation">(</span><span class="token string">"{"</span> <span class="token operator">+</span>                <span class="token string">"    \"out_trade_no\":\"20150320010101002\","</span> <span class="token operator">+</span>                <span class="token string">"    \"total_amount\":88.88,"</span> <span class="token operator">+</span>                <span class="token string">"    \"subject\":\"Iphone6 16G\","</span> <span class="token operator">+</span>                <span class="token string">"    \"product_code\":\"QUICK_WAP_WAY\""</span> <span class="token operator">+</span>                <span class="token string">"  }"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//填充业务参数</span>        String form <span class="token operator">=</span> alipayClient<span class="token punctuation">.</span><span class="token function">pageExecute</span><span class="token punctuation">(</span>alipayRequest<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//调用SDK生成表单</span>        httpResponse<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"text/html;charset="</span> <span class="token operator">+</span> AlipayConfig<span class="token punctuation">.</span>CHARSET<span class="token punctuation">)</span><span class="token punctuation">;</span>        httpResponse<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>form<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接将完整的表单html输出到页面</span>        httpResponse<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a><strong>生成二维码</strong></h4><p>用户在前端使用支付宝沙箱通过扫码请求下单接口，我们需要生成订单服务的下单接口的二维码。</p><p>ZXing是一个开源的类库，是用Java编写的多格式的1D &#x2F; 2D条码图像处理库，使用ZXing可以生成、识别QR Code（二维码）。常用的二维码处理库还有zbar，近几年已经不再更新代码，下边介绍ZXing生成二维码的方法。</p><p>1）引入依赖</p><p>在base工程pom.xml中添加依赖：</p><pre class=" language-xml"><code class="language-xml"> <span class="token comment" spellcheck="true">&lt;!-- 二维码生成&amp;识别组件 --></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.google.zxing<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.3.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.google.zxing<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>javase<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.3.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>commons-lang3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>2）生成二维码方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>kevintam<span class="token punctuation">.</span>study<span class="token punctuation">.</span>utils<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>zxing<span class="token punctuation">.</span>BarcodeFormat<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>zxing<span class="token punctuation">.</span>EncodeHintType<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>zxing<span class="token punctuation">.</span>client<span class="token punctuation">.</span>j2se<span class="token punctuation">.</span>MatrixToImageWriter<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>zxing<span class="token punctuation">.</span>common<span class="token punctuation">.</span>BitMatrix<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>zxing<span class="token punctuation">.</span>qrcode<span class="token punctuation">.</span>QRCodeWriter<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>zxing<span class="token punctuation">.</span>qrcode<span class="token punctuation">.</span>decoder<span class="token punctuation">.</span>ErrorCorrectionLevel<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang3<span class="token punctuation">.</span>StringUtils<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>imageio<span class="token punctuation">.</span>ImageIO<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>ServletOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>awt<span class="token punctuation">.</span>image<span class="token punctuation">.</span>BufferedImage<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>ByteArrayOutputStream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author Mr.M * @version 1.0 * @description 二维码生成工具 * @date 2022/10/3 0:03 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QRCodeUtil</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 生成二维码     *     * @param content 二维码对应的URL     * @param width   二维码图片宽度     * @param height  二维码图片高度     * @return     */</span>    <span class="token keyword">public</span> String <span class="token function">createQRCode</span><span class="token punctuation">(</span>String content<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        String resultImage <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//除了尺寸，传入内容不能为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ServletOutputStream stream <span class="token operator">=</span> null<span class="token punctuation">;</span>            ByteArrayOutputStream os <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//二维码参数</span>            <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"rawtypes"</span><span class="token punctuation">)</span>            HashMap<span class="token operator">&lt;</span>EncodeHintType<span class="token punctuation">,</span> Comparable<span class="token operator">></span> hints <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//指定字符编码为“utf-8”</span>            hints<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>EncodeHintType<span class="token punctuation">.</span>CHARACTER_SET<span class="token punctuation">,</span> <span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//L M Q H四个纠错等级从低到高，指定二维码的纠错等级为M</span>            <span class="token comment" spellcheck="true">//纠错级别越高，可以修正的错误就越多，需要的纠错码的数量也变多，相应的二维吗可储存的数据就会减少</span>            hints<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>EncodeHintType<span class="token punctuation">.</span>ERROR_CORRECTION<span class="token punctuation">,</span> ErrorCorrectionLevel<span class="token punctuation">.</span>M<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//设置图片的边距</span>            hints<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>EncodeHintType<span class="token punctuation">.</span>MARGIN<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//zxing生成二维码核心类</span>                QRCodeWriter writer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QRCodeWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//把输入文本按照指定规则转成二维吗</span>                BitMatrix bitMatrix <span class="token operator">=</span> writer<span class="token punctuation">.</span><span class="token function">encode</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> BarcodeFormat<span class="token punctuation">.</span>QR_CODE<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">,</span> hints<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//生成二维码图片流</span>                BufferedImage bufferedImage <span class="token operator">=</span> MatrixToImageWriter<span class="token punctuation">.</span><span class="token function">toBufferedImage</span><span class="token punctuation">(</span>bitMatrix<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//输出流</span>                ImageIO<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bufferedImage<span class="token punctuation">,</span> <span class="token string">"png"</span><span class="token punctuation">,</span> os<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">/**                 * 原生转码前面没有 data:image/png;base64 这些字段，返回给前端是无法被解析，所以加上前缀                 */</span>                resultImage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"data:image/png;base64,"</span> <span class="token operator">+</span> EncryptUtil<span class="token punctuation">.</span><span class="token function">encodeBase64</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> resultImage<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"生成二维码出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>stream <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    stream<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    stream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        QRCodeUtil qrCodeUtil <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QRCodeUtil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>qrCodeUtil<span class="token punctuation">.</span><span class="token function">createQRCode</span><span class="token punctuation">(</span><span class="token string">"http://localhost:63050/orders/alipaytest"</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行main方法输入二维码图片的base64串，如下：</p><pre class=" language-bash"><code class="language-bash">data:image/png<span class="token punctuation">;</span>base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADIAQAAAACFI5MzAAABXUlEQVR42u2YSY6EMAxFnVWO4ZuS5KY5Rla4PRWgKvWm1VL+oiIkIh4L4+HbgeS3RV/yR7JIVxHpVc46ibjbA8YgrCYOvRYrHL63hxikEwfRL2i2oYJFZls8Yo9HikwL+8Ii4u7UNDwU1fc82EroZWxeb/Wzk7zWWaX7Kx+6s4+4L+8gLzoqDLHY0kF8mskqgZaSbTEG0Tv5slohr2DNRwwSvULvU32ptketQJBoFBZqleTZ3KNHdrPdxI0VT8Nh+9mioWEQU7u7b1DzPQYxDY4gh8m9+ndgkOHJaPJcw6NQJCPsQwr7WwxBPAFLVEmSq352E1flZt3M3KnKd5rGYBBv++UqjhXyLBAklnfals32ruDNJE855s6ycow6q2CQmDpDXTzOUSgY5DrlhFNt5BQkkkdDG/H6YwqAIN7/42gYGgNCnk0jquSZiVtJnnK6aV4oX3az/eT7v+p/yQ/ovSDjCl7mQgAAAABJRU5ErkJggg<span class="token operator">==</span></code></pre><h4 id="支付结果查询接口"><a href="#支付结果查询接口" class="headerlink" title="支付结果查询接口"></a><strong>支付结果查询接口</strong></h4><p>支付完成可以调用第三方支付平台的支付结果查询接口 查询支付结果。</p><p>文档：<a href="https://opendocs.alipay.com/open/02ivbt">https://opendocs.alipay.com/open/02ivbt</a></p><p>示例代码:</p><pre class=" language-java"><code class="language-java">AlipayClient alipayClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultAlipayClient</span><span class="token punctuation">(</span><span class="token string">"https://openapi.alipay.com/gateway.do"</span><span class="token punctuation">,</span><span class="token string">"app_id"</span><span class="token punctuation">,</span><span class="token string">"your private_key"</span><span class="token punctuation">,</span><span class="token string">"json"</span><span class="token punctuation">,</span><span class="token string">"GBK"</span><span class="token punctuation">,</span><span class="token string">"alipay_public_key"</span><span class="token punctuation">,</span><span class="token string">"RSA2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>AlipayTradeQueryRequest request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlipayTradeQueryRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>JSONObject bizContent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>bizContent<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"out_trade_no"</span><span class="token punctuation">,</span> <span class="token string">"20150320010101001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//bizContent.put("trade_no", "2014112611001004680073956707");</span>request<span class="token punctuation">.</span><span class="token function">setBizContent</span><span class="token punctuation">(</span>bizContent<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>AlipayTradeQueryResponse response <span class="token operator">=</span> alipayClient<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>刚才订单付款成功，可以使用out_trade_no商品订单号或支付宝的交易流水号trade_no去查询支付结果。</p><p>out_trade_no商品订单号: 是在下单请求时指定的商品订单号。</p><p>支付宝的交易流水号trade_no：是支付完成后支付宝通知支付结果时发送的trade_no</p><p>我们使用out_trade_no商品订单号去查询，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"getOrder"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> AlipayApiException <span class="token punctuation">{</span>        AlipayClient alipayClient <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultAlipayClient</span><span class="token punctuation">(</span>AlipayConfig<span class="token punctuation">.</span>URL<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>APPID<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>RSA_PRIVATE_KEY<span class="token punctuation">,</span> AlipayConfig<span class="token punctuation">.</span>FORMAT<span class="token punctuation">,</span> AlipayConfig<span class="token punctuation">.</span>CHARSET<span class="token punctuation">,</span>                AlipayConfig<span class="token punctuation">.</span>ALIPAY_PUBLIC_KEY<span class="token punctuation">,</span>AlipayConfig<span class="token punctuation">.</span>SIGNTYPE<span class="token punctuation">)</span><span class="token punctuation">;</span>        AlipayTradeQueryRequest request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AlipayTradeQueryRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JSONObject bizContent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        bizContent<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"out_trade_no"</span><span class="token punctuation">,</span> <span class="token string">"20150320010101002"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//bizContent.put("trade_no", "2014112611001004680073956707");</span>        request<span class="token punctuation">.</span><span class="token function">setBizContent</span><span class="token punctuation">(</span>bizContent<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AlipayTradeQueryResponse response <span class="token operator">=</span> alipayClient<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>响应如下:</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"alipay_trade_query_response"</span><span class="token operator">:</span><span class="token punctuation">{</span><span class="token property">"code"</span><span class="token operator">:</span><span class="token string">"10000"</span><span class="token punctuation">,</span>                                <span class="token property">"msg"</span><span class="token operator">:</span><span class="token string">"Success"</span><span class="token punctuation">,</span>                                <span class="token property">"buyer_logon_id"</span><span class="token operator">:</span><span class="token string">"drf***@sandbox.com"</span><span class="token punctuation">,</span>                                <span class="token property">"buyer_pay_amount"</span><span class="token operator">:</span><span class="token string">"0.00"</span><span class="token punctuation">,</span>                                <span class="token property">"buyer_user_id"</span><span class="token operator">:</span><span class="token string">"2088102180608143"</span><span class="token punctuation">,</span>                                <span class="token property">"buyer_user_type"</span><span class="token operator">:</span><span class="token string">"PRIVATE"</span><span class="token punctuation">,</span>                                <span class="token property">"invoice_amount"</span><span class="token operator">:</span><span class="token string">"0.00"</span><span class="token punctuation">,</span>                                <span class="token property">"out_trade_no"</span><span class="token operator">:</span><span class="token string">"20150320010101002"</span><span class="token punctuation">,</span>                                <span class="token property">"point_amount"</span><span class="token operator">:</span><span class="token string">"0.00"</span><span class="token punctuation">,</span>                                <span class="token property">"receipt_amount"</span><span class="token operator">:</span><span class="token string">"0.00"</span><span class="token punctuation">,</span>                                <span class="token property">"send_pay_date"</span><span class="token operator">:</span><span class="token string">"2023-03-23 21:43:38"</span><span class="token punctuation">,</span>                                <span class="token property">"total_amount"</span><span class="token operator">:</span><span class="token string">"88.88"</span><span class="token punctuation">,</span>                                <span class="token property">"trade_no"</span><span class="token operator">:</span><span class="token string">"2023032322001408140511381202"</span><span class="token punctuation">,</span>                                <span class="token property">"trade_status"</span><span class="token operator">:</span><span class="token string">"TRADE_SUCCESS"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token property">"sign"</span><span class="token operator">:</span><span class="token string">"doZWWCAMJsxnOc12zHXFLCf2JrjgTjk7Qi2PnHld7EWDQZvhbUbR+3utVlX/S1G0Dh/SAWkNKd518xzQ+I3+LsGy4pF+BLR0vJzFUzZ8Ou13gjwxcjCBmUWBxdudRbTbtLaugZdBjPpxIn7+APuQYdIPuB/NLepUNqamkK4Zb+m7djtv81u13xlXjnFL/kXSUe2DEDtSlJj4LoZHiE6UrCph+Sqs70pD0vjbXP777NhqcugtK7hbpFhTpWfCCFDdL37nPS67ArwLpwo0HiGdbGyBiPYPKG1wkoJd7HmBI8xdZ6vF1LqNeXK5DWwp1STlX2+YWbPEBX37lBwmY9Ha4w=="</span><span class="token punctuation">}</span></code></pre><p>参考文档<a href="https://opendocs.alipay.com/open/02ivbt">https://opendocs.alipay.com/open/02ivbt</a> 查阅每个参数的意义。</p><p>我们主要需要下边的参数：</p><p>“out_trade_no” : “20220520010101026”,</p><p>“trade_no”:”2022100422001422760505740639” ： 支付宝交易流水号</p><p>“total_amount” : “1.30”</p><p>“trade_status” : “TRADE_SUCCESS”： 交易状态</p><p>交易状态类型：</p><p>交易状态：WAIT_BUYER_PAY（交易创建，等待买家付款）</p><p>TRADE_CLOSED（未付款交易超时关闭，或支付完成后全额退款）</p><p>TRADE_SUCCESS（交易支付成功）</p><p>TRADE_FINISHED（交易结束，不可退款）</p><h4 id="支付结果通知接口"><a href="#支付结果通知接口" class="headerlink" title="支付结果通知接口"></a><strong>支付结果通知接口</strong></h4><p>对于手机网站支付产生的交易，支付宝会根据原始支付 API 中传入的异步通知地址 notify_url，通过 POST 请求的形式将支付结果作为参数通知到商户系统。详情可查看 <a href="https://opendocs.alipay.com/support/01raw4">支付宝异步通知说明</a> 。</p><p>文档：<a href="https://opendocs.alipay.com/open/203/105286">https://opendocs.alipay.com/open/203/105286</a></p><p>根据下单执行流程，订单服务收到支付结果需要对内容进行验签，验签过程如下：</p><ol><li><p>在通知返回参数列表中，除去sign、sign_type两个参数外，凡是通知返回回来的参数皆是待验签的参数。将剩下参数进行 url_decode，然后进行字典排序，组成字符串，得到待签名字符串； 生活号异步通知组成的待验签串里需要保留 sign_type 参数。</p></li><li><p>将签名参数（sign）使用 base64 解码为字节码串；</p></li><li><p>使用 RSA 的验签方法，通过签名字符串、签名参数（经过 base64 解码）及支付宝公钥验证签名。</p></li><li><p>验证签名正确后，必须再严格按照如下描述校验通知数据的正确性。</p></li></ol><p>在上述验证通过后，商户必须根据支付宝不同类型的业务通知，正确的进行不同的业务处理，并且过滤重复的通知结果数据。</p><p>通过验证out_trade_no、total_amount、appid参数的正确性判断通知请求的合法性。</p><p>验证的过程可以参考sdk demo代码，下载 sdk demo代码，<a href="https://opendocs.alipay.com/open/203/105910">https://opendocs.alipay.com/open/203/105910</a></p><p><strong>编写测试代码</strong></p><p>1、在下单请求时设置通知地址request.setNotifyUrl(“商户自己的notify_url地址”);</p><pre class=" language-java"><code class="language-java"><span class="token function">PostMapping</span><span class="token punctuation">(</span><span class="token string">"/paynotify"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">paynotify</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">)</span> <span class="token keyword">throws</span> UnsupportedEncodingException<span class="token punctuation">,</span> AlipayApiException <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> params <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Map requestParams <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getParameterMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Iterator iter <span class="token operator">=</span> requestParams<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String name <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span> iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> requestParams<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        String valueStr <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> values<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            valueStr <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> values<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> valueStr <span class="token operator">+</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                    <span class="token operator">:</span> valueStr <span class="token operator">+</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">","</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//乱码解决，这段代码在出现乱码时使用。如果mysign和sign不相等也可以使用这段代码转化</span>        <span class="token comment" spellcheck="true">//valueStr = new String(valueStr.getBytes("ISO-8859-1"), "gbk");</span>        params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> valueStr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//商户订单号</span>    String out_trade_no <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"out_trade_no"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//支付宝交易号</span>    String trade_no <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"trade_no"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//交易状态</span>    String trade_status <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"trade_status"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"ISO-8859-1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取支付宝的通知返回参数，可参考技术文档中页面跳转同步通知参数列表(以上仅供参考)//</span>    <span class="token comment" spellcheck="true">//计算得出通知验证结果</span>    <span class="token comment" spellcheck="true">//boolean AlipaySignature.rsaCheckV1(Map&lt;String, String> params, String publicKey, String charset, String sign_type)</span>    <span class="token keyword">boolean</span> verify_result <span class="token operator">=</span> AlipaySignature<span class="token punctuation">.</span><span class="token function">rsaCheckV1</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> ALIPAY_PUBLIC_KEY<span class="token punctuation">,</span> CHARSET<span class="token punctuation">,</span> <span class="token string">"RSA2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>verify_result<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//验证成功</span>        <span class="token comment" spellcheck="true">//////////////////////////////////////////////////////////////////////////////////////////</span>        <span class="token comment" spellcheck="true">//请在这里加上商户的业务逻辑程序代码</span>        <span class="token comment" spellcheck="true">//——请根据您的业务逻辑来编写程序（以下代码仅作参考）——</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>trade_status<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"TRADE_FINISHED"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//交易结束</span>            <span class="token comment" spellcheck="true">//判断该笔订单是否在商户网站中已经做过处理</span>            <span class="token comment" spellcheck="true">//如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序</span>            <span class="token comment" spellcheck="true">//请务必判断请求时的total_fee、seller_id与通知时获取的total_fee、seller_id为一致的</span>            <span class="token comment" spellcheck="true">//如果有做过处理，不执行商户的业务程序</span>            <span class="token comment" spellcheck="true">//注意：</span>            <span class="token comment" spellcheck="true">//如果签约的是可退款协议，退款日期超过可退款期限后（如三个月可退款），支付宝系统发送该交易状态通知</span>            <span class="token comment" spellcheck="true">//如果没有签约可退款协议，那么付款完成后，支付宝系统发送该交易状态通知。</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>trade_status<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"TRADE_SUCCESS"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//交易成功</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>trade_status<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//判断该笔订单是否在商户网站中已经做过处理</span>            <span class="token comment" spellcheck="true">//如果没有做过处理，根据订单号（out_trade_no）在商户网站的订单系统中查到该笔订单的详细，并执行商户的业务程序</span>            <span class="token comment" spellcheck="true">//请务必判断请求时的total_fee、seller_id与通知时获取的total_fee、seller_id为一致的</span>            <span class="token comment" spellcheck="true">//如果有做过处理，不执行商户的业务程序</span>            <span class="token comment" spellcheck="true">//注意：</span>            <span class="token comment" spellcheck="true">//如果签约的是可退款协议，那么付款完成后，支付宝系统发送该交易状态通知。</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="通知接口测试"><a href="#通知接口测试" class="headerlink" title="通知接口测试"></a><strong>通知接口测试</strong></h4><p>1、重启订单服务，并在下单接口中打上断点</p><p>2、配置内网穿透的本地端口为订单服务端口，启动内网穿透客户端。</p><p>3、打开模拟器、支付宝沙箱，扫码、支付。</p><p>4、观察下单接口断点处的执行情况、接收数据等是否正常。</p><h3 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战:"></a>项目实战:</h3><p>点击“支付宝支付”此时打开支付二维码，用户扫码支付。</p><p>所以首先需要生成支付二维码，用户扫描二维码开始请求支付宝下单，在向支付宝下单前需要添加选课记录、创建商品订单、生成支付交易记录。</p><p>生成二维码执行流程如下：</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323223103719.png" alt="image-20230323223103719"></p><p>执行流程：</p><p>1、前端调用学习中心服务的添加选课接口。</p><p>2、添加选课成功请求订单服务生成支付二维码接口。</p><p>3、生成二维码接口：创建商品订单、生成支付交易记录、生成二维码。</p><p>4、将二维码返回到前端，用户扫码。</p><p>用户扫码支付流程如下：</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323230516623.png" alt="image-20230323230516623"></p><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>订单支付模式的核心由三张表组成：订单表、订单明细表、支付交易记录表。</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323230553795.png" alt="image-20230323230553795"></p><p>订单表：记录订单信息</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230323230610490.png" alt="image-20230323230610490"></p><p>三张表之间的关系就是订单表和订单明细表是一对多的关系。然后我们的订单记录表和订单表也是一对多的关系。</p><p>因为我们发起支付宝的请求页面需要将我们的订单信息发送给我们的支付宝页面，如果是将我们的订单id发送过去的话，有可能会造成支付中断，导致再次将订单id发送过去，有可能会导致该订单Id支付不成功，因为你发送过一次支付了，再次支付有可能会出现一些问题。所以一般我们是将订单记录发送过去。</p><p>订单号注意唯一性、安全性、尽量短等特点，生成方案常用的如下：</p><p>1、时间戳+随机数</p><p>年月日时分秒毫秒+随机数</p><p>2、高并发场景</p><p>年月日时分秒毫秒+随机数+redis自增序列</p><p>3、订单号中加上业务标识</p><p>订单号加上业务标识方便客服，比如：第10位是业务类型，第11位是用户类型等。</p><p>4、雪花算法</p><p>雪花算法是推特内部使用的分布式环境下的唯一ID生成算法，它基于时间戳生成，保证有序递增，加以入计算机硬件等元素，可以满足高并发环境下ID不重复。</p><p>1位的符号位、32位的时间戳、12位的机器码</p><p>本项目订单号生成采用雪花算法。</p><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a><strong>接口定义</strong></h4><p>在订单服务中定义生成支付二维码接口。</p><p>请求：订单信息</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2023/03/22/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/03/22/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式:"></a>单例模式:</h2><p>单例模式(Singleton Pattern)是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h3 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a><strong>单例模式的结构</strong></h3><p>单例模式的主要有以下角色:</p><ul><li>单例类:只能创建一个实例的类</li><li>访问类:使用单例类</li></ul><h3 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h3><p>单例类的实现主要分为两种实现方式:</p><ul><li>饿汉式:在类加载的时候，就会去创建对象</li><li>懒汉式:类加载的时候不会导致该实例被创建，而是首次使用该对象时才会被创建</li></ul><h3 id="1、饿汉式-静态变量方式"><a href="#1、饿汉式-静态变量方式" class="headerlink" title="1、饿汉式-静态变量方式"></a>1、饿汉式-静态变量方式</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 单例模式<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/14 * 单例模式 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 单例模式主要分为     * 恶汉式: 在类加载的时候，就回去创建该对象     * 懒汉式:在我们真正去实现它时才会去创建对象     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton INSTANCE<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。 instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p><h3 id="2-饿汉式-静态代码块方式"><a href="#2-饿汉式-静态代码块方式" class="headerlink" title="2 饿汉式-静态代码块方式"></a>2 饿汉式-静态代码块方式</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 恶汉式* 在静态代码块中创建该类对象 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//私有构造方法</span><span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//在成员位置创建该类的对象</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//对外提供静态方法获取该对象</span><span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说明:</p><p>该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着 类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</p><h3 id="3、懒汉式-线程不安全"><a href="#3、懒汉式-线程不安全" class="headerlink" title="3、懒汉式 线程不安全"></a>3、懒汉式 线程不安全</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 懒汉式* 线程不安全 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//私有构造方法</span><span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//在成员位置创建该类的对象</span><span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对外提供静态方法获取该对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说明:</p><p>从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的 赋值操作，那么什么时候赋值的呢?当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p><h3 id="4、懒汉式-线程安全："><a href="#4、懒汉式-线程安全：" class="headerlink" title="4、懒汉式 线程安全："></a>4、懒汉式 线程安全：</h3><p>使用synchronized来解决线程安全:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 懒汉式* 线程安全 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//私有构造方法</span><span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//在成员位置创建该类的对象</span><span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对外提供静态方法获取该对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个是可以解决我们的线程安全的问题，但是会存在一个锁的粒度会很高，导致我们的程序的性能不是很好，可以使用双重检索的方式来进行解决.</p><h3 id="5、懒汉式-双重检查锁"><a href="#5、懒汉式-双重检查锁" class="headerlink" title="5、懒汉式 -双重检查锁"></a>5、懒汉式 -双重检查锁</h3><p>对于上面的操作加锁问题，我们单例模式应该是一个读多写少的问题。所以针对这个问题，我们可以改造我们的代码:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">DoubleSingleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//volatile保证我们不会受到可见性的影响。</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> DoubleSingleton instance<span class="token punctuation">;</span>    <span class="token keyword">public</span> DoubleSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第一次进行校验</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//会出现线程安全的问题</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p><p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 volatile 关键字, volatile 关 键字可以保证可见性和有序性。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">DoubleSingleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//volatile保证我们不会受到可见性的影响。</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> DoubleSingleton instance<span class="token punctuation">;</span>    <span class="token keyword">public</span> DoubleSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第一次进行校验</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//会出现线程安全的问题</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><p>添加 volatile 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程 的情况下线程安全也不会有性能问题。</p><h3 id="6、懒汉式-静态内部类"><a href="#6、懒汉式-静态内部类" class="headerlink" title="6、懒汉式 -静态内部类"></a>6、懒汉式 -静态内部类</h3><p>静态内部类单例模式中实例有内部类创建，由于JVM在类加载的过程中，是不会加载静态内部类的，只有内部类的属性&#x2F;方法被调用时才会被加载，并初始化其静态属性。静态属性由于被static修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHandler</span><span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> SingletonHandler<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说明:</p><p>第一次类记载的时候，不会去初始化的我们的静态内部类的，只有第一次调用getInstance,虚拟机加载SingletonHander，并初始化。</p><p>小结:<br> 静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任<br> 何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题:"></a>存在的问题:</h3><p>1、怎么破坏单例模式:</p><p>使上面定义的单例类(Singleton)可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。</p><p>序列化反序列化</p><p>Singleton类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//私有构造方法</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//对外提供静态方法获取该对象</span><span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Test类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//往文件中写对象</span><span class="token comment" spellcheck="true">//writeObject2File(); //从文件中读取对象</span>        Singleton s1 <span class="token operator">=</span> <span class="token function">readObjectFromFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Singleton s2 <span class="token operator">=</span> <span class="token function">readObjectFromFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断两个反序列化后的对象是否是同一个对象</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton <span class="token function">readObjectFromFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//创建对象输入流对象</span>        ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span>                <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\Think\\Desktop\\a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//第一个读取Singleton对象</span>        Singleton instance <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writeObject2File</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//获取Singleton类的对象</span>        Singleton instance <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建对象输出流</span>        ObjectOutputStream oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span>                <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\Think\\Desktop\\a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将instance对象写出到文件中</span>        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面代码运行结果是 false ，表明序列化和反序列化已经破坏了单例设计模式。</p><p>2、可以通过我们的暴力反射可以破解我们的单例模式</p><p>Singleton类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">DoubleSingleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//volatile保证我们不会受到可见性的影响。</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> DoubleSingleton instance<span class="token punctuation">;</span>    <span class="token keyword">public</span> DoubleSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第一次进行校验</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//会出现线程安全的问题</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><p>Test类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//获取Singleton类的字节码对象</span>        Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//获取Singleton类的私有无参构造方法对象</span>        Constructor constructor <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//取消访问检查</span>        constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建Singleton类的对象s1</span>        Singleton s1 <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建Singleton类的对象s2</span>        Singleton s2 <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断通过反射创建的两个Singleton对象是否是同一个对象</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span><span class="token punctuation">}</span></code></pre><h3 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决:"></a>问题的解决:</h3><p>1、序列化、反序列化方式破解我们的单例模式的解决方法:</p><p>在Singleton类中添加 readResolve() 方法，在反序列化时被反射调用，如果定义了这个方法， 就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 下面是为了解决序列化反序列化破解单例模式 */</span><span class="token keyword">private</span> Object <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2、反射方式破解单例的解决方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//私有构造方法</span><span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>就是使用异常的方式来进行解决.</p><p>说明: 这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操</p><p>作。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2021/07/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/07/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h3><p>需求:设计一个咖啡店点餐系统。</p><p>设计一个咖啡类(Coffee)，并定义其两个子类(美式咖啡【AmericanCoffee】和拿铁咖啡 【LatteCoffee】);再设计一个咖啡店类(CoffeeStore)，咖啡店具有点咖啡的功能。</p><p>具体类的设计如下:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230322222915518.png" alt="image-20230322222915518"></p><p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。 如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象， 直接在工厂里更换该对象即可，达到了与对象解耦的目的;所以说，工厂模式最大的优点就是:<strong>解耦</strong>。</p><p>在本教程中会介绍三种工厂的使用</p><ul><li>简单工厂模式(不属于GOF的23种经典设计模式) </li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式:"></a>简单工厂模式:</h3><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构:"></a>结构:</h3><p>简单工厂包含如下角色:</p><ul><li>抽象产品:定义了产品的规范，描述了产品的主要特性和功能</li><li>具体产品:实现或者继承了抽象类产品的子类</li><li>具体工厂:提供了创建产品的方法，调用者通过该方法来获取产品。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h3><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230322222915518.png" alt="image-20230322222915518"></p><p>工厂类代码如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleCoffeeFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Coffee <span class="token function">createCoffee</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Coffee coffee <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"americano"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            coffee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmericanoCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"latte"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            coffee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LatteCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> coffee<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>工厂(factory)处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的 orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就 解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和 SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p><p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修 改操作。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><p>优点:</p><p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避<br>免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户<br>代码修改的可能性，更加容易扩展。</p><p>缺点:</p><p>每次添加新的产品时，都需要去我们的工厂类中添加代码，违背了”开背原则”。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a><strong>工厂方法模式</strong></h3><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延</p><p>迟到其工厂的子类。</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a><strong>结构</strong></h3><p>工厂方法模式的主要角色:</p><ul><li>抽象工厂(Abstract Factory):提供了创建产品的接口，调用者通过它访问具体工厂的工厂 方法来创建产品。 </li><li>具体工厂(ConcreteFactory):主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 </li><li>抽象产品(Product):定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品(ConcreteProduct):实现了抽象产品角色所定义的接口，由具体工厂来创建，它同 具体工厂之间一一对应。</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a><strong>实现</strong></h3><p>使用工厂方法模式对上例进行改进，类图如下:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230322223844656.png" alt="image-20230322223844656"></p><p>代码如下: </p><p>抽象工厂:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">{</span>    Coffee <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>具体工厂:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LatteCoffeeFactory</span> <span class="token keyword">implements</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Coffee <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LatteCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AmericanCoffeeFactory</span> <span class="token keyword">implements</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Coffee <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AmericanCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>咖啡店类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CoffeeStore</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> CoffeeFactory factory<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CoffeeStore</span><span class="token punctuation">(</span>CoffeeFactory factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>factory <span class="token operator">=</span> factory<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Coffee <span class="token function">orderCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Coffee coffee <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coffee<span class="token punctuation">.</span><span class="token function">addMilk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coffee<span class="token punctuation">.</span><span class="token function">addsugar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> coffee<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，<br>这样就解决了简单工厂模式的缺点。<br>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的<br>优点，而且克服了它的缺点。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程;</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，<br>满足开闭原则;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-动态监控进程</title>
      <link href="/2021/06/13/linux-%E5%8A%A8%E6%80%81%E7%9B%91%E6%8E%A7/"/>
      <url>/2021/06/13/linux-%E5%8A%A8%E6%80%81%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>top 与 ps 命令很相似。它们都用来显示正在执行的进程。Top 与 ps 最大的不同之处，在于 top 在执行一段时间可以更新正在运行的的进程。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre class=" language-linux"><code class="language-linux">top [选项]</code></pre><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt="截图"></p><p> 选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d 秒数</td><td>指定top命令每隔几秒进行刷新.默认是3秒</td></tr><tr><td>-i</td><td>使top不显示任何闲置或者僵死进程</td></tr><tr><td>-p</td><td>通过指定监控id来仅仅监控某个进程的状态.</td></tr></tbody></table><p> 交互操作说明：</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以cpu使用率排序,默认就是此项</td></tr><tr><td>M</td><td>以内存的使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>q</td><td>退出操作</td></tr></tbody></table><p>应用实例<br>案例 1.监视特定用户, 比如我们监控 tom 用户</p><pre class=" language-linux"><code class="language-linux">top：输入此命令，按回车键，查看执行的进程。u：然后输入“u”回车，再输入用户名，即可,</code></pre><p>案例 2：终止指定的进程, 比如我们要结束 tom 登录</p><pre class=" language-linux"><code class="language-linux">top：输入此命令，按回车键，查看执行的进程。k：然后输入“k”回车，再输入要结束的进程 ID 号</code></pre><p>案例 3:指定系统状态更新的时间(每隔 10 秒自动更新), 默认是 3 秒</p><pre class=" language-linux"><code class="language-linux">top -d 10</code></pre><h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><p>查看系统网络情况 netstat</p><p>基本语法</p><pre class=" language-linux"><code class="language-linux">netstat [选项]</code></pre><p>选项说明</p><pre class=" language-linux"><code class="language-linux">-an 按一定顺序排列输出-p 显示哪个进程在调用</code></pre><p>应用案例<br>请查看服务名为 sshd 的服务的信息。</p><pre class=" language-linux"><code class="language-linux">netstat -anp | grep sshd</code></pre><h3 id="检测主机连接命令-ping："><a href="#检测主机连接命令-ping：" class="headerlink" title="检测主机连接命令 ping："></a>检测主机连接命令 ping：</h3><p>是一种网络检测工具，它主要是用检测远程主机是否正常，或是两部主机间的网线或网卡故障。<br>如: ping 对方 ip 地址</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-服务管理</title>
      <link href="/2021/06/09/linux-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2021/06/09/linux-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="linux服务管理"><a href="#linux服务管理" class="headerlink" title="linux服务管理"></a>linux服务管理</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍:"></a>介绍:</h4><p>服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysqld , sshd防火墙等)，因此我们又称为守护进程，是 Linux 中非常重要的知识点。</p><h4 id="service-管理指令"><a href="#service-管理指令" class="headerlink" title="service 管理指令"></a>service 管理指令</h4><ol><li>service 服务名 [start | stop | restart | reload | status]</li><li>在 CentOS7.0 后 很多服务不再使用 service ,而是 systemctl</li><li>service 指令管理的服务在 &#x2F;etc&#x2F;init.d 查看</li></ol><h4 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名:"></a>查看服务名:</h4><p><strong>使用 setup -&gt; 系统服务 就可以看到全部。（作用可以在setup中更改开机即启动的服务）</strong></p><h4 id="服务的运行级别-runlevel"><a href="#服务的运行级别-runlevel" class="headerlink" title="服务的运行级别(runlevel):"></a>服务的运行级别(runlevel):</h4><p>Linux 系统有 7 种运行级别(runlevel)：常用的是 级别 3 和 和 5</p><p>Linux 系统有 7 种运行级别(runlevel)：常用的是 级别 3 和 和 5<br>运行级别 0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动<br>运行级别 1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆<br>运行级别 2：多用户状态(没有 NFS)，不支持网络<br>运行级别 3：完全的多用户状态(有 NFS)，无界面，登陆后进入控制台命令行模式<br>运行级别 4：系统未使用，保留<br>运行级别 5：X11 控制台，登陆后进入图形 GUI 模式<br>运行级别 6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动</p><h4 id="CentOS7-后运行级别说明"><a href="#CentOS7-后运行级别说明" class="headerlink" title="CentOS7 后运行级别说明"></a>CentOS7 后运行级别说明</h4><p>在 &#x2F;etc&#x2F;initab进行了简化 ，如下:</p><pre class=" language-linux"><code class="language-linux">multi-user.target: analogous to runlevel 3graphical.target: analogous to runlevel 5#查看当前级别systemctl get-default#修改运行级别systemctl set-default TARGET.target</code></pre><h4 id="chkconfig-指令"><a href="#chkconfig-指令" class="headerlink" title="chkconfig 指令"></a>chkconfig 指令</h4><p>通过 chkconfig 命令可以给服务的各个运行级别设置自 启动&#x2F;关闭chkconfig 指令管理的服务在 &#x2F;etc&#x2F;init.d 查看<br>注意: Centos7.0 后，很多服务使用 systemctl 管理.</p><p>chkconfig 基本语法</p><pre class=" language-linux"><code class="language-linux">查看服务 chkconfig --list [| grep xxx]chkconfig 服务名 --listchkconfig --level 5 服务名 on/off</code></pre><p>案例演示 : 对 network 服务 进行各种操作, 把 network 在 3 运行级别,关闭自启动</p><pre class=" language-linux"><code class="language-linux">chkconfig --level 3 network offchkconfig --level 3 network on</code></pre><p>使用细节<br>chkconfig 重新设置服务后自启动或关闭，需要重启机器 reboot 生效.</p><h4 id="systemctl-管理指令-重点"><a href="#systemctl-管理指令-重点" class="headerlink" title="systemctl 管理指令(重点)"></a>systemctl 管理指令(重点)</h4><p>基本语法：</p><pre class=" language-linux"><code class="language-linux">systemctl [start | stop | restart | status] 服务名systemctl 指令管理的服务在 /usr/lib/systemd/system 查看</code></pre><p> systemctl 设置服务的自启动状态</p><pre class=" language-bash"><code class="language-bash">systemctl list-unit-files <span class="token punctuation">[</span> <span class="token operator">|</span> <span class="token function">grep</span> 服务名<span class="token punctuation">]</span> <span class="token punctuation">(</span>查看服务开机启动状态, <span class="token function">grep</span> 可以进行过滤<span class="token punctuation">)</span>systemctl <span class="token function">enable</span> 服务名 <span class="token punctuation">(</span>设置服务开机启动<span class="token punctuation">)</span>systemctl disable 服务名 <span class="token punctuation">(</span>关闭服务开机启动<span class="token punctuation">)</span>systemctl is-enabled 服务名 <span class="token punctuation">(</span>查询某个服务是否是自启动的<span class="token punctuation">)</span></code></pre><p>应用案列:</p><p>查看当前防火墙的状况，关闭防火墙和重启防火墙。&#x3D;&gt; firewalld.service<br>systemctl status firewalld; systemctl stop firewalld; systemctl start firewalld</p><h4 id="打开或者关闭指定端口-重点"><a href="#打开或者关闭指定端口-重点" class="headerlink" title="打开或者关闭指定端口(重点)"></a>打开或者关闭指定端口(重点)</h4><p>   在真正的生产环境，往往需要将防火墙打开，但问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。比如 80、22、8080 等，这个又怎么做呢？</p><p>示意图:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/mall/service.png" alt="截图"></p><p> <strong>firewall 指令:</strong></p><ol><li>打开端口: firewall-cmd –permanent –add-port&#x3D;端口号&#x2F;协议</li><li>关闭端口: firewall-cmd –permanent –remove-port&#x3D;端口号&#x2F;协议</li><li>重新载入,才能生效 : firewall-cmd –reload</li><li>查询端口是否开放: firewall-cmd –query-port&#x3D;端口&#x2F;协议</li></ol><p>应用案例：</p><ol><li>启用防火墙， 测试 111 端口是否能 telnet , 不行</li><li>开放 111 端口</li></ol><pre class=" language-linux"><code class="language-linux">firewall-cmd --permanent --add-port=111/tcp ; 需要 firewall-cmd --reload</code></pre><ol start="3"><li>再次关闭 111 端口</li></ol><pre class=" language-linux"><code class="language-linux">firewall-cmd --permanent --remove-port=111/tcp ; 需要 firewall-cmd --reload</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程管理</title>
      <link href="/2021/05/14/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2021/05/14/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="进程管理（重点）"><a href="#进程管理（重点）" class="headerlink" title="进程管理（重点）"></a>进程管理（重点）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>在 LINUX 中，每个执行的程序都称为一个进程。每一个进程都分配一个 ID 号(pid,进程号)。&#x3D;&gt;windows &#x3D;&gt; linux</li><li>每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</li><li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。</li></ol><h4 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h4><p>ps 命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数.</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/image-20210514173753530.png" alt="image-20210514173753530"></p><h4 id="ps-详解"><a href="#ps-详解" class="headerlink" title="ps 详解"></a>ps 详解</h4><ol><li>指令：ps –aux|grep xxx ，比如我看看有没有 sshd 服务</li><li>指令说明<ul><li>System V 展示风格</li><li>USER：用户名称</li><li>PID：进程号</li><li>%CPU：进程占用 CPU 的百分比</li><li>%MEM：进程占用物理内存的百分比</li><li>VSZ：进程占用的虚拟内存大小（单位：KB）</li><li>RSS：进程占用的物理内存大小（单位：KB）</li><li>TT：终端名称,缩写 .</li><li>STAT：进程状态，其中 S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</li><li>STARTED：进程的启动时间</li><li>TIME： CPU 时间，即进程使用 CPU 的总时间</li><li>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</li></ul></li></ol><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>要求：以全格式显示当前所有的进程，查看进程的父进程。 查看 sshd 的父进程信息</p><pre class=" language-linux"><code class="language-linux">ps -ef 是以全格式显示当前所有的进程-e 显示所有进程。-f 全格式ps -ef|grep sshdroot       942     1  0 Mar16 ?        00:02:16 /usr/sbin/sshd -Droot     17779   942  0 17:06 ?        00:00:00 sshd: root@pts/1root     27343   942  0 17:56 ?        00:00:00 sshd: root [priv]sshd     27344 27343  0 17:56 ?        00:00:00 sshd: root [net]是 BSD 风格UID：用户 IDPID：进程 IDPPID：父进程 IDC：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高STIME：进程启动的时间TTY：完整的终端名称TIME：CPU 时间CMD：启动进程所用的命令和参数</code></pre><h4 id="终止进程-kill-和-killall"><a href="#终止进程-kill-和-killall" class="headerlink" title="终止进程 kill 和 killall"></a>终止进程 kill 和 killall</h4><blockquote><p>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用 kill 命令来完成此项任务</p></blockquote><p>基本语法:</p><pre class=" language-linux"><code class="language-linux">kill [选项] 进程号（功能描述：通过进程号杀死/终止进程）killall 进程名称（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）</code></pre><p>常用选项:</p><p>-9 :表示强迫进程立即停止</p><p>应用案例:</p><p>案例 1. ：踢掉某个非法登录用户</p><pre class=" language-linux"><code class="language-linux">kill 进程号 , 比如 kill 11421</code></pre><p>案例 2: 终止远程登录服务 sshd, 在适当时候再次重启 sshd 服务</p><pre class=" language-linux"><code class="language-linux">kill sshd 对应的进程号; /bin/systemctl start sshd.service</code></pre><p>案例 3: 终止多个 gedit , 演示 killall gedit</p><pre class=" language-linux"><code class="language-linux">通过进程的名字来终止进程</code></pre><p>案例 4：强制杀掉一个终端, 指令 kill -9 bash 对应的进程号</p><pre class=" language-linux"><code class="language-linux">kill -9 bash</code></pre><h4 id="查看进程树-pstree"><a href="#查看进程树-pstree" class="headerlink" title="查看进程树 pstree"></a>查看进程树 pstree</h4><p>基本语法</p><pre class=" language-linux"><code class="language-linux">pstree [选项] ,可以更加直观的来看进程信息</code></pre><p>常用选项</p><p>-p :显示进程的 PID<br>-u :显示进程的所属用户</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux组的介绍</title>
      <link href="/2021/04/27/linux%E7%BB%84%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/04/27/linux%E7%BB%84%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="linux组的介绍"><a href="#linux组的介绍" class="headerlink" title="linux组的介绍"></a>linux组的介绍</h3><p>在linux中每个用户必须属于一个组,不能独立于组外。在linux中每个文件有所有组、所在组、其它组的概念</p><ul><li>所有者</li><li>所在组</li><li>其它组</li><li>改变用户所在的组</li></ul><h4 id="文件-x2F-目录-所有者"><a href="#文件-x2F-目录-所有者" class="headerlink" title="文件&#x2F;目录 所有者"></a>文件&#x2F;目录 所有者</h4><p>一般为文件的创建者,谁创建了该文件,就自然的称为该文件的所有者</p><ul><li>查看文件的所有者</li></ul><pre class=" language-code"><code class="language-code">指令:ls -ahl</code></pre><ul><li>修改文件的所有者</li></ul><pre class=" language-code"><code class="language-code">指令:chown用户名 文件名案列:chown root txh</code></pre><h4 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h4><pre class=" language-code"><code class="language-code">groupadd 组名</code></pre><p>应用案例:</p><p>创建一个组名tom</p><pre class=" language-code"><code class="language-code">groupadd tom</code></pre><p>将hello.txt加入到该组之中</p><pre class=" language-code"><code class="language-code">useradd -g tom hello.txt</code></pre><p>修改文件所在组</p><p>基本指令:</p><pre class=" language-code"><code class="language-code">chgrp 组名 文件名</code></pre><h4 id="其它组"><a href="#其它组" class="headerlink" title="其它组"></a>其它组</h4><p>除文件的所有者和所在组的用户外,系统的其它用户都是文件的其它组</p><h4 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h4><p>在添加用户时,可以指定将该用户添加到哪个组中,同样的用root的管理权限可以改变某个用户所在的组。</p><ul><li>改变用户所在组</li></ul><p>usermod -g 新组名 用户名</p><p>usermod -d 目录名 用户名 改变该用户登录的初始目录。</p><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><p>ls -l命令的显示的内容如下:</p><pre class=" language-code"><code class="language-code">[txh@VM-0-17-centos home]$ ls -ltotal 20-rw-r--r--  1 root root    0 Apr 23 23:15 cat.txt-rw-r--r--  1 root root   26 Apr 19 22:33 hello.txtdrwxr-xr-x 11 txh  txh  4096 Apr 26 23:23 hexodrwxr-xr-x  2 root root 4096 Apr 26 19:49 kevintam-rw-r--r--  1 root root  125 Apr 23 23:17 pc.tar.gz-rw-r--r--  1 root root    0 Apr 23 23:16 pig.txtdrwx------ 10 txh  txh  4096 Apr 14 14:13 txh</code></pre><p>drwxr-xr-x 0 -9位说明</p><ol><li>第0位说明文件的类型（d,-,l,c,b）</li></ol><ul><li>l是链接,相当于windows的快捷方式</li><li>d是目录,相当于windows的文件夹</li><li>c是字符设备文件,鼠标,键盘</li><li>b是块设备，比如硬盘</li><li>-表示是个普通文件</li></ul><ol start="2"><li>第1-3位确定所有者（该文件的所有者）拥有该文件的权限</li><li>第4-6位确定所属组（同用户组的）拥有该文件的权限</li><li>第7-9位确定其他用户拥有该文件的权限</li></ol><blockquote><p> rwx作用到文件</p></blockquote><p>[r]代表可读(read):可以读取,查看</p><p>[w]代表可写(write):可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限,才能删除该文件。</p><p>[x]代表可执行(execute):可以被执行</p><blockquote><p> rwx作用到目录</p></blockquote><p>[r]代表可读（read）:可以读取,ls查看目录内容</p><p>[w]代表可写（write）:可以修改,对目录内创建+删除+重命名目录</p><p>[x]代表可执行（execute）:可以进行该目录</p><p><strong>案列分析:</strong></p><pre class=" language-code"><code class="language-code">-rw-r--r--  1 root root    0 Apr 23 23:15 cat.txt-表示是一个普通文件rw- 表示文件拥有者权限是读和写r-- 表示同组的用户对该文件拥有读的权限r-- 其他的用户只有读的权限1  文件:表示是硬链接数 目录:表示子目录数+文件数(第一个root)root 表示文件的所有者(第二个root)root 表示文件的所在组0 文件的大小(字节)Apr 23 23:15 表示最后的修改日期cat.txt 文件名</code></pre><h4 id="修改权限-chmod"><a href="#修改权限-chmod" class="headerlink" title="修改权限-chmod"></a>修改权限-chmod</h4><p>基本说明:</p><p>通过chmod指令,可以修改文件或者目录的权限</p><p>第一种方式:+、-、&#x3D;变更权限</p><p>​     u:所有者 g:所在组 o:其他人 a:所有人(u、g、o的总和)</p><ul><li>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件&#x2F;目录</li><li>chmod o+w 文件&#x2F;目录名</li><li>chmod a-x 文件&#x2F;目录名</li></ul><p><strong>注意:&#x3D;直接赋予 -除去权限 +增加权限</strong></p><p>案列:给cat.txt文件的所有者读写执行的权限,在给是在组读执行权限,给其他组读执行权限</p><pre class=" language-code"><code class="language-code">chmod u=rwx,g=rx,o=rx cat.txt</code></pre><p>给cat.txt文件的所有者除去执行的权限,增加组写的权限</p><pre class=" language-code"><code class="language-code">chmod u-x,g+w cat.txt</code></pre><p>第二种方式:通过数字变更权限</p><p>r&#x3D;4 w&#x3D;2 x&#x3D;1 rwx&#x3D;4+2+1&#x3D;7</p><p>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件目录名</p><p>相当于chmod 751 文件目录名</p><h4 id="修改文件所有者-chown"><a href="#修改文件所有者-chown" class="headerlink" title="修改文件所有者-chown"></a>修改文件所有者-chown</h4><p>chown newowner 文件&#x2F;目录 改变所有者</p><p>chown newowner:newgroup 文件&#x2F;目录 改变所有者和所在组 -R 如果是目录 则使其下所有子文件或目录递归生效</p><p>案例演示:</p><p>请将&#x2F;home&#x2F;cat.txt 文件的所有者修改成txh</p><pre class=" language-code"><code class="language-code">chown txh /home/cat.txt</code></pre><h4 id="修改文件所在组-chgrp"><a href="#修改文件所在组-chgrp" class="headerlink" title="修改文件所在组-chgrp"></a>修改文件所在组-chgrp</h4><p>基本介绍:</p><p>chgrp newgroup 文件&#x2F;目录 改变所在组</p><p>案例演示:</p><p>请将&#x2F;home&#x2F;cat.txt 文件的所在组修改成shaolin（少林）</p><pre class=" language-code"><code class="language-code">chgrp shaolin /home/cat.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解压和压缩命令</title>
      <link href="/2021/04/22/%E8%A7%A3%E5%8E%8B%E5%92%8C%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/22/%E8%A7%A3%E5%8E%8B%E5%92%8C%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="解压和压缩命令"><a href="#解压和压缩命令" class="headerlink" title="解压和压缩命令"></a>解压和压缩命令</h3><blockquote><p> 压缩和解压类</p></blockquote><pre class=" language-code"><code class="language-code"> gzip/gunzip 指令</code></pre><p>gzip 用于压缩文件，gunzip用于解压的</p><p>基本语法:</p><pre class=" language-code"><code class="language-code">gzip 文件 (功能描述:压缩文件,只能将文件压缩为*.gz文件)gunzip 文件.gz (解压缩文件命令</code></pre><p>应用实例:</p><p>案列1: gzip压缩,将&#x2F;home下的hello.txt文件进行压缩</p><pre class=" language-linux"><code class="language-linux">gzip /home/hello.txt  #压缩</code></pre><p>案列2:gunzip压缩,将&#x2F;home下的hello.txt.gz文件进行解压缩.</p><pre class=" language-bash"><code class="language-bash">gunzip /home/hello.txt.gz <span class="token comment" spellcheck="true">#解压</span></code></pre><h3 id="zip-x2F-unzip指令"><a href="#zip-x2F-unzip指令" class="headerlink" title="zip&#x2F;unzip指令"></a>zip&#x2F;unzip指令</h3><blockquote><p> zip用于压缩文件，unzip用于解压的，这个在项目打爆发布中很有用.</p></blockquote><p>基本语法:</p><pre class=" language-linux"><code class="language-linux">zip [选项] xxx.zip 将要压缩的内容  （功能描述:压缩文件和目录的命令）unzip [选项] xxx.zip (功能描述:解压缩文件)</code></pre><p>zip常用选项</p><p>-r: 递归压缩，即压缩目录</p><p>unzip的常用选项</p><p>-d &lt;目录&gt;:指定解压后文件的存放目录</p><p>案例:</p><p>案例一:将&#x2F;home下的所有文件&#x2F;进行压缩成myhome.zip</p><pre class=" language-linux"><code class="language-linux">zip -r myhome/  </code></pre><p>案例二:将myhome.zip压缩到&#x2F;opt&#x2F;temp下.</p><pre class=" language-linux"><code class="language-linux">unzip -d /opt/temp myhome.zip  </code></pre><h3 id="tar指令-最常用的命令"><a href="#tar指令-最常用的命令" class="headerlink" title="tar指令(最常用的命令)"></a>tar指令(最常用的命令)</h3><p>tar指令是打包指令,最后打包后的文件是.tar.gz的文件</p><p>基本语法：</p><blockquote><p>tar [选项] xxx.tar.gz 打包的内容  （功能描述:打包目录,压缩后的文件选项说明）</p></blockquote><table><thead><tr><th>选项</th><th align="center">功能</th></tr></thead><tbody><tr><td>-c</td><td align="center">产生.tar打包文件</td></tr><tr><td>-v</td><td align="center">显示详细信息</td></tr><tr><td>-f</td><td align="center">指定压缩后的文件名</td></tr><tr><td>-z</td><td align="center">用gzip对文档进行压缩或解压</td></tr><tr><td>-x</td><td align="center">解包.tar文件</td></tr></tbody></table><p>应用案例：</p><p>案例一:压缩多个文件,将&#x2F;home&#x2F;pig.txt和&#x2F;home&#x2F;cat.txt压缩成pc.tar.gz</p><pre class=" language-linux"><code class="language-linux">[root@VM-0-17-centos home]# tar -zcvf pc.tar.gz cat.txt pig.txtcat.txtpig.txt[root@VM-0-17-centos home]# lscat.txt  hello.txt  hexo  kevintam  pc.tar.gz  pig.txt  txh</code></pre><p>案例二：将&#x2F;home的文件夹压缩成myhome.tar.gz</p><pre class=" language-linux"><code class="language-linux">[root@VM-0-17-centos home]# tar -zcvf myhome.tar.gz /home/ #包括/home</code></pre><p>案例三：将pc.tar.gz解压到当前目录.</p><pre class=" language-linux"><code class="language-linux">[root@VM-0-17-centos home]# tar -zxvf pc.tar.gz cat.txtpig.txt[root@VM-0-17-centos home]# lscat.txt  hello.txt  hexo  kevintam  pc.tar.gz  pig.txt  txh</code></pre><p>案例四：将myhome.tar.gz 解压到&#x2F;opt&#x2F;temm目录下</p><pre class=" language-linux"><code class="language-linux">tar -zxvf /home/myhome.tar.gz -C /opt/tem2</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>走进linux系统</title>
      <link href="/2021/04/18/%E8%B5%B0%E8%BF%9Blinux%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/04/18/%E8%B5%B0%E8%BF%9Blinux%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="走近Linux系统"><a href="#走近Linux系统" class="headerlink" title="走近Linux系统"></a>走近Linux系统</h2><blockquote><p>开机登录</p></blockquote><p>开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p><p>开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！</p><p>一般来说，用户的登录方式有三种：</p><ul><li>命令行登录</li><li>ssh登录</li><li>图形界面登录</li></ul><p>最高权限账户为 root，可以操作一切！</p><blockquote><p>关机</p></blockquote><p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>关机指令为：shutdown ；</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sync</span> <span class="token comment" spellcheck="true"># 将数据由内存同步到硬盘中。</span><span class="token function">shutdown</span> <span class="token comment" spellcheck="true"># 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><span class="token function">shutdown</span> –h 10 <span class="token comment" spellcheck="true"># 这个命令告诉大家，计算机将在10分钟后关机</span><span class="token function">shutdown</span> –h now <span class="token comment" spellcheck="true"># 立马关机</span><span class="token function">shutdown</span> –h 20:25 <span class="token comment" spellcheck="true"># 系统会在今天20:25关机</span><span class="token function">shutdown</span> –h +10 <span class="token comment" spellcheck="true"># 十分钟后关机</span><span class="token function">shutdown</span> –r now <span class="token comment" spellcheck="true"># 系统立马重启</span><span class="token function">shutdown</span> –r +10 <span class="token comment" spellcheck="true"># 系统十分钟后重启</span><span class="token function">reboot</span> <span class="token comment" spellcheck="true"># 就是重启，等同于 shutdown –r now</span>halt <span class="token comment" spellcheck="true"># 关闭系统，等同于shutdown –h now 和 poweroff</span></code></pre><p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p><blockquote><p>系统目录结构</p></blockquote><p>登录系统后，在当前命令窗口下输入命令：</p><pre class=" language-linux"><code class="language-linux">ls /</code></pre><p>你会看到如下图所示：</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/linux.JPG" alt="图片"></p><p>树状目录结构：（Linux的一切资源都挂载在这个 &#x2F; 根节点下）</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="图片"></p><p><strong>以下是对这些目录的解释：</strong></p><ul><li>&#x2F;bin(常用)：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li>&#x2F;boot：(常用) 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li>&#x2F;dev: dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li>&#x2F;etc(常用) :这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li><li>&#x2F;home(常用)：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li>&#x2F;lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</li><li>&#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li>&#x2F;media(常用)： linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li>&#x2F;mnt(常用)：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</li><li>&#x2F;opt(常用)：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li>&#x2F;proc[不能动]：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li><li>&#x2F;root：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li>&#x2F;sbin： s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li>&#x2F;srv[不能动]： 该目录存放一些服务启动之后需要提取的数据。</li><li>&#x2F;sys[不能动]：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li><li>&#x2F;tmp： 这个目录是用来存放一些临时文件的。</li><li>&#x2F;usr： 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li><li>&#x2F;usr&#x2F;bin:  系统用户使用的应用程序。</li><li>&#x2F;usr&#x2F;sbin: 超级用户使用的比较高级的管理程序和系统守护程序。</li><li>&#x2F;usr&#x2F;src: 内核源代码默认的放置目录。</li><li>&#x2F;usr&#x2F;local&#x2F;:这是另一个给主机安装软件所安排的目录.一盘是通过编译源码方式来安装的程序</li><li>&#x2F;var(常用)：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li>&#x2F;run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常见的目录命令</title>
      <link href="/2021/04/17/linux%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%AE%E5%BD%95%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/17/linux%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%AE%E5%BD%95%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="常用的基本命令（必掌握）"><a href="#常用的基本命令（必掌握）" class="headerlink" title="常用的基本命令（必掌握）"></a>常用的基本命令（必掌握）</h3><h4 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h4><h4 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h4><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 &#x2F;。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="网图"></p><p><strong>绝对路径：</strong></p><p>路径的写法，由根目录 &#x2F; 写起，例如：&#x2F;usr&#x2F;share&#x2F;doc 这个目录。</p><p><strong>相对路径：</strong></p><p>路径的写法，不是由 &#x2F; 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成：cd ..&#x2F;man 这就是相对路径的写法啦！</p><h4 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h4><p>接下来我们就来看几个常见的处理目录的命令吧：</p><ul><li>ls: 列出目录</li><li>cd：切换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><h4 id="ls-（列出目录）"><a href="#ls-（列出目录）" class="headerlink" title="ls （列出目录）"></a>ls （列出目录）</h4><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><pre><code>[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称</code></pre><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将目录下的所有文件列出来(含属性与隐藏档)</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls -al ~</span></code></pre><h4 id="cd-（切换目录）"><a href="#cd-（切换目录）" class="headerlink" title="cd （切换目录）"></a>cd （切换目录）</h4><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><pre><code>cd [相对路径或绝对路径]</code></pre><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 切换到用户目录下</span><span class="token punctuation">[</span>root@VM-0-17-centos /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd home</span><span class="token comment" spellcheck="true"># 使用 mkdir 命令创建 tom 目录</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir tom</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>kevintam  tom<span class="token comment" spellcheck="true"># 进入  tom 目录</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd tom/</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token comment" spellcheck="true"># 回到上一级</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd ..</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token comment" spellcheck="true"># 回到根目录</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /</span><span class="token punctuation">[</span>root@VM-0-17-centos /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token comment" spellcheck="true"># 表示回到自己的家目录，亦即是 /root 这个目录</span><span class="token punctuation">[</span>root@VM-0-17-centos /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd ~</span><span class="token punctuation">[</span>root@VM-0-17-centos ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span></code></pre><h4 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd ( 显示目前所在的目录 )"></a>pwd ( 显示目前所在的目录 )</h4><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><pre><code>[root@kuangshen kuangstudy]#pwd [-P]</code></pre><p>选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。</p><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 单纯显示出目前的工作目录</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># pwd</span>/home/tom<span class="token comment" spellcheck="true"># 如果是链接，要显示真实地址，可以使用 -P参数</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># pwd -P</span>/home/tom</code></pre><h4 id="mkdir-（创建新目录）"><a href="#mkdir-（创建新目录）" class="headerlink" title="mkdir （创建新目录）"></a>mkdir （创建新目录）</h4><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><pre><code>mkdir [-mp] 目录名称</code></pre><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 进入我们用户目录下</span><span class="token punctuation">[</span>root@VM-0-17-centos /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd home/</span><span class="token comment" spellcheck="true"># 创建一个 test 文件夹</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir test</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>kevintam  <span class="token function">test</span>  tom<span class="token comment" spellcheck="true"># 创建多层级目录</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir test1/test2</span>mkdir: cannot create directory ‘test1/test2’: No such <span class="token function">file</span> or directory<span class="token comment" spellcheck="true"># &lt;== 没办法直接创建此目录啊！</span><span class="token comment" spellcheck="true"># 加了这个 -p 的选项，可以自行帮你创建多层目录！</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir -p  test1/test2</span></code></pre><h4 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir ( 删除空的目录 )"></a>rmdir ( 删除空的目录 )</h4><p>语法：</p><pre><code>rmdir [-p] 目录名称</code></pre><p>选项与参数：**-p ：**连同上一级『空的』目录也一起删除</p><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 看看有多少目录存在？</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls -l</span>total 16drwxr-xr-x 2 root root 4096 Feb 26 14:45 kevintamdrwxr-xr-x 2 root root 4096 Feb 26 14:51 <span class="token function">test</span>drwxr-xr-x 3 root root 4096 Feb 26 14:51 test1drwxr-xr-x 2 root root 4096 Feb 26 14:46 tom<span class="token comment" spellcheck="true"># 可直接删除掉，没问题</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rmdir test</span><span class="token comment" spellcheck="true"># 因为尚有内容，所以无法删除！</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rmdir test1/</span>rmdir: failed to remove ‘test1/’: Directory not empty<span class="token comment" spellcheck="true"># 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rmdir -p test1/test2/</span></code></pre><p>注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录.</p><h4 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp ( 复制文件或目录 )"></a>cp ( 复制文件或目录 )</h4><p>语法：</p><pre><code>[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory</code></pre><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 找一个有文件的目录，我这里找到 root目录</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /root</span><span class="token punctuation">[</span>root@kuangshen ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>install.sh<span class="token punctuation">[</span>root@kuangshen ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /home</span><span class="token comment" spellcheck="true"># 复制 home目录下的hello 到 opt目录下</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp -r hello /opt/</span><span class="token comment" spellcheck="true"># 再次复制，加上-i参数，增加覆盖询问？</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp -r hello /opt/</span>cp: overwrite ‘/opt/hello/hello.txt’? y <span class="token comment" spellcheck="true"># n不覆盖，y为覆盖</span><span class="token comment" spellcheck="true">#不提示是否覆盖</span>\cp -r /root/install.sh /home</code></pre><h4 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm ( 移除文件或目录 )"></a>rm ( 移除文件或目录 )</h4><p>语法：</p><pre><code>rm [-fir] 文件或目录</code></pre><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span><span class="token punctuation">[</span>root@VM-0-17-centos opt<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rm -rf hello</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rm hello.txt </span>rm: remove regular empty <span class="token function">file</span> ‘hello.txt’? y<span class="token comment" spellcheck="true"># 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</span><span class="token comment" spellcheck="true"># 尽量不要在服务器上使用 rm -rf /</span></code></pre><h4 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv  ( 移动文件与目录，或修改名称 )"></a>mv  ( 移动文件与目录，或修改名称 )</h4><p>语法：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mv [-fiu] source destination</span><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mv [options] source1 source2 source3 .... directory</span><span class="token comment" spellcheck="true">#如果是在一个目录下的移动就是重命名</span></code></pre><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 复制一个文件到当前目录</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp /root/install.sh /home</span><span class="token comment" spellcheck="true"># 创建一个文件夹 test</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir test</span><span class="token comment" spellcheck="true"># 将复制过来的文件移动到我们创建的目录，并查看</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mv install.sh test</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span><span class="token function">test</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd test</span><span class="token punctuation">[</span>root@kuangshen test<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>install.sh<span class="token comment" spellcheck="true"># 将文件夹重命名，然后再次查看！</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># touch cat</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mv cat pig</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>kevintam  pig  tom</code></pre><h4 id="创建一个空的文件"><a href="#创建一个空的文件" class="headerlink" title="创建一个空的文件"></a>创建一个空的文件</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">touch</span> <span class="token punctuation">[</span>文件名称<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#指令</span></code></pre><p>测试</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@VM-0-17-centos kevintam<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># touch hello.java</span><span class="token punctuation">[</span>root@VM-0-17-centos kevintam<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>hello.java</code></pre><h4 id="查看文件的内容"><a href="#查看文件的内容" class="headerlink" title="查看文件的内容"></a>查看文件的内容</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token comment" spellcheck="true">#查看文件的内容</span>-n <span class="token comment" spellcheck="true">#显示行号</span><span class="token comment" spellcheck="true">#查看/etc/profile的文件 -n就是查看行号.</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat -n /etc/profile</span><span class="token comment" spellcheck="true"># | more 管道命令 按回车键往下走 输入空格 会直接下一页</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat -n /etc/profile | more</span></code></pre><p>more指令是一个vi编辑的文本过滤器，他以全屏的方式按页显示内容</p><p>more中常见的快捷键</p><ul><li>空格键: 往下翻一页</li><li>enter ：往下走一段</li><li>q：立刻离开</li><li>ctrl+f：向下滚动一屏</li><li>ctrl+b：返回上一屏</li><li>&#x3D;：输出当前行号</li><li>：f  输出当前的行号和文件名</li></ul><p>cat和more通常组合使用</p><h4 id="less-指令"><a href="#less-指令" class="headerlink" title="less 指令"></a>less 指令</h4><p>less指令支持用来分屏查看文件内容。通常使用在大文件的查看</p><p>常用指令：</p><ul><li>空格键:向下翻到一页</li><li>q：离开less指令</li><li>&#x2F;字符：查询字符</li><li>[pagedown]：向下翻动一页</li><li>[pageup]：向上翻动一页</li></ul><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>输出内容到控制台</p><pre class=" language-bash"><code class="language-bash">echo<span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>输出内容<span class="token punctuation">]</span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo $HOSTNAME</span>VM-0-17-centos<span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo "hello world~~"</span>hello world~~</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token function">head</span><span class="token comment" spellcheck="true">#文件的开头</span><span class="token comment" spellcheck="true">#看5行的代码</span><span class="token function">head</span> -n 5<span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># head -n 5 /etc/profile</span><span class="token comment" spellcheck="true"># /etc/profile</span><span class="token comment" spellcheck="true"># System wide environment and startup programs, for login setup</span><span class="token comment" spellcheck="true"># Functions and aliases go in /etc/bashrc</span><span class="token function">tail</span>  -f<span class="token comment" spellcheck="true">#文件尾的内容 实时的监控文件</span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span>和<span class="token operator">>></span>指令<span class="token comment" spellcheck="true">#输出重定向和追加</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo "hello world" > data.txt #会覆盖该文件里的数据</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo "java" >> data.txt #在原数据的基础上会追加内容</span></code></pre><h4 id="查看当前日期"><a href="#查看当前日期" class="headerlink" title="查看当前日期"></a>查看当前日期</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">cal</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cal</span>     March 2021     Su Mo Tu We Th Fr Sa    1  2  3  4  5  6 7  8  9 10 11 12 1314 15 16 17 18 19 2021 22 23 24 25 26 2728 29 30 31</code></pre><h4 id="In指令"><a href="#In指令" class="headerlink" title="In指令"></a>In指令</h4><p>软链接也称为符号链接,类似于windows里的快捷方式,主要存放了链接其他文件的路径</p><p>基本语法</p><pre class=" language-shell"><code class="language-shell">in -s 原文件或目录(功能描述：给原文件创建一个软链接) 连接到的目录</code></pre><p>引用案列</p><p>案列1:在&#x2F;home目录下创建一个软链接myroot,连接到&#x2F;root目录</p><p>案列2:删除软链接myroot</p><pre class=" language-shell"><code class="language-shell">in -s /root /myrootrm /home/myroot #删除这个目录即可</code></pre><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>查看已执行过历史命令,也可以执行历史命令</p><p>基本语法</p><p>history (功能描述:查看已经执行过历史命令)</p><pre class=" language-shell"><code class="language-shell">history</code></pre><p>案列1:显示所有的历史命令</p><pre class=" language-shell"><code class="language-shell">history</code></pre><p>案列2:显示最近使用过的10个指令</p><pre class=" language-shell"><code class="language-shell">history 10</code></pre><p>案列3：执行历史编号为5的指令</p><pre class=" language-shell"><code class="language-shell">!5</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
