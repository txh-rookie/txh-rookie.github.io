<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单例模式</title>
      <link href="/2023/03/22/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/03/22/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式:"></a>单例模式:</h2><p>单例模式(Singleton Pattern)是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><h3 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a><strong>单例模式的结构</strong></h3><p>单例模式的主要有以下角色:</p><ul><li>单例类:只能创建一个实例的类</li><li>访问类:使用单例类</li></ul><h3 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h3><p>单例类的实现主要分为两种实现方式:</p><ul><li>饿汉式:在类加载的时候，就会去创建对象</li><li>懒汉式:类加载的时候不会导致该实例被创建，而是首次使用该对象时才会被创建</li></ul><h3 id="1、饿汉式-静态变量方式"><a href="#1、饿汉式-静态变量方式" class="headerlink" title="1、饿汉式-静态变量方式"></a>1、饿汉式-静态变量方式</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> 单例模式<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author kevintam * @version 1.0 * @title * @description * @createDate 2023/3/14 * 单例模式 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 单例模式主要分为     * 恶汉式: 在类加载的时候，就回去创建该对象     * 懒汉式:在我们真正去实现它时才会去创建对象     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton INSTANCE<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。 instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p><h3 id="2-饿汉式-静态代码块方式"><a href="#2-饿汉式-静态代码块方式" class="headerlink" title="2 饿汉式-静态代码块方式"></a>2 饿汉式-静态代码块方式</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 恶汉式* 在静态代码块中创建该类对象 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//私有构造方法</span><span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//在成员位置创建该类的对象</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//对外提供静态方法获取该对象</span><span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说明:</p><p>该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着 类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</p><h3 id="3、懒汉式-线程不安全"><a href="#3、懒汉式-线程不安全" class="headerlink" title="3、懒汉式 线程不安全"></a>3、懒汉式 线程不安全</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 懒汉式* 线程不安全 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//私有构造方法</span><span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//在成员位置创建该类的对象</span><span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对外提供静态方法获取该对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说明:</p><p>从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的 赋值操作，那么什么时候赋值的呢?当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p><h3 id="4、懒汉式-线程安全："><a href="#4、懒汉式-线程安全：" class="headerlink" title="4、懒汉式 线程安全："></a>4、懒汉式 线程安全：</h3><p>使用synchronized来解决线程安全:</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 懒汉式* 线程安全 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//私有构造方法</span><span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//在成员位置创建该类的对象</span><span class="token keyword">private</span> <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//对外提供静态方法获取该对象</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个是可以解决我们的线程安全的问题，但是会存在一个锁的粒度会很高，导致我们的程序的性能不是很好，可以使用双重检索的方式来进行解决.</p><h3 id="5、懒汉式-双重检查锁"><a href="#5、懒汉式-双重检查锁" class="headerlink" title="5、懒汉式 -双重检查锁"></a>5、懒汉式 -双重检查锁</h3><p>对于上面的操作加锁问题，我们单例模式应该是一个读多写少的问题。所以针对这个问题，我们可以改造我们的代码:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">DoubleSingleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//volatile保证我们不会受到可见性的影响。</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> DoubleSingleton instance<span class="token punctuation">;</span>    <span class="token keyword">public</span> DoubleSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第一次进行校验</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//会出现线程安全的问题</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p><p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 volatile 关键字, volatile 关 键字可以保证可见性和有序性。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">DoubleSingleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//volatile保证我们不会受到可见性的影响。</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> DoubleSingleton instance<span class="token punctuation">;</span>    <span class="token keyword">public</span> DoubleSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第一次进行校验</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//会出现线程安全的问题</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><p>添加 volatile 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程 的情况下线程安全也不会有性能问题。</p><h3 id="6、懒汉式-静态内部类"><a href="#6、懒汉式-静态内部类" class="headerlink" title="6、懒汉式 -静态内部类"></a>6、懒汉式 -静态内部类</h3><p>静态内部类单例模式中实例有内部类创建，由于JVM在类加载的过程中，是不会加载静态内部类的，只有内部类的属性&#x2F;方法被调用时才会被加载，并初始化其静态属性。静态属性由于被static修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span>   <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHandler</span><span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> SingletonHandler<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说明:</p><p>第一次类记载的时候，不会去初始化的我们的静态内部类的，只有第一次调用getInstance,虚拟机加载SingletonHander，并初始化。</p><p>小结:<br> 静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任<br> 何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题:"></a>存在的问题:</h3><p>1、怎么破坏单例模式:</p><p>使上面定义的单例类(Singleton)可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。</p><p>序列化反序列化</p><p>Singleton类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//私有构造方法</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//对外提供静态方法获取该对象</span><span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Test类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//往文件中写对象</span><span class="token comment" spellcheck="true">//writeObject2File(); //从文件中读取对象</span>        Singleton s1 <span class="token operator">=</span> <span class="token function">readObjectFromFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Singleton s2 <span class="token operator">=</span> <span class="token function">readObjectFromFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断两个反序列化后的对象是否是同一个对象</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton <span class="token function">readObjectFromFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//创建对象输入流对象</span>        ObjectInputStream ois <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span>                <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\Think\\Desktop\\a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//第一个读取Singleton对象</span>        Singleton instance <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> ois<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">writeObject2File</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//获取Singleton类的对象</span>        Singleton instance <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建对象输出流</span>        ObjectOutputStream oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span>                <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"C:\\Users\\Think\\Desktop\\a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将instance对象写出到文件中</span>        oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上面代码运行结果是 false ，表明序列化和反序列化已经破坏了单例设计模式。</p><p>2、可以通过我们的暴力反射可以破解我们的单例模式</p><p>Singleton类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">DoubleSingleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//构造器私有化</span>    <span class="token keyword">private</span> <span class="token function">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//volatile保证我们不会受到可见性的影响。</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> DoubleSingleton instance<span class="token punctuation">;</span>    <span class="token keyword">public</span> DoubleSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//第一次进行校验</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//会出现线程安全的问题</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> instance<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">DoubleSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><p>Test类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//获取Singleton类的字节码对象</span>        Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//获取Singleton类的私有无参构造方法对象</span>        Constructor constructor <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//取消访问检查</span>        constructor<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建Singleton类的对象s1</span>        Singleton s1 <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//创建Singleton类的对象s2</span>        Singleton s2 <span class="token operator">=</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//判断通过反射创建的两个Singleton对象是否是同一个对象</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//false</span><span class="token punctuation">}</span></code></pre><h3 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决:"></a>问题的解决:</h3><p>1、序列化、反序列化方式破解我们的单例模式的解决方法:</p><p>在Singleton类中添加 readResolve() 方法，在反序列化时被反射调用，如果定义了这个方法， 就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 下面是为了解决序列化反序列化破解单例模式 */</span><span class="token keyword">private</span> Object <span class="token function">readResolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>2、反射方式破解单例的解决方法</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//私有构造方法</span><span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>就是使用异常的方式来进行解决.</p><p>说明: 这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操</p><p>作。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2021/07/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2021/07/22/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h3><p>需求:设计一个咖啡店点餐系统。</p><p>设计一个咖啡类(Coffee)，并定义其两个子类(美式咖啡【AmericanCoffee】和拿铁咖啡 【LatteCoffee】);再设计一个咖啡店类(CoffeeStore)，咖啡店具有点咖啡的功能。</p><p>具体类的设计如下:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230322222915518.png" alt="image-20230322222915518"></p><p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。 如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象， 直接在工厂里更换该对象即可，达到了与对象解耦的目的;所以说，工厂模式最大的优点就是:<strong>解耦</strong>。</p><p>在本教程中会介绍三种工厂的使用</p><ul><li>简单工厂模式(不属于GOF的23种经典设计模式) </li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式:"></a>简单工厂模式:</h3><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构:"></a>结构:</h3><p>简单工厂包含如下角色:</p><ul><li>抽象产品:定义了产品的规范，描述了产品的主要特性和功能</li><li>具体产品:实现或者继承了抽象类产品的子类</li><li>具体工厂:提供了创建产品的方法，调用者通过该方法来获取产品。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现:"></a>实现:</h3><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230322222915518.png" alt="image-20230322222915518"></p><p>工厂类代码如下:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleCoffeeFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Coffee <span class="token function">createCoffee</span><span class="token punctuation">(</span>String type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Coffee coffee <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"americano"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            coffee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmericanoCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"latte"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            coffee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LatteCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> coffee<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>工厂(factory)处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的 orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就 解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和 SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p><p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修 改操作。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><p>优点:</p><p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避<br>免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户<br>代码修改的可能性，更加容易扩展。</p><p>缺点:</p><p>每次添加新的产品时，都需要去我们的工厂类中添加代码，违背了”开背原则”。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a><strong>工厂方法模式</strong></h3><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延</p><p>迟到其工厂的子类。</p><h3 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a><strong>结构</strong></h3><p>工厂方法模式的主要角色:</p><ul><li>抽象工厂(Abstract Factory):提供了创建产品的接口，调用者通过它访问具体工厂的工厂 方法来创建产品。 </li><li>具体工厂(ConcreteFactory):主要是实现抽象工厂中的抽象方法，完成具体产品的创建。 </li><li>抽象产品(Product):定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品(ConcreteProduct):实现了抽象产品角色所定义的接口，由具体工厂来创建，它同 具体工厂之间一一对应。</li></ul><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a><strong>实现</strong></h3><p>使用工厂方法模式对上例进行改进，类图如下:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230322223844656.png" alt="image-20230322223844656"></p><p>代码如下: </p><p>抽象工厂:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">{</span>    Coffee <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>具体工厂:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LatteCoffeeFactory</span> <span class="token keyword">implements</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Coffee <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LatteCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AmericanCoffeeFactory</span> <span class="token keyword">implements</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Coffee <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AmericanCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>咖啡店类:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CoffeeStore</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> CoffeeFactory factory<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">CoffeeStore</span><span class="token punctuation">(</span>CoffeeFactory factory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>factory <span class="token operator">=</span> factory<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Coffee <span class="token function">orderCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Coffee coffee <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coffee<span class="token punctuation">.</span><span class="token function">addMilk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        coffee<span class="token punctuation">.</span><span class="token function">addsugar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> coffee<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，<br>这样就解决了简单工厂模式的缺点。<br>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的<br>优点，而且克服了它的缺点。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程;</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，<br>满足开闭原则;</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-动态监控进程</title>
      <link href="/2021/06/13/linux-%E5%8A%A8%E6%80%81%E7%9B%91%E6%8E%A7/"/>
      <url>/2021/06/13/linux-%E5%8A%A8%E6%80%81%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="动态监控进程"><a href="#动态监控进程" class="headerlink" title="动态监控进程"></a>动态监控进程</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>top 与 ps 命令很相似。它们都用来显示正在执行的进程。Top 与 ps 最大的不同之处，在于 top 在执行一段时间可以更新正在运行的的进程。</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><pre class=" language-linux"><code class="language-linux">top [选项]</code></pre><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png" alt="截图"></p><p> 选项说明：</p><table><thead><tr><th>选项</th><th>功能</th></tr></thead><tbody><tr><td>-d 秒数</td><td>指定top命令每隔几秒进行刷新.默认是3秒</td></tr><tr><td>-i</td><td>使top不显示任何闲置或者僵死进程</td></tr><tr><td>-p</td><td>通过指定监控id来仅仅监控某个进程的状态.</td></tr></tbody></table><p> 交互操作说明：</p><table><thead><tr><th>操作</th><th>功能</th></tr></thead><tbody><tr><td>P</td><td>以cpu使用率排序,默认就是此项</td></tr><tr><td>M</td><td>以内存的使用率排序</td></tr><tr><td>N</td><td>以PID排序</td></tr><tr><td>q</td><td>退出操作</td></tr></tbody></table><p>应用实例<br>案例 1.监视特定用户, 比如我们监控 tom 用户</p><pre class=" language-linux"><code class="language-linux">top：输入此命令，按回车键，查看执行的进程。u：然后输入“u”回车，再输入用户名，即可,</code></pre><p>案例 2：终止指定的进程, 比如我们要结束 tom 登录</p><pre class=" language-linux"><code class="language-linux">top：输入此命令，按回车键，查看执行的进程。k：然后输入“k”回车，再输入要结束的进程 ID 号</code></pre><p>案例 3:指定系统状态更新的时间(每隔 10 秒自动更新), 默认是 3 秒</p><pre class=" language-linux"><code class="language-linux">top -d 10</code></pre><h3 id="监控网络状态"><a href="#监控网络状态" class="headerlink" title="监控网络状态"></a>监控网络状态</h3><p>查看系统网络情况 netstat</p><p>基本语法</p><pre class=" language-linux"><code class="language-linux">netstat [选项]</code></pre><p>选项说明</p><pre class=" language-linux"><code class="language-linux">-an 按一定顺序排列输出-p 显示哪个进程在调用</code></pre><p>应用案例<br>请查看服务名为 sshd 的服务的信息。</p><pre class=" language-linux"><code class="language-linux">netstat -anp | grep sshd</code></pre><h3 id="检测主机连接命令-ping："><a href="#检测主机连接命令-ping：" class="headerlink" title="检测主机连接命令 ping："></a>检测主机连接命令 ping：</h3><p>是一种网络检测工具，它主要是用检测远程主机是否正常，或是两部主机间的网线或网卡故障。<br>如: ping 对方 ip 地址</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux-服务管理</title>
      <link href="/2021/06/09/linux-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
      <url>/2021/06/09/linux-%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="linux服务管理"><a href="#linux服务管理" class="headerlink" title="linux服务管理"></a>linux服务管理</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍:"></a>介绍:</h4><p>服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysqld , sshd防火墙等)，因此我们又称为守护进程，是 Linux 中非常重要的知识点。</p><h4 id="service-管理指令"><a href="#service-管理指令" class="headerlink" title="service 管理指令"></a>service 管理指令</h4><ol><li>service 服务名 [start | stop | restart | reload | status]</li><li>在 CentOS7.0 后 很多服务不再使用 service ,而是 systemctl</li><li>service 指令管理的服务在 &#x2F;etc&#x2F;init.d 查看</li></ol><h4 id="查看服务名"><a href="#查看服务名" class="headerlink" title="查看服务名:"></a>查看服务名:</h4><p><strong>使用 setup -&gt; 系统服务 就可以看到全部。（作用可以在setup中更改开机即启动的服务）</strong></p><h4 id="服务的运行级别-runlevel"><a href="#服务的运行级别-runlevel" class="headerlink" title="服务的运行级别(runlevel):"></a>服务的运行级别(runlevel):</h4><p>Linux 系统有 7 种运行级别(runlevel)：常用的是 级别 3 和 和 5</p><p>Linux 系统有 7 种运行级别(runlevel)：常用的是 级别 3 和 和 5<br>运行级别 0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动<br>运行级别 1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆<br>运行级别 2：多用户状态(没有 NFS)，不支持网络<br>运行级别 3：完全的多用户状态(有 NFS)，无界面，登陆后进入控制台命令行模式<br>运行级别 4：系统未使用，保留<br>运行级别 5：X11 控制台，登陆后进入图形 GUI 模式<br>运行级别 6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动</p><h4 id="CentOS7-后运行级别说明"><a href="#CentOS7-后运行级别说明" class="headerlink" title="CentOS7 后运行级别说明"></a>CentOS7 后运行级别说明</h4><p>在 &#x2F;etc&#x2F;initab进行了简化 ，如下:</p><pre class=" language-linux"><code class="language-linux">multi-user.target: analogous to runlevel 3graphical.target: analogous to runlevel 5#查看当前级别systemctl get-default#修改运行级别systemctl set-default TARGET.target</code></pre><h4 id="chkconfig-指令"><a href="#chkconfig-指令" class="headerlink" title="chkconfig 指令"></a>chkconfig 指令</h4><p>通过 chkconfig 命令可以给服务的各个运行级别设置自 启动&#x2F;关闭chkconfig 指令管理的服务在 &#x2F;etc&#x2F;init.d 查看<br>注意: Centos7.0 后，很多服务使用 systemctl 管理.</p><p>chkconfig 基本语法</p><pre class=" language-linux"><code class="language-linux">查看服务 chkconfig --list [| grep xxx]chkconfig 服务名 --listchkconfig --level 5 服务名 on/off</code></pre><p>案例演示 : 对 network 服务 进行各种操作, 把 network 在 3 运行级别,关闭自启动</p><pre class=" language-linux"><code class="language-linux">chkconfig --level 3 network offchkconfig --level 3 network on</code></pre><p>使用细节<br>chkconfig 重新设置服务后自启动或关闭，需要重启机器 reboot 生效.</p><h4 id="systemctl-管理指令-重点"><a href="#systemctl-管理指令-重点" class="headerlink" title="systemctl 管理指令(重点)"></a>systemctl 管理指令(重点)</h4><p>基本语法：</p><pre class=" language-linux"><code class="language-linux">systemctl [start | stop | restart | status] 服务名systemctl 指令管理的服务在 /usr/lib/systemd/system 查看</code></pre><p> systemctl 设置服务的自启动状态</p><pre class=" language-bash"><code class="language-bash">systemctl list-unit-files <span class="token punctuation">[</span> <span class="token operator">|</span> <span class="token function">grep</span> 服务名<span class="token punctuation">]</span> <span class="token punctuation">(</span>查看服务开机启动状态, <span class="token function">grep</span> 可以进行过滤<span class="token punctuation">)</span>systemctl <span class="token function">enable</span> 服务名 <span class="token punctuation">(</span>设置服务开机启动<span class="token punctuation">)</span>systemctl disable 服务名 <span class="token punctuation">(</span>关闭服务开机启动<span class="token punctuation">)</span>systemctl is-enabled 服务名 <span class="token punctuation">(</span>查询某个服务是否是自启动的<span class="token punctuation">)</span></code></pre><p>应用案列:</p><p>查看当前防火墙的状况，关闭防火墙和重启防火墙。&#x3D;&gt; firewalld.service<br>systemctl status firewalld; systemctl stop firewalld; systemctl start firewalld</p><h4 id="打开或者关闭指定端口-重点"><a href="#打开或者关闭指定端口-重点" class="headerlink" title="打开或者关闭指定端口(重点)"></a>打开或者关闭指定端口(重点)</h4><p>   在真正的生产环境，往往需要将防火墙打开，但问题来了，如果我们把防火墙打开，那么外部请求数据包就不能跟服务器监听端口通讯。这时，需要打开指定的端口。比如 80、22、8080 等，这个又怎么做呢？</p><p>示意图:</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/mall/service.png" alt="截图"></p><p> <strong>firewall 指令:</strong></p><ol><li>打开端口: firewall-cmd –permanent –add-port&#x3D;端口号&#x2F;协议</li><li>关闭端口: firewall-cmd –permanent –remove-port&#x3D;端口号&#x2F;协议</li><li>重新载入,才能生效 : firewall-cmd –reload</li><li>查询端口是否开放: firewall-cmd –query-port&#x3D;端口&#x2F;协议</li></ol><p>应用案例：</p><ol><li>启用防火墙， 测试 111 端口是否能 telnet , 不行</li><li>开放 111 端口</li></ol><pre class=" language-linux"><code class="language-linux">firewall-cmd --permanent --add-port=111/tcp ; 需要 firewall-cmd --reload</code></pre><ol start="3"><li>再次关闭 111 端口</li></ol><pre class=" language-linux"><code class="language-linux">firewall-cmd --permanent --remove-port=111/tcp ; 需要 firewall-cmd --reload</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程管理</title>
      <link href="/2021/05/14/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2021/05/14/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="进程管理（重点）"><a href="#进程管理（重点）" class="headerlink" title="进程管理（重点）"></a>进程管理（重点）</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ol><li>在 LINUX 中，每个执行的程序都称为一个进程。每一个进程都分配一个 ID 号(pid,进程号)。&#x3D;&gt;windows &#x3D;&gt; linux</li><li>每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</li><li>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。</li></ol><h4 id="显示系统执行的进程"><a href="#显示系统执行的进程" class="headerlink" title="显示系统执行的进程"></a>显示系统执行的进程</h4><p>ps 命令是用来查看目前系统中，有哪些正在执行，以及它们执行的状况。可以不加任何参数.</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/image-20210514173753530.png" alt="image-20210514173753530"></p><h4 id="ps-详解"><a href="#ps-详解" class="headerlink" title="ps 详解"></a>ps 详解</h4><ol><li>指令：ps –aux|grep xxx ，比如我看看有没有 sshd 服务</li><li>指令说明<ul><li>System V 展示风格</li><li>USER：用户名称</li><li>PID：进程号</li><li>%CPU：进程占用 CPU 的百分比</li><li>%MEM：进程占用物理内存的百分比</li><li>VSZ：进程占用的虚拟内存大小（单位：KB）</li><li>RSS：进程占用的物理内存大小（单位：KB）</li><li>TT：终端名称,缩写 .</li><li>STAT：进程状态，其中 S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</li><li>STARTED：进程的启动时间</li><li>TIME： CPU 时间，即进程使用 CPU 的总时间</li><li>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</li></ul></li></ol><h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><p>要求：以全格式显示当前所有的进程，查看进程的父进程。 查看 sshd 的父进程信息</p><pre class=" language-linux"><code class="language-linux">ps -ef 是以全格式显示当前所有的进程-e 显示所有进程。-f 全格式ps -ef|grep sshdroot       942     1  0 Mar16 ?        00:02:16 /usr/sbin/sshd -Droot     17779   942  0 17:06 ?        00:00:00 sshd: root@pts/1root     27343   942  0 17:56 ?        00:00:00 sshd: root [priv]sshd     27344 27343  0 17:56 ?        00:00:00 sshd: root [net]是 BSD 风格UID：用户 IDPID：进程 IDPPID：父进程 IDC：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高STIME：进程启动的时间TTY：完整的终端名称TIME：CPU 时间CMD：启动进程所用的命令和参数</code></pre><h4 id="终止进程-kill-和-killall"><a href="#终止进程-kill-和-killall" class="headerlink" title="终止进程 kill 和 killall"></a>终止进程 kill 和 killall</h4><blockquote><p>若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用 kill 命令来完成此项任务</p></blockquote><p>基本语法:</p><pre class=" language-linux"><code class="language-linux">kill [选项] 进程号（功能描述：通过进程号杀死/终止进程）killall 进程名称（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）</code></pre><p>常用选项:</p><p>-9 :表示强迫进程立即停止</p><p>应用案例:</p><p>案例 1. ：踢掉某个非法登录用户</p><pre class=" language-linux"><code class="language-linux">kill 进程号 , 比如 kill 11421</code></pre><p>案例 2: 终止远程登录服务 sshd, 在适当时候再次重启 sshd 服务</p><pre class=" language-linux"><code class="language-linux">kill sshd 对应的进程号; /bin/systemctl start sshd.service</code></pre><p>案例 3: 终止多个 gedit , 演示 killall gedit</p><pre class=" language-linux"><code class="language-linux">通过进程的名字来终止进程</code></pre><p>案例 4：强制杀掉一个终端, 指令 kill -9 bash 对应的进程号</p><pre class=" language-linux"><code class="language-linux">kill -9 bash</code></pre><h4 id="查看进程树-pstree"><a href="#查看进程树-pstree" class="headerlink" title="查看进程树 pstree"></a>查看进程树 pstree</h4><p>基本语法</p><pre class=" language-linux"><code class="language-linux">pstree [选项] ,可以更加直观的来看进程信息</code></pre><p>常用选项</p><p>-p :显示进程的 PID<br>-u :显示进程的所属用户</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux组的介绍</title>
      <link href="/2021/04/27/linux%E7%BB%84%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/04/27/linux%E7%BB%84%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="linux组的介绍"><a href="#linux组的介绍" class="headerlink" title="linux组的介绍"></a>linux组的介绍</h3><p>在linux中每个用户必须属于一个组,不能独立于组外。在linux中每个文件有所有组、所在组、其它组的概念</p><ul><li>所有者</li><li>所在组</li><li>其它组</li><li>改变用户所在的组</li></ul><h4 id="文件-x2F-目录-所有者"><a href="#文件-x2F-目录-所有者" class="headerlink" title="文件&#x2F;目录 所有者"></a>文件&#x2F;目录 所有者</h4><p>一般为文件的创建者,谁创建了该文件,就自然的称为该文件的所有者</p><ul><li>查看文件的所有者</li></ul><pre class=" language-code"><code class="language-code">指令:ls -ahl</code></pre><ul><li>修改文件的所有者</li></ul><pre class=" language-code"><code class="language-code">指令:chown用户名 文件名案列:chown root txh</code></pre><h4 id="组的创建"><a href="#组的创建" class="headerlink" title="组的创建"></a>组的创建</h4><pre class=" language-code"><code class="language-code">groupadd 组名</code></pre><p>应用案例:</p><p>创建一个组名tom</p><pre class=" language-code"><code class="language-code">groupadd tom</code></pre><p>将hello.txt加入到该组之中</p><pre class=" language-code"><code class="language-code">useradd -g tom hello.txt</code></pre><p>修改文件所在组</p><p>基本指令:</p><pre class=" language-code"><code class="language-code">chgrp 组名 文件名</code></pre><h4 id="其它组"><a href="#其它组" class="headerlink" title="其它组"></a>其它组</h4><p>除文件的所有者和所在组的用户外,系统的其它用户都是文件的其它组</p><h4 id="改变用户所在组"><a href="#改变用户所在组" class="headerlink" title="改变用户所在组"></a>改变用户所在组</h4><p>在添加用户时,可以指定将该用户添加到哪个组中,同样的用root的管理权限可以改变某个用户所在的组。</p><ul><li>改变用户所在组</li></ul><p>usermod -g 新组名 用户名</p><p>usermod -d 目录名 用户名 改变该用户登录的初始目录。</p><h3 id="权限的基本介绍"><a href="#权限的基本介绍" class="headerlink" title="权限的基本介绍"></a>权限的基本介绍</h3><p>ls -l命令的显示的内容如下:</p><pre class=" language-code"><code class="language-code">[txh@VM-0-17-centos home]$ ls -ltotal 20-rw-r--r--  1 root root    0 Apr 23 23:15 cat.txt-rw-r--r--  1 root root   26 Apr 19 22:33 hello.txtdrwxr-xr-x 11 txh  txh  4096 Apr 26 23:23 hexodrwxr-xr-x  2 root root 4096 Apr 26 19:49 kevintam-rw-r--r--  1 root root  125 Apr 23 23:17 pc.tar.gz-rw-r--r--  1 root root    0 Apr 23 23:16 pig.txtdrwx------ 10 txh  txh  4096 Apr 14 14:13 txh</code></pre><p>drwxr-xr-x 0 -9位说明</p><ol><li>第0位说明文件的类型（d,-,l,c,b）</li></ol><ul><li>l是链接,相当于windows的快捷方式</li><li>d是目录,相当于windows的文件夹</li><li>c是字符设备文件,鼠标,键盘</li><li>b是块设备，比如硬盘</li><li>-表示是个普通文件</li></ul><ol start="2"><li>第1-3位确定所有者（该文件的所有者）拥有该文件的权限</li><li>第4-6位确定所属组（同用户组的）拥有该文件的权限</li><li>第7-9位确定其他用户拥有该文件的权限</li></ol><blockquote><p> rwx作用到文件</p></blockquote><p>[r]代表可读(read):可以读取,查看</p><p>[w]代表可写(write):可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限,才能删除该文件。</p><p>[x]代表可执行(execute):可以被执行</p><blockquote><p> rwx作用到目录</p></blockquote><p>[r]代表可读（read）:可以读取,ls查看目录内容</p><p>[w]代表可写（write）:可以修改,对目录内创建+删除+重命名目录</p><p>[x]代表可执行（execute）:可以进行该目录</p><p><strong>案列分析:</strong></p><pre class=" language-code"><code class="language-code">-rw-r--r--  1 root root    0 Apr 23 23:15 cat.txt-表示是一个普通文件rw- 表示文件拥有者权限是读和写r-- 表示同组的用户对该文件拥有读的权限r-- 其他的用户只有读的权限1  文件:表示是硬链接数 目录:表示子目录数+文件数(第一个root)root 表示文件的所有者(第二个root)root 表示文件的所在组0 文件的大小(字节)Apr 23 23:15 表示最后的修改日期cat.txt 文件名</code></pre><h4 id="修改权限-chmod"><a href="#修改权限-chmod" class="headerlink" title="修改权限-chmod"></a>修改权限-chmod</h4><p>基本说明:</p><p>通过chmod指令,可以修改文件或者目录的权限</p><p>第一种方式:+、-、&#x3D;变更权限</p><p>​     u:所有者 g:所在组 o:其他人 a:所有人(u、g、o的总和)</p><ul><li>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件&#x2F;目录</li><li>chmod o+w 文件&#x2F;目录名</li><li>chmod a-x 文件&#x2F;目录名</li></ul><p><strong>注意:&#x3D;直接赋予 -除去权限 +增加权限</strong></p><p>案列:给cat.txt文件的所有者读写执行的权限,在给是在组读执行权限,给其他组读执行权限</p><pre class=" language-code"><code class="language-code">chmod u=rwx,g=rx,o=rx cat.txt</code></pre><p>给cat.txt文件的所有者除去执行的权限,增加组写的权限</p><pre class=" language-code"><code class="language-code">chmod u-x,g+w cat.txt</code></pre><p>第二种方式:通过数字变更权限</p><p>r&#x3D;4 w&#x3D;2 x&#x3D;1 rwx&#x3D;4+2+1&#x3D;7</p><p>chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x 文件目录名</p><p>相当于chmod 751 文件目录名</p><h4 id="修改文件所有者-chown"><a href="#修改文件所有者-chown" class="headerlink" title="修改文件所有者-chown"></a>修改文件所有者-chown</h4><p>chown newowner 文件&#x2F;目录 改变所有者</p><p>chown newowner:newgroup 文件&#x2F;目录 改变所有者和所在组 -R 如果是目录 则使其下所有子文件或目录递归生效</p><p>案例演示:</p><p>请将&#x2F;home&#x2F;cat.txt 文件的所有者修改成txh</p><pre class=" language-code"><code class="language-code">chown txh /home/cat.txt</code></pre><h4 id="修改文件所在组-chgrp"><a href="#修改文件所在组-chgrp" class="headerlink" title="修改文件所在组-chgrp"></a>修改文件所在组-chgrp</h4><p>基本介绍:</p><p>chgrp newgroup 文件&#x2F;目录 改变所在组</p><p>案例演示:</p><p>请将&#x2F;home&#x2F;cat.txt 文件的所在组修改成shaolin（少林）</p><pre class=" language-code"><code class="language-code">chgrp shaolin /home/cat.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解压和压缩命令</title>
      <link href="/2021/04/22/%E8%A7%A3%E5%8E%8B%E5%92%8C%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/22/%E8%A7%A3%E5%8E%8B%E5%92%8C%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="解压和压缩命令"><a href="#解压和压缩命令" class="headerlink" title="解压和压缩命令"></a>解压和压缩命令</h3><blockquote><p> 压缩和解压类</p></blockquote><pre class=" language-code"><code class="language-code"> gzip/gunzip 指令</code></pre><p>gzip 用于压缩文件，gunzip用于解压的</p><p>基本语法:</p><pre class=" language-code"><code class="language-code">gzip 文件 (功能描述:压缩文件,只能将文件压缩为*.gz文件)gunzip 文件.gz (解压缩文件命令</code></pre><p>应用实例:</p><p>案列1: gzip压缩,将&#x2F;home下的hello.txt文件进行压缩</p><pre class=" language-linux"><code class="language-linux">gzip /home/hello.txt  #压缩</code></pre><p>案列2:gunzip压缩,将&#x2F;home下的hello.txt.gz文件进行解压缩.</p><pre class=" language-bash"><code class="language-bash">gunzip /home/hello.txt.gz <span class="token comment" spellcheck="true">#解压</span></code></pre><h3 id="zip-x2F-unzip指令"><a href="#zip-x2F-unzip指令" class="headerlink" title="zip&#x2F;unzip指令"></a>zip&#x2F;unzip指令</h3><blockquote><p> zip用于压缩文件，unzip用于解压的，这个在项目打爆发布中很有用.</p></blockquote><p>基本语法:</p><pre class=" language-linux"><code class="language-linux">zip [选项] xxx.zip 将要压缩的内容  （功能描述:压缩文件和目录的命令）unzip [选项] xxx.zip (功能描述:解压缩文件)</code></pre><p>zip常用选项</p><p>-r: 递归压缩，即压缩目录</p><p>unzip的常用选项</p><p>-d &lt;目录&gt;:指定解压后文件的存放目录</p><p>案例:</p><p>案例一:将&#x2F;home下的所有文件&#x2F;进行压缩成myhome.zip</p><pre class=" language-linux"><code class="language-linux">zip -r myhome/  </code></pre><p>案例二:将myhome.zip压缩到&#x2F;opt&#x2F;temp下.</p><pre class=" language-linux"><code class="language-linux">unzip -d /opt/temp myhome.zip  </code></pre><h3 id="tar指令-最常用的命令"><a href="#tar指令-最常用的命令" class="headerlink" title="tar指令(最常用的命令)"></a>tar指令(最常用的命令)</h3><p>tar指令是打包指令,最后打包后的文件是.tar.gz的文件</p><p>基本语法：</p><blockquote><p>tar [选项] xxx.tar.gz 打包的内容  （功能描述:打包目录,压缩后的文件选项说明）</p></blockquote><table><thead><tr><th>选项</th><th align="center">功能</th></tr></thead><tbody><tr><td>-c</td><td align="center">产生.tar打包文件</td></tr><tr><td>-v</td><td align="center">显示详细信息</td></tr><tr><td>-f</td><td align="center">指定压缩后的文件名</td></tr><tr><td>-z</td><td align="center">用gzip对文档进行压缩或解压</td></tr><tr><td>-x</td><td align="center">解包.tar文件</td></tr></tbody></table><p>应用案例：</p><p>案例一:压缩多个文件,将&#x2F;home&#x2F;pig.txt和&#x2F;home&#x2F;cat.txt压缩成pc.tar.gz</p><pre class=" language-linux"><code class="language-linux">[root@VM-0-17-centos home]# tar -zcvf pc.tar.gz cat.txt pig.txtcat.txtpig.txt[root@VM-0-17-centos home]# lscat.txt  hello.txt  hexo  kevintam  pc.tar.gz  pig.txt  txh</code></pre><p>案例二：将&#x2F;home的文件夹压缩成myhome.tar.gz</p><pre class=" language-linux"><code class="language-linux">[root@VM-0-17-centos home]# tar -zcvf myhome.tar.gz /home/ #包括/home</code></pre><p>案例三：将pc.tar.gz解压到当前目录.</p><pre class=" language-linux"><code class="language-linux">[root@VM-0-17-centos home]# tar -zxvf pc.tar.gz cat.txtpig.txt[root@VM-0-17-centos home]# lscat.txt  hello.txt  hexo  kevintam  pc.tar.gz  pig.txt  txh</code></pre><p>案例四：将myhome.tar.gz 解压到&#x2F;opt&#x2F;temm目录下</p><pre class=" language-linux"><code class="language-linux">tar -zxvf /home/myhome.tar.gz -C /opt/tem2</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>走进linux系统</title>
      <link href="/2021/04/18/%E8%B5%B0%E8%BF%9Blinux%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/04/18/%E8%B5%B0%E8%BF%9Blinux%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="走近Linux系统"><a href="#走近Linux系统" class="headerlink" title="走近Linux系统"></a>走近Linux系统</h2><blockquote><p>开机登录</p></blockquote><p>开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p><p>开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！</p><p>一般来说，用户的登录方式有三种：</p><ul><li>命令行登录</li><li>ssh登录</li><li>图形界面登录</li></ul><p>最高权限账户为 root，可以操作一切！</p><blockquote><p>关机</p></blockquote><p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>关机指令为：shutdown ；</p><pre class=" language-bash"><code class="language-bash"><span class="token function">sync</span> <span class="token comment" spellcheck="true"># 将数据由内存同步到硬盘中。</span><span class="token function">shutdown</span> <span class="token comment" spellcheck="true"># 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><span class="token function">shutdown</span> –h 10 <span class="token comment" spellcheck="true"># 这个命令告诉大家，计算机将在10分钟后关机</span><span class="token function">shutdown</span> –h now <span class="token comment" spellcheck="true"># 立马关机</span><span class="token function">shutdown</span> –h 20:25 <span class="token comment" spellcheck="true"># 系统会在今天20:25关机</span><span class="token function">shutdown</span> –h +10 <span class="token comment" spellcheck="true"># 十分钟后关机</span><span class="token function">shutdown</span> –r now <span class="token comment" spellcheck="true"># 系统立马重启</span><span class="token function">shutdown</span> –r +10 <span class="token comment" spellcheck="true"># 系统十分钟后重启</span><span class="token function">reboot</span> <span class="token comment" spellcheck="true"># 就是重启，等同于 shutdown –r now</span>halt <span class="token comment" spellcheck="true"># 关闭系统，等同于shutdown –h now 和 poweroff</span></code></pre><p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p><blockquote><p>系统目录结构</p></blockquote><p>登录系统后，在当前命令窗口下输入命令：</p><pre class=" language-linux"><code class="language-linux">ls /</code></pre><p>你会看到如下图所示：</p><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/linux.JPG" alt="图片"></p><p>树状目录结构：（Linux的一切资源都挂载在这个 &#x2F; 根节点下）</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="图片"></p><p><strong>以下是对这些目录的解释：</strong></p><ul><li>&#x2F;bin(常用)：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li>&#x2F;boot：(常用) 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li>&#x2F;dev: dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li>&#x2F;etc(常用) :这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li><li>&#x2F;home(常用)：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li>&#x2F;lib：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</li><li>&#x2F;lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li>&#x2F;media(常用)： linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li>&#x2F;mnt(常用)：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看光驱里的内容了。</li><li>&#x2F;opt(常用)：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li>&#x2F;proc[不能动]：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li><li>&#x2F;root：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li>&#x2F;sbin： s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li>&#x2F;srv[不能动]： 该目录存放一些服务启动之后需要提取的数据。</li><li>&#x2F;sys[不能动]：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li><li>&#x2F;tmp： 这个目录是用来存放一些临时文件的。</li><li>&#x2F;usr： 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li><li>&#x2F;usr&#x2F;bin:  系统用户使用的应用程序。</li><li>&#x2F;usr&#x2F;sbin: 超级用户使用的比较高级的管理程序和系统守护程序。</li><li>&#x2F;usr&#x2F;src: 内核源代码默认的放置目录。</li><li>&#x2F;usr&#x2F;local&#x2F;:这是另一个给主机安装软件所安排的目录.一盘是通过编译源码方式来安装的程序</li><li>&#x2F;var(常用)：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li>&#x2F;run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常见的目录命令</title>
      <link href="/2021/04/17/linux%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%AE%E5%BD%95%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/17/linux%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%AE%E5%BD%95%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="常用的基本命令（必掌握）"><a href="#常用的基本命令（必掌握）" class="headerlink" title="常用的基本命令（必掌握）"></a>常用的基本命令（必掌握）</h3><h4 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h4><h4 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h4><p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 &#x2F;。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="网图"></p><p><strong>绝对路径：</strong></p><p>路径的写法，由根目录 &#x2F; 写起，例如：&#x2F;usr&#x2F;share&#x2F;doc 这个目录。</p><p><strong>相对路径：</strong></p><p>路径的写法，不是由 &#x2F; 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成：cd ..&#x2F;man 这就是相对路径的写法啦！</p><h4 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h4><p>接下来我们就来看几个常见的处理目录的命令吧：</p><ul><li>ls: 列出目录</li><li>cd：切换目录</li><li>pwd：显示目前的目录</li><li>mkdir：创建一个新的目录</li><li>rmdir：删除一个空的目录</li><li>cp: 复制文件或目录</li><li>rm: 移除文件或目录</li><li>mv: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><h4 id="ls-（列出目录）"><a href="#ls-（列出目录）" class="headerlink" title="ls （列出目录）"></a>ls （列出目录）</h4><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><pre><code>[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称</code></pre><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将目录下的所有文件列出来(含属性与隐藏档)</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls -al ~</span></code></pre><h4 id="cd-（切换目录）"><a href="#cd-（切换目录）" class="headerlink" title="cd （切换目录）"></a>cd （切换目录）</h4><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><pre><code>cd [相对路径或绝对路径]</code></pre><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 切换到用户目录下</span><span class="token punctuation">[</span>root@VM-0-17-centos /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd home</span><span class="token comment" spellcheck="true"># 使用 mkdir 命令创建 tom 目录</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir tom</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>kevintam  tom<span class="token comment" spellcheck="true"># 进入  tom 目录</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd tom/</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token comment" spellcheck="true"># 回到上一级</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd ..</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token comment" spellcheck="true"># 回到根目录</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /</span><span class="token punctuation">[</span>root@VM-0-17-centos /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token comment" spellcheck="true"># 表示回到自己的家目录，亦即是 /root 这个目录</span><span class="token punctuation">[</span>root@VM-0-17-centos /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd ~</span><span class="token punctuation">[</span>root@VM-0-17-centos ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span></code></pre><h4 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd ( 显示目前所在的目录 )"></a>pwd ( 显示目前所在的目录 )</h4><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><pre><code>[root@kuangshen kuangstudy]#pwd [-P]</code></pre><p>选项与参数：**-P** ：显示出确实的路径，而非使用连接(link) 路径。</p><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 单纯显示出目前的工作目录</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># pwd</span>/home/tom<span class="token comment" spellcheck="true"># 如果是链接，要显示真实地址，可以使用 -P参数</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># pwd -P</span>/home/tom</code></pre><h4 id="mkdir-（创建新目录）"><a href="#mkdir-（创建新目录）" class="headerlink" title="mkdir （创建新目录）"></a>mkdir （创建新目录）</h4><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><pre><code>mkdir [-mp] 目录名称</code></pre><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 进入我们用户目录下</span><span class="token punctuation">[</span>root@VM-0-17-centos /<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd home/</span><span class="token comment" spellcheck="true"># 创建一个 test 文件夹</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir test</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>kevintam  <span class="token function">test</span>  tom<span class="token comment" spellcheck="true"># 创建多层级目录</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir test1/test2</span>mkdir: cannot create directory ‘test1/test2’: No such <span class="token function">file</span> or directory<span class="token comment" spellcheck="true"># &lt;== 没办法直接创建此目录啊！</span><span class="token comment" spellcheck="true"># 加了这个 -p 的选项，可以自行帮你创建多层目录！</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir -p  test1/test2</span></code></pre><h4 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir ( 删除空的目录 )"></a>rmdir ( 删除空的目录 )</h4><p>语法：</p><pre><code>rmdir [-p] 目录名称</code></pre><p>选项与参数：**-p ：**连同上一级『空的』目录也一起删除</p><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 看看有多少目录存在？</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls -l</span>total 16drwxr-xr-x 2 root root 4096 Feb 26 14:45 kevintamdrwxr-xr-x 2 root root 4096 Feb 26 14:51 <span class="token function">test</span>drwxr-xr-x 3 root root 4096 Feb 26 14:51 test1drwxr-xr-x 2 root root 4096 Feb 26 14:46 tom<span class="token comment" spellcheck="true"># 可直接删除掉，没问题</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rmdir test</span><span class="token comment" spellcheck="true"># 因为尚有内容，所以无法删除！</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rmdir test1/</span>rmdir: failed to remove ‘test1/’: Directory not empty<span class="token comment" spellcheck="true"># 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 依次删除。</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rmdir -p test1/test2/</span></code></pre><p>注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录.</p><h4 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp ( 复制文件或目录 )"></a>cp ( 复制文件或目录 )</h4><p>语法：</p><pre><code>[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory</code></pre><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 找一个有文件的目录，我这里找到 root目录</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /root</span><span class="token punctuation">[</span>root@kuangshen ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>install.sh<span class="token punctuation">[</span>root@kuangshen ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd /home</span><span class="token comment" spellcheck="true"># 复制 home目录下的hello 到 opt目录下</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp -r hello /opt/</span><span class="token comment" spellcheck="true"># 再次复制，加上-i参数，增加覆盖询问？</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp -r hello /opt/</span>cp: overwrite ‘/opt/hello/hello.txt’? y <span class="token comment" spellcheck="true"># n不覆盖，y为覆盖</span><span class="token comment" spellcheck="true">#不提示是否覆盖</span>\cp -r /root/install.sh /home</code></pre><h4 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm ( 移除文件或目录 )"></a>rm ( 移除文件或目录 )</h4><p>语法：</p><pre><code>rm [-fir] 文件或目录</code></pre><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span><span class="token punctuation">[</span>root@VM-0-17-centos opt<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rm -rf hello</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># rm hello.txt </span>rm: remove regular empty <span class="token function">file</span> ‘hello.txt’? y<span class="token comment" spellcheck="true"># 如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</span><span class="token comment" spellcheck="true"># 尽量不要在服务器上使用 rm -rf /</span></code></pre><h4 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv  ( 移动文件与目录，或修改名称 )"></a>mv  ( 移动文件与目录，或修改名称 )</h4><p>语法：</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mv [-fiu] source destination</span><span class="token punctuation">[</span>root@www ~<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mv [options] source1 source2 source3 .... directory</span><span class="token comment" spellcheck="true">#如果是在一个目录下的移动就是重命名</span></code></pre><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>测试：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 复制一个文件到当前目录</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cp /root/install.sh /home</span><span class="token comment" spellcheck="true"># 创建一个文件夹 test</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mkdir test</span><span class="token comment" spellcheck="true"># 将复制过来的文件移动到我们创建的目录，并查看</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mv install.sh test</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span><span class="token function">test</span><span class="token punctuation">[</span>root@kuangshen home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cd test</span><span class="token punctuation">[</span>root@kuangshen test<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>install.sh<span class="token comment" spellcheck="true"># 将文件夹重命名，然后再次查看！</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># touch cat</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># </span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># mv cat pig</span><span class="token punctuation">[</span>root@VM-0-17-centos home<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>kevintam  pig  tom</code></pre><h4 id="创建一个空的文件"><a href="#创建一个空的文件" class="headerlink" title="创建一个空的文件"></a>创建一个空的文件</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">touch</span> <span class="token punctuation">[</span>文件名称<span class="token punctuation">]</span><span class="token comment" spellcheck="true">#指令</span></code></pre><p>测试</p><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@VM-0-17-centos kevintam<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># touch hello.java</span><span class="token punctuation">[</span>root@VM-0-17-centos kevintam<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># ls</span>hello.java</code></pre><h4 id="查看文件的内容"><a href="#查看文件的内容" class="headerlink" title="查看文件的内容"></a>查看文件的内容</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">cat</span> <span class="token comment" spellcheck="true">#查看文件的内容</span>-n <span class="token comment" spellcheck="true">#显示行号</span><span class="token comment" spellcheck="true">#查看/etc/profile的文件 -n就是查看行号.</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat -n /etc/profile</span><span class="token comment" spellcheck="true"># | more 管道命令 按回车键往下走 输入空格 会直接下一页</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cat -n /etc/profile | more</span></code></pre><p>more指令是一个vi编辑的文本过滤器，他以全屏的方式按页显示内容</p><p>more中常见的快捷键</p><ul><li>空格键: 往下翻一页</li><li>enter ：往下走一段</li><li>q：立刻离开</li><li>ctrl+f：向下滚动一屏</li><li>ctrl+b：返回上一屏</li><li>&#x3D;：输出当前行号</li><li>：f  输出当前的行号和文件名</li></ul><p>cat和more通常组合使用</p><h4 id="less-指令"><a href="#less-指令" class="headerlink" title="less 指令"></a>less 指令</h4><p>less指令支持用来分屏查看文件内容。通常使用在大文件的查看</p><p>常用指令：</p><ul><li>空格键:向下翻到一页</li><li>q：离开less指令</li><li>&#x2F;字符：查询字符</li><li>[pagedown]：向下翻动一页</li><li>[pageup]：向上翻动一页</li></ul><h4 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h4><p>输出内容到控制台</p><pre class=" language-bash"><code class="language-bash">echo<span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>输出内容<span class="token punctuation">]</span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo $HOSTNAME</span>VM-0-17-centos<span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo "hello world~~"</span>hello world~~</code></pre><pre class=" language-bash"><code class="language-bash"><span class="token function">head</span><span class="token comment" spellcheck="true">#文件的开头</span><span class="token comment" spellcheck="true">#看5行的代码</span><span class="token function">head</span> -n 5<span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># head -n 5 /etc/profile</span><span class="token comment" spellcheck="true"># /etc/profile</span><span class="token comment" spellcheck="true"># System wide environment and startup programs, for login setup</span><span class="token comment" spellcheck="true"># Functions and aliases go in /etc/bashrc</span><span class="token function">tail</span>  -f<span class="token comment" spellcheck="true">#文件尾的内容 实时的监控文件</span></code></pre><pre class=" language-bash"><code class="language-bash"><span class="token operator">></span>和<span class="token operator">>></span>指令<span class="token comment" spellcheck="true">#输出重定向和追加</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo "hello world" > data.txt #会覆盖该文件里的数据</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># echo "java" >> data.txt #在原数据的基础上会追加内容</span></code></pre><h4 id="查看当前日期"><a href="#查看当前日期" class="headerlink" title="查看当前日期"></a>查看当前日期</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">cal</span><span class="token punctuation">[</span>root@VM-0-17-centos tom<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># cal</span>     March 2021     Su Mo Tu We Th Fr Sa    1  2  3  4  5  6 7  8  9 10 11 12 1314 15 16 17 18 19 2021 22 23 24 25 26 2728 29 30 31</code></pre><h4 id="In指令"><a href="#In指令" class="headerlink" title="In指令"></a>In指令</h4><p>软链接也称为符号链接,类似于windows里的快捷方式,主要存放了链接其他文件的路径</p><p>基本语法</p><pre class=" language-shell"><code class="language-shell">in -s 原文件或目录(功能描述：给原文件创建一个软链接) 连接到的目录</code></pre><p>引用案列</p><p>案列1:在&#x2F;home目录下创建一个软链接myroot,连接到&#x2F;root目录</p><p>案列2:删除软链接myroot</p><pre class=" language-shell"><code class="language-shell">in -s /root /myrootrm /home/myroot #删除这个目录即可</code></pre><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><p>查看已执行过历史命令,也可以执行历史命令</p><p>基本语法</p><p>history (功能描述:查看已经执行过历史命令)</p><pre class=" language-shell"><code class="language-shell">history</code></pre><p>案列1:显示所有的历史命令</p><pre class=" language-shell"><code class="language-shell">history</code></pre><p>案列2:显示最近使用过的10个指令</p><pre class=" language-shell"><code class="language-shell">history 10</code></pre><p>案列3：执行历史编号为5的指令</p><pre class=" language-shell"><code class="language-shell">!5</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
