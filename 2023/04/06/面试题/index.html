<!DOCTYPE HTML>
<html lang="zh">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="面试题, kevintam">
    <meta name="description" content="jvm篇1、JVM的运行时数据区
1、一般将.java后缀的文件，使用javac编译成.class文件，然后通过我们的类加载器将我们的字节码文件记载到我们的运行时数据区中。
2、运行时数据区主要分为方法区、虚拟机栈、本地方法栈、堆、程序计数">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>面试题 | kevintam</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">kevintam</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">kevintam</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/txh-rookie" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>txh-rookie
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/txh-rookie" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="txh-rookie" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/5.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">面试题</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/java/">
                                <span class="chip bg-color">java</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                技术
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2023-04-06
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="jvm篇"><a href="#jvm篇" class="headerlink" title="jvm篇"></a>jvm篇</h1><h2 id="1、JVM的运行时数据区"><a href="#1、JVM的运行时数据区" class="headerlink" title="1、JVM的运行时数据区"></a>1、JVM的运行时数据区</h2><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220220161522429.png" alt="image-20220220161522429"></p>
<p>1、一般将.java后缀的文件，使用javac编译成.class文件，然后通过我们的类加载器将我们的字节码文件记载到我们的运行时数据区中。</p>
<p>2、运行时数据区主要分为方法区、虚拟机栈、本地方法栈、堆、程序计数器</p>
<p>3、程序计数器是线程私有的，也就是每个线程都拥有一个程序计数器，主要用于记录当前线程执行的字节码的文件的行数。为什么需要程序计数器就是因为我们的java的多线程是通过不断的切换的cpu的时间片来进行实现。所以会发生执行线程会不断的进行切换。所以我们需要一个程序计数器，来记录当前线程执行到的位置。程序计数器是jvm规范中唯一没有规定任何规范的的区域。</p>
<p>3、虚拟栈也是线程私有的，当我们的方法被执行时。创建一个栈帧，这个栈帧主要存储的是我们的局部变量、基本数据类型、返回地址等，将这个栈帧进行压栈操作。当我们的执行完方法后，会将虚拟机栈中的栈帧进行弹栈操作。当我们的请求的栈的深度大于我们的默认的栈的深度时，会抛出<strong>StackOverflowError异常</strong>。当我们的请求创建栈帧的时候，内存空间不足以创建时，会抛出<strong>OutOfMemoryError异常错误</strong>。-Xss来进行调控，但是最好不要调的过大。因为会导致我们的创建的线程变少。</p>
<p>4、方法区，是线程共享的区域，它主要用于存储的类相关的信息，比如说常量、静态变量、类型信息、常量池、即使编译器编译的代码信息等都会存储在我们的方法区中。方法区是jvm的规范，但是的具体的实现不同，在jdk1.6的时候，采用永久带进行的实现，在jdk1.8的时候，采用的元空间MateSpace来进行实现。然后将我们的永久带中的Stringtable进行了移除，然后将我们的字符常量池放入到了我们的堆中。在jdk1.8的时候采用的元空间来进行实现。可以使用我们的-XX:MatespaceSize来进行调控。当我们的方法区无法满足新的内存分配时，就会抛出异常OutOfMoneryError错误。</p>
<p>5、堆，是线程共享的内存区域，它主要用于存储的java中的所有的对象，都会在我们的java堆中的进行内存的分配。所以堆中的对象都需要考虑的线程安全的问题。存在垃圾回收。堆内存溢出会抛我们的OutOfMoneryError错误。</p>
<blockquote>
<p>对象的创建:对象的创建我们是通过java的new关键字来进行创建，但是在jvm层面的创建过程是通过字节码new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被记载、解析和初始化过。如果没有，先将这个类进行类加载。类记载通过之后，会heap堆中分配内存空间.然后会根据我们的堆空闲的内存是否规整，来选择不同的方式去分配我们的内存空间。堆中的内存空间是否规整主要取决于我们选择何种的垃圾收集器，比如说seriel、Parnew等代压缩整理收集器的话，我们可以采用指针碰撞的方式来分配堆中的空间。如果是采用cms这种基于我们的垃圾清除算法的收集器的话，会产生我们的内存碎片，所以我们需要使用的空闲列表的方式来分陪堆中的内存空闲。</p>
</blockquote>
<p>因为我们的java堆是线程共享的，所以会存在线程安全的问题。所以我们的创建的对象的过程中，也会出现线程安全的问题。jvm 主要采用了两种方式来实现我们的创建对象的线程安全。1、采用乐观锁的机制，也就是cas加上失败重试来保证我们的线程安全。2、采用ZlAB本地线程分配缓存来保证我们的线程安全。线程隔离的方式来实现线程安全的。</p>
<p>扩展点:</p>
<p>java对象的内存布局:对象头(8个字节)、实例数据、对其填充。</p>
<ul>
<li>用于存储对象自身的运行时数据,如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程id、偏向时间戳等。(Mark world)</li>
<li>类型指针,即对象指向它的类型元数据等指针,java虚拟机通过这个指针来确定改对象是那个类的实例。</li>
</ul>
<p>对象的访问定位:</p>
<ul>
<li>句柄:java堆中可能会划出一块内存作为句柄池，这样我们找对象只需要通过我们的句柄池来进行查找。</li>
<li>直接指针:就是直接使用指针去关联这块内存地址。就直接通过访问我们的指针就可以拿到对象了。</li>
</ul>
<h2 id="2、JVM中如何判断对象可以回收"><a href="#2、JVM中如何判断对象可以回收" class="headerlink" title="2、JVM中如何判断对象可以回收"></a>2、JVM中如何判断对象可以回收</h2><p><font color="red">1. 引用计数法</font></p>
<p>只要有一个对象被其他对象所引用，就会让这个对象的计数器加1，没有引用就会减一，直到这个计数为0，那么这个对象就会被判定为垃圾对象。</p>
<p>缺点:如果两个对象互相引用，就会导致我们这两个对象计数器，永远都不会为0，这两个对象引用不会被回收。</p>
<p><font color="red">2、可达性分析</font></p>
<p>可达性分析算法首先会确定一系列的根对象(确定不会当作垃圾回收的对象被称为根对象),然后沿着我们的根对象进行遍历，如果一个对象直接或者间接被我们的根对象进行引用的话，那么就不是垃圾对象。如果没有引用的话，那么就是垃圾对象。</p>
<h2 id="3、可以被当作GCRoots的对象"><a href="#3、可以被当作GCRoots的对象" class="headerlink" title="3、可以被当作GCRoots的对象"></a>3、可以被当作GCRoots的对象</h2><ul>
<li>java虚拟机栈中引用的对象</li>
<li>方法区中的类静态属性引用的对象</li>
<li>方法区中的常量引用对象</li>
<li>本地方法栈中的native修饰的对象</li>
<li>加锁的一些对象，也可以作为GCRoot</li>
</ul>
<h2 id="4、java中的引用"><a href="#4、java中的引用" class="headerlink" title="4、java中的引用:"></a>4、java中的引用:</h2><p>1、强引用:常用的引用复制给一个对象，这就是强引用，jvm不会回收强引用对象。</p>
<p>2、弱引用:就是弱一点的对象，可以使用sortReference来进行修饰，将对象装饰成一个弱对象，就是当我们的堆内存中的不足的时候，会去回收。当我们的java的内存空间不足的时候，不会去进行回收。</p>
<p>3、软引用:就是更软一点的对象，可以使用我们的workReference来进行修饰。将对象装饰成一个软引用对象。只要发现垃圾回收，就会将我们的软引用进行回收。</p>
<p>4、虚引用相当于没有引用，只能搭配我们的引用队列来进行使用，ReferenceQueue。主要是来解决我们的当我们的对象被回收做一些通知操作。</p>
<h2 id="5、怎么去遍历这个可达性分析算法的。"><a href="#5、怎么去遍历这个可达性分析算法的。" class="headerlink" title="5、怎么去遍历这个可达性分析算法的。"></a>5、怎么去遍历这个可达性分析算法的。</h2><p>1、因为的可达性分析算法必须先确定我们的一系列的根对象，所以我们在确定这些根对象时，必须暂定用户线程也就是我们的常说的stw。stop the world。</p>
<p>为什么减少这个stw的时间，使用了三色标记作为工具辅导推导。按照是否访问过的这个条件标记成以下三种颜色。</p>
<ul>
<li>白色:表示该对象尚未被垃圾收集器访问过。</li>
<li>黑色:表示被遍历过，存活的对象。</li>
<li>灰色:表示中间地带。就是已经被垃圾收集器访问过，但是这个对象至少存在一个引用还没有扫描过。</li>
</ul>
<p>从三色标记这里可以知道,为什么垃圾收集器在枚举GCRoots的时候，需要将其他用户线程进行冻结。</p>
<p>如果垃圾收集线程在工作,用户线程是并发工作的，收集器在对象图上标记颜色,同时用户线程在修改引用关系-即修改对象图的结构,这可以会出现两种问题:</p>
<ul>
<li>把原本消亡的对象错误标记为存活，这是可以容忍的,下次垃圾收集器在工作时，就可以回收这些浮动垃圾。</li>
<li>把原本存活的对象错误标记为已消亡，这是不能忍受的错误。程序出现错误。</li>
</ul>
<p>一下两个条件同时满足时,会产生对象消失问题,即原本应该是黑色的对象被误标为白色:</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象到新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象到直接或间接引用</li>
</ul>
<p>增量更新:当黑色对象插入新的指向白色对象的引用关系时，就将这个关系记录下来，等并发扫描过后，再将这些记录的引用关系，重新扫描一次。</p>
<p>原始快照:当灰色对象要删除指向白色对象时的引用时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。</p>
<h2 id="6、垃圾回收算法"><a href="#6、垃圾回收算法" class="headerlink" title="6、垃圾回收算法"></a>6、垃圾回收算法</h2><p>主要分为三种:</p>
<p>1、标记-清除算法。沿着GCRoot对象的引用链去找,扫描堆中的空间,找出所有不被GCRoot直接或者间接引用的对象,然后进行标记。标记完成之后,会把这些标记完的对象进行清除，清除只是将空间的起始地址进行了一个记录,放入到了空间列表，下一次有对象来就直接使用这个空闲列表里面的空间直接进行覆盖即可。</p>
<p>缺点:会产生我们的垃圾碎片。他只是清除我们的垃圾对象，它并没有对我们的空间进行规整。我们的空间肯定是乱的啊。</p>
<p>优点：速度相对较快，因为它没有真正意义上对空间进行清除。</p>
<p>2、标记-整理算法:沿着GCRoot对象的引用链去找,扫描堆中的空间,找出所有不被GCRoot直接或者间接引用的对象,然后进行标记。标记完成之后,会把这些标记完的对象进行清理，然后会将标记对象空间后面的空间往前进行移动整理.可以解决内存碎片问题。</p>
<p>优点:不会产生内存碎片</p>
<p>缺点:就是会移动我们的内存空间，速度会慢一点。stw</p>
<p>3、复制算法:复制算法会开辟一个一摸一样大小的空间。然后在原有空间的基础上做垃圾标记，也是使用沿着GCRoot的引用链，找到所有被GCRoot直接或间接引用的对象，然后做出标记。然后在被GCRoot引用的对象放入到to(新的空间)里面,将form中的空间进行清除。清除完后,将to和from进行替换操作。to变成了from,from变成了to。</p>
<p>优点：不会产生内存碎片</p>
<p>缺点: 要使用两份的空间</p>
<p>所以在jvm中新生代里面采用了我们复制算法，但对其进行优化，jvm中from区和to区占比为8:1，也就是jvm认为90%的新生代对象都是早生夕死的。所以才可以设计。但是存在一个问题，就是当我们的清理垃圾不够的时候，也就是说我们的from空间的值大于to空间，那么怎么进行交换呢，就需要使用我们的分配担保，也就是当内存不足时，去使用一下其他的内存空间，一般都是老年代的空间。</p>
<p>什么是记忆集:</p>
<p>记忆集就是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p>
<p>主要用于解决:跨代引用时，避免去进行全表扫描非收集区域。</p>
<p>什么是卡表:</p>
<p>卡表就是我们的记忆集的一种实现方式。</p>
<p>卡表定义了记忆集的记录精度、与堆内存的映射关系等。</p>
<p>卡表本质就是一个字节数组。每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称为卡页。</p>
<p>主要卡页中存在一个一个跨代引用的指针，那么这个对应的卡表中的数组会变为1.这又被称为脏页。</p>
<h2 id="7、分带垃圾回收"><a href="#7、分带垃圾回收" class="headerlink" title="7、分带垃圾回收:"></a>7、分带垃圾回收:</h2><p>1、jvm将对中的内存分为新生代、老年代。</p>
<p>老年代又被分为三个小区域分别是:伊甸园区、幸存去from、幸存区to。</p>
<p>为什么这样划分？</p>
<p>主要是java中的有些对象需要长时间使用，这些长时间使用的对象放入到老年代，新声代中存放一些使用完之后，可以丢弃的对象，这样就可以根据对象的生命周期的不同来使用不同的垃圾回收算法.新生代因为要处理的都是一些朝生夕死的对象，所以发生垃圾回收的比较频繁。老年区因为存储着需要长时间需要的对象，需要发生垃圾回收不是很频繁。</p>
<h2 id="8、jvm堆中分配对象的流程"><a href="#8、jvm堆中分配对象的流程" class="headerlink" title="8、jvm堆中分配对象的流程"></a>8、jvm堆中分配对象的流程</h2><p>1、对象首先分配在新生代，当新生代的内存不足时，会触发minorGC，会进行一次回收</p>
<p>2、伊甸园区和幸存区from存活的对象使用copy算法复制到我们的to区中，存活的对象的年龄会加1.并且将我们from和to进行交换。</p>
<p>3、minorGC会触发stw，暂停其他用户线程，等垃圾回收结束，用户线程才会恢复运行。</p>
<p>4、当对象寿命超过阈值时，会晋升至老年代，最大寿命为15 4bit</p>
<p>5、当老年代的内存空间不足时，会先尝试触发minor gc，如果之后空间仍然不足,那么就会触发full gc，stw的时间更长。</p>
<p>6、老年代使用的算法有可能是标记清除也有可能是标记整理</p>
<p>7、大对象他会直接跳过新声代，直接放入到老年代</p>
<h2 id="9、JVM的重要的参数"><a href="#9、JVM的重要的参数" class="headerlink" title="9、JVM的重要的参数"></a>9、JVM的重要的参数</h2><p>1、堆初始大小:-Xms</p>
<p>2、栈初始大小:-Xss</p>
<p>3、堆中最大大小: -Xmx或-XX：MaxHeapsize</p>
<p>4、新生代大小: -Xmn</p>
<p>5、-Xms20m  堆初始大小</p>
<p>6、-XX:+UseSerialGC  指定我们的垃圾收集器</p>
<p>7、-XX:+ProintGCDetails  GC详情</p>
<h2 id="10、垃圾回收器"><a href="#10、垃圾回收器" class="headerlink" title="10、垃圾回收器"></a>10、垃圾回收器</h2><p>1、串行的垃圾回收器</p>
<p>Serial:单线程，适合堆内存较小，适合个人电脑。新生代的复制算法。</p>
<p>Serial old:老年代版的serial，标记整理算法。</p>
<p>缺点:当垃圾回收器线程启动的时候，其他的用户线程会进行暂停。</p>
<p>2、吞吐量优先（吞吐量是指系统在单位时间内处理请求的数量）</p>
<p>多线程版本(parallel)：适合堆内存较大，多核cpu。</p>
<p>-XX:+UseParallelGC JDk默认开启。</p>
<p>parallel scanvenge是新生代的收集器，会让我们的用户线程运行到我们的安全点。然后再去执行我们的垃圾回收线程。</p>
<p>Parallel old 老年代的收集器。</p>
<p>3、以响应时间优先:</p>
<p>cms:ConcurrentMarkSweep：并发的标记清理算法垃圾收集器，是一种以获得最短停顿时间为目标的收集器。</p>
<p>运行过程:初始标记、并发标记、重新标记、并发清除，收集结束后会产生大量的内存碎片。</p>
<blockquote>
<p>并发：是在统一时刻执行多个事情。</p>
<p>并行：是指同一时间段内执行了多个事情。</p>
</blockquote>
<p>流程:多个用户线程正在执行，到达安全点，会触发初始标记，初始标记只会标记一些根对象，初始标记完成之后，用户线程恢复运行，垃圾回收线程会执行并发标记，这时用户线程也是在运行的，所以这个时间段会产生一个浮动垃圾。因此cms会有重新标记的过程，重新标记完成之后，会触发并发清理，清除阶段是清理删除标记阶段判断已经死亡的对象，由于不需要移动存活对象，所以这个也可以与用户线程同时并发进行。</p>
<p>cms的缺点:</p>
<p>1、无法清理浮动垃圾。</p>
<p>2、占用cpu资源。</p>
<p>3、标记清理的算法，所以会出现内存碎片的问题。</p>
<p>G1 Garbage first</p>
<p>G1的目标是延迟可控的情况下获得尽可能的高的吞吐量，所以才被称为”全功能收集器”。</p>
<p>G1是一个并行回收器，他把堆内存分割成很多不相关的区域（region）.使用不同的region来表示Eden、幸存区from、幸存去to、老年代等。</p>
<p>G1有计划的规避在整个java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获的的空间大小以及所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>
<p>G1的流程:</p>
<p>1、初始标记。</p>
<p>2、并发标记。</p>
<p>3、最终标记。</p>
<p>4、筛选回收。</p>
<h2 id="11、垃圾回收调优"><a href="#11、垃圾回收调优" class="headerlink" title="11、垃圾回收调优"></a>11、垃圾回收调优</h2><p>1、确定gc垃圾回收器</p>
<p>2、使用我们的工具查看一下gc的允许情况，GC比较频繁的区域在哪。然后找准问题，然后去解决这个问题。</p>
<p>3、先去查看一下自身代码是否出现问题，如果出现了一次性查询过多的对象、使用了Map去缓存了太多的数据，也有可能会造成内存溢出。</p>
<p>4、会尝试去新生代进行调优:</p>
<ul>
<li>新生代的对象都是根据我们的分带假说来的，也就是所有的新生代的对象都是朝生夕死。</li>
<li>所有的new操作所创建的对象都会在新生代中进行分配对象，在TLAB中进行分配，也就是线程本地分配缓存区。为了解决并发创建对象的问题。使用的是隔离的策略来解决并发的问题。</li>
<li>死亡对象的回收代价是零</li>
<li>MinorGC的时间远远低于FullGC。</li>
<li>基于这些特点需要对其进行优化的话，可以适当的调整一下堆堆大小。</li>
<li>-Xmn堆参数可以设置我们的堆内存大小。</li>
<li>新生代的大小要适当，如果新生代的内存过小，会导致我们minorGC会很频繁，不断出发minorGc会导致我们的stw，会暂停我们的用户线程，会导致我们的响应时间变长。如果minorGC过大，由会产生的问题，就会不变挤压你的老年代的空间。如果老年代的空间过小，那么就可能会触发我们的FullGC。所以新生代的选择一定要适当。然后我们的jvm给出的建议是在我们的堆空间的25以上，50%一下，可以适当进行调控。</li>
<li>合适的大小可以容纳所有的并发量*(请求-响应)的数据。</li>
<li>老年代的大小能保留(当前活跃对象+需要晋升对象)</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例:"></a>案例:</h2><p>1、FullGC和MinorGC频繁。可以适当的调大一下-Xmn新生代的大小。</p>
<p>2、就是我们的视频网站，因为采用断点续传的功能，所以需要将我们的视频切割成很多块，然后进行上传，上传之前会将我们的视频文件以IO流的形式存储在我们的服务器中，这样会造成一个问题就是。因为我们采用的jdk1.8，jdk1.8默认设置就是1000000字节，就相当于1m，那么我们的视频文件切割成文件就会以大对象的形式直接放入到我们的老年代中。这也就是我们常说的大对象会直接放入到我们的老年代中。如果一旦我们的视频上传过多，那么就有可能会出现FullGC。所以为了减少我们的FullGC我们的适当的调控了一下这个大对象的参数</p>
<p><font color="red">-XX:PretenureSizeThreshold&#x3D;1000000 </font></p>
<p>3、使用我们的arthas去查看我们的jvm相关的命令。使用dashboard查看我们系统的实时数据面板。</p>
<h2 id="12、内存溢出的问题"><a href="#12、内存溢出的问题" class="headerlink" title="12、内存溢出的问题"></a>12、内存溢出的问题</h2><ul>
<li>误用线程池导致的内存溢出 newThreadFixedThreadPool默认的是LinkedBlockingQueue的无界的任务队列，会导致我们的内存溢出。</li>
<li>使用线程池会导致我们的内存溢出。newCache.因为newCache里面最大线程数是integer的最大值。导致生成大量的线程。会导致内存溢出。</li>
<li>一次查询太多数据</li>
<li>类太多</li>
</ul>
<h2 id="13、类加载的过程"><a href="#13、类加载的过程" class="headerlink" title="13、类加载的过程"></a>13、类加载的过程</h2><p>1、加载:将类的字节码载入方法区中，内部采用的是c++的instanKlass描述java类。来进行初始化。如果这个类还有父类没有加载，先记载父类。</p>
<p>2、链接:</p>
<ul>
<li><p>验证:验证类是否符合JVM规范，安全性检查。</p>
</li>
<li><p>准备:为static变量分配空间，设置默认值。static变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在准备阶段完成。如果static变量是final的，但属于引用类型，那么赋值也会在初始化阶段完成。</p>
</li>
<li><p>解析:将常量池中的符号引用解析为直接引用。</p>
<ul>
<li>符号引用就是仅仅只是一个符号，它并不知道这个对象所处的内存地址。</li>
<li>解析和作用就是将这个符号引用变为直接引用，将这个符号位变成对象的内存地址。</li>
</ul>
</li>
</ul>
<p>3、初始化。</p>
<p>⚠️注意:</p>
<p>1、main方法所在的类，会首先初始化</p>
<p>2、首先访问这个类的静态变量或静态方法时</p>
<p>3、子类初始化，如果父类还没初始化，先初始化父类</p>
<p>4、子类访问父类的静态变量，只会触发父类的初始化</p>
<p>5、Class.forName</p>
<p>6、new 会导致初始化</p>
<p>不会导致类初始化的情况:</p>
<ul>
<li>访问类的static final静态变量（静本类型和字符串）不会触发初始化</li>
<li>类对象.class不会触发初始化</li>
<li>创建该类的数组不会触发初始化。</li>
<li>类加载的loadCLass方法</li>
<li>class.forname也不会导致初始化。</li>
</ul>
<h2 id="14、类加载器"><a href="#14、类加载器" class="headerlink" title="14、类加载器"></a>14、类加载器</h2><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">加载哪都类</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Bootstrap ClassLoader</td>
<td align="left">JAVA_HOME&#x2F;jre&#x2F;lib</td>
<td align="left">无法直接访问</td>
</tr>
<tr>
<td align="left">Extension ClassLoader</td>
<td align="left">JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</td>
<td align="left">上级为bootstrap,显示为null</td>
</tr>
<tr>
<td align="left">Application ClassLoader</td>
<td align="left">class path</td>
<td align="left">上级为Extension</td>
</tr>
<tr>
<td align="left">自定义类加载器</td>
<td align="left">自定义</td>
<td align="left">上级为Application</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="15、双亲委派模式"><a href="#15、双亲委派模式" class="headerlink" title="15、双亲委派模式"></a>15、双亲委派模式</h2><p>它是类记载器的加载类的一个规则。</p>
<p>一个类加载器查找class和resource时，它首先判断这个class是不是已经加载成功，如果没有的话它并不是自己进行查找，而是先通过父加载器，然后递归下去，直到Bootstrap ClassLoader，如果Bootstrap classloader找到了，直接返回，如果没有找到，则一级一级返回，最后到达自身去查找这些对象。这种机制就叫做双亲委托。</p>
<p>发现委拖时从下向上，然后具体查找过程却是自上至下。</p>
<p>如果找不到类的话，会抛出一个classNotfountException这个异常。</p>
<h2 id="16-怎么打破双亲委派机制"><a href="#16-怎么打破双亲委派机制" class="headerlink" title="16 怎么打破双亲委派机制"></a>16 怎么打破双亲委派机制</h2><p>1、使用我们的服务发现的机制,也就是我们的spi。</p>
<blockquote>
<p>SPI:ServiceLoader机制是一种服务发现机制。它会通过在classpath路径下的META-INF&#x2F;services文件夹去查找文件，自动记载文件所定义的类。</p>
<p>规则:jar包的META-INF&#x2F;services包下，以接口全限定名为文件，文件内容是实现类名称。</p>
</blockquote>
<p>2、使用线程上下文来进行破坏。只需要使用Thread.currentThread.getClassLoader进行加载。</p>
<p>3、自定义类加载器，继承classLoader类，重写loadClass方法，获取类文件的字节码。</p>
<h1 id="javase篇"><a href="#javase篇" class="headerlink" title="javase篇"></a>javase篇</h1><h2 id="1、java的基本数据类型"><a href="#1、java的基本数据类型" class="headerlink" title="1、java的基本数据类型"></a>1、java的基本数据类型</h2><p> 整数类型:byte、short、int、long</p>
<p>浮点类型:float、double</p>
<p>布尔类型:boolean</p>
<p>字符类型:char</p>
<p>类型转换:</p>
<ul>
<li>自动类型转换:<strong>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</strong></li>
<li>转换从低级到高级。byte、short、char、int、long、float、double。</li>
<li>强制类型转换:从高转低，损失精度。byte -128～127 128最后结果是-128这就是损失了精度。</li>
<li>隐式类型转换:整数型会默认转换为int类型，浮点型会默认转换为我们的double。</li>
</ul>
<h2 id="2、JDK、JRE、JVM"><a href="#2、JDK、JRE、JVM" class="headerlink" title="2、JDK、JRE、JVM"></a>2、JDK、JRE、JVM</h2><p>1、JRE是java的运行环境，它包含我们的java程序运行所需的所有的环境。JRE只能运行程序，没有办法创建我们的java程序。</p>
<p>2、JDK是java开发的工具包，可以创建和运行我们的java程序。</p>
<p>3、jvm是java的虚拟机，我们将.java的源代码通过我们的javac命令将其编译成我们的字节码文件，放到jvm上进行运行。</p>
<p>三者之间的关系:</p>
<p>JRE包含JVM、JDK包含我们的JRE。</p>
<h2 id="3、java的进制之间的转换"><a href="#3、java的进制之间的转换" class="headerlink" title="3、java的进制之间的转换"></a>3、java的进制之间的转换</h2><p>1、在java中使用0b来表示二进制、8进制采用9来进行表示、16进制使用0x来进行表示。</p>
<p>2、二进制转换成十进制</p>
<p>底层的位数*2 的位数-1的次方</p>
<p>例子: 10  0*2^1-1+1*2^2-1&#x3D;2</p>
<p>3、8进制转换成10进制</p>
<p>8进制转十进制也是从低位开始，底位数*8(位数-1)的次方</p>
<p>例子:45<br>  5*8^1-1+4*8^2-1&#x3D;37</p>
<p>4、16进制转换成10进制</p>
<p>十六进制转十进制也是从低位开始，底位数*16(位数-1)的次方</p>
<p>16进制到10之后使用a、b、c、d、e、f表示</p>
<p>1413 十六进制是0xed</p>
<p>例子:13+14*16^2-1&#x3D;237  </p>
<p>5、十进制转换二进制</p>
<img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230403161345968.png" alt="image-20230403161345968" style="zoom:50%;" />

<p>十进制转换成二进制就是不断的除以2，直到商为0，然后将每步得到的余数倒过来，就是对应的二进制数</p>
<p>6、十进制转8进制</p>
<p>十进制转换成8进制就是不断的除以8，直到商为0，然后将每步得到的余数结果倒过来即可得到8进制。</p>
<p>7、10进制转十六进制是一样的。</p>
<p>8、二进制转8进制<br>规则:从低位开始,将二进制数每三位一组，转成对应的八进制即可。<br>案例: 0b 11 010 101 转成八进制<br>101 5  010 2 11 3 所以是0325</p>
<h2 id="4、源码、反码、补吗"><a href="#4、源码、反码、补吗" class="headerlink" title="4、源码、反码、补吗"></a>4、源码、反码、补吗</h2><p>1、二进制的最高位是符号位:0表示正数，1表示负数</p>
<p>2、正数的原码、反码、补码都一样(三码合一)</p>
<p>3、负数的反码&#x3D;它的原码符号位不变，其他位取反</p>
<p>4、负数的补吗&#x3D;它的反码+1，负数的反码&#x3D;负数的补吗-1</p>
<p>5、0的反码，补吗都是0</p>
<p>6、java没有无符号位，换言之，java中的数都是有符号的</p>
<p>7、在计算机运算的时候，都是以补吗的方式来运算的。</p>
<p>8、当我们看运算结果的时候，要看他的原码。</p>
<h2 id="5、位运算"><a href="#5、位运算" class="headerlink" title="5、位运算"></a>5、位运算</h2><p>按位与&amp;：两边全为1，结果为1，</p>
<p>按位或|:两位有一个为1，结果为1，否者为0.</p>
<p>按位异或^：两位一个为0、一个为1，结果就为1，否者为0.</p>
<p>按位取反～:0-&gt;1、1&gt;0</p>
<p>右位运算符 &#x2F;2 2&gt;&gt;2 2&#x2F;2&#x2F;2 &#x3D;0<br>&lt;&lt; 左位运算符 <em>2 2&lt;&lt;2 2</em>2*2 8<br>3&amp;4 计算过程<br>00000000 00000000 00000000 00000011 原码 3 三码和一<br>                            &amp;<br>00000000 00000000 00000000 00000100<br>00000000 00000000 00000000 00000000  补码要转成原码 结果为0</p>
<h2 id="6、访问修饰符"><a href="#6、访问修饰符" class="headerlink" title="6、访问修饰符"></a>6、访问修饰符</h2><p>1、public:表示公开，可以被任意类访问。可以修饰的对象:对象、方法、属性、接口</p>
<p>2、private:表示私有的，只能被当前类中进行使用。使用的对象:方法、属性</p>
<p>3、protected:表示受保护的，只能被当前包下的类和其子类进行访问。使用的对象:方法、属性</p>
<p>4、default:表示默认，只能被当前包下的其他类进行访问，不实用任意的修饰符。使用对象:类、方法、接口、属性</p>
<h2 id="7、break、continue、return的区别及作用"><a href="#7、break、continue、return的区别及作用" class="headerlink" title="7、break、continue、return的区别及作用"></a>7、break、continue、return的区别及作用</h2><p>1、break是跳出循环</p>
<p>2、continue:跳出本次循环，进入下一次循环</p>
<p>3、return:返回，方法的返回结果。后续不再执行。</p>
<h2 id="8、final、finally、finalize的区别"><a href="#8、final、finally、finalize的区别" class="headerlink" title="8、final、finally、finalize的区别:"></a>8、final、finally、finalize的区别:</h2><p>final:表示最终，不可修改的。</p>
<p>final修饰的类，表示该类不可被继承。</p>
<p>final修饰的方法，表示该方法不能重写。</p>
<p>final如果修饰的属性，如果是基本数据类型，一旦赋值，不允许发现更改。</p>
<p>如果修饰的引用数据类型的话，那么一旦进行复制也会导致我们的引用不可变。但是我们的引用中的值可以改变的。</p>
<p>final一般和我们的static联合起来一起使用。一般我们用来修饰常量。</p>
<p>finally:主要和我们的try、catch联合使用。表示最终一定会执行的。不管有没有发生异常都是会被执行的。经常用于释放各种资源。</p>
<p>Finalize：是object中的方法，这个方法会在gc启动时，该对象被回收时进行调用。</p>
<h2 id="9、Object中的常用方法"><a href="#9、Object中的常用方法" class="headerlink" title="9、Object中的常用方法"></a>9、Object中的常用方法</h2><p>1、toString：将我们其他的类型转换成我们的String类型</p>
<p>2、equals:比较两个对象是否相等。</p>
<p>3、clone：克隆对象，但是时浅拷贝。</p>
<p>4、hashCode：是根据我们的内存地址通过hash得来的，主要用于集合中的哈希表。通过取模获取哈希桶的下标。</p>
<blockquote>
<p>HashCode和equals为什么要都进行重写:</p>
<p>equals因为object中的方法是直接使用的&#x3D;&#x3D;的方法来进行比较，它比较多内存地址。我们的日常的比较通常是比较两个对象是否相等。如果不重写的话，那么比较多就是内存地址。重写了才会去比较我们的对象的内容。</p>
<p>HashCode为什么需要重写呢，因为我们的hashCode是基于我们的对象的内存地址，然后通过我们的hash算法得来的。主要的作用hashmap会通过我们的hashcode然后取模得到我们的数组的下标。从而可以提高我们的效率。</p>
<p>为什么需要同时重写呢?</p>
<p>1、就是因为我们对比两个对象是否相等时，我们就可以先使用的我们的HashCode进行比较，如果比较的结果是true，那么就可以使用equals再次确认两个对象是否相等，如果比较的结果是true。那就相等。这样可以提高我们的比较效率。</p>
<p>2、set集合正常使用就是保存不同的对象，相等的对象就会被我们的set进行合并，最终留下一份独一无二的数据。如果我们的对象重写了equlas方法，当没有重写我们的hashCode方法时，就会出现一个问题就是我们的set并没有进行去重。因为我们并没有重写我们的hashCode，所以默认使用的还是我们的object中的hashCode。而Object中的hashCode方法比较的是不同引用地址的对象，所以结果是 false。那么就不会执行我们的equals方法了。</p>
</blockquote>
<p>5、wait、notifyAll主要的作用就是让当前线程去进行休眠。然后通过我们的notifyAll的进行唤醒。这样就可以起到我们的线程之间的通信。wait和notify必须和我们的synchronized一起使用。</p>
<p>6、finalize:当我们的垃圾回收该对象的时候，会去调用一下这个方法。这个方法主要的作用应该就是起到了一个通知的作用。但是已被标记为废弃的方法。</p>
<p>7、getClass，通过这个方法可以获取到对象对应的class对象。</p>
<h2 id="10-static关键字作用"><a href="#10-static关键字作用" class="headerlink" title="10 static关键字作用"></a>10 static关键字作用</h2><p>1、什么是static</p>
<p>static在我们的java程序中，被称为静态的。表示是属于我们的类的，而不是属于我们的对象的。当我们的一个属性被static进行修饰时，会在我们的类加载时，为其进行赋值操作。如果是引用的话，会在初始化阶段进行赋值。如果是基本数据类型，就会在准备阶段为其进行赋值。被我们static进行修饰的属性会被放到我们的方法区。</p>
<p>2、怎么用:</p>
<p>一般情况static和我们的final一起进行使用，用来修饰常量。还有就是在使用我们的简单工厂模式的时候，为了使用方便，会将工厂方法标注成我们的static。</p>
<p>可以用来修饰我们的属性、方法。修饰的属性叫做静态成员变量。修饰方法就叫做我们的静态方法。</p>
<blockquote>
<p>静态变量和我们实例变量的区别?</p>
<p>1、静态变量不属于我们的对象的，属于我们的类，所以在内存中只会存在一份。类记载的过程中，准备阶段会为其进行空间的分配，然后为其进行赋值操作。如果是使用final修饰的引用的话，会在初始化阶段，为其进行赋值操作。</p>
<p>2、实例变量是我们的对象，每次当我们去创建该对象时，jvm才会在堆内存中为其开辟空间，进行赋值操作。在java中可以存在多份的。</p>
</blockquote>
<h2 id="11、java的代码执行顺序"><a href="#11、java的代码执行顺序" class="headerlink" title="11、java的代码执行顺序"></a>11、java的代码执行顺序</h2><p>1、基本上的代码块分为:静态代码块、构造代码块、普通代码块.</p>
<p>2、代码块的顺序:静态代码块—&gt;构造代码块—-&gt;普通的代码块</p>
<p>3、继承中代码执行顺序:父类的静态代码块、子类的静态代码块、父类的代码块、父类的构造器、子类的代码块、子类的构造器。</p>
<h2 id="12、面向对象的特征"><a href="#12、面向对象的特征" class="headerlink" title="12、面向对象的特征"></a>12、面向对象的特征</h2><p>1、封装:将对象中的一些复杂的属性和方法进行封装，不对外界暴露一些实现细节。</p>
<p>作用:屏蔽复杂、暴露简单。</p>
<p>通常对使用：就是使用我们的private进行修饰，然后通过我们的get、set方法对外进行暴露，供外界进行操作。</p>
<p>2、继承:就是子类继承我们的父类，可以获取我们的父类中的属性和方法。并且父类中的方法不满足我们的需要可以对其进行重写。继承比较多作用就是可以让我们的代码进行复用。减少了一些重负代码的编写。比如说像我们的设计模式中的模版设计模式，就是使用我们的继承。通过继承我们模版抽象方法，去实现我们里面的抽象方法，而从得到我们的模版方法得到我们复用。然后对一些需要改变的方法，可以进行重写。这就是我们的继承的作用。还有一大作用就是的多态。</p>
<p>3、多态:同一类型的对象，执行同一个行为，在不同的状态下会表现出不同的行为特征。</p>
<p>多态分为:编译时多态和运行时多态</p>
<p>编译时多态:在编译时的时候，可以发生多种状态,一般的实现形式就是方法重载。</p>
<p>运行时多态:在多态中需要将子类的引用赋值给父类对象，只有这样的引用才能既可以调用父类的方法，又能调用子类的方法。</p>
<blockquote>
<p>私有方法和静态方法能被重写吗?</p>
<p>不能。私有方法只能在本类中进行使用，你没有办法在子类中使用父类的私有方法。</p>
<p>静态时属于父类的，并没有继承给子类，都没有继承，何来的重写呢？</p>
</blockquote>
<h2 id="13、重载和重写"><a href="#13、重载和重写" class="headerlink" title="13、重载和重写"></a>13、重载和重写</h2><p>方法重载：指同一个类中的多个方法具有相同的名字,但这些方法具有不同的参数列表,即参数的数量或参数类型不能完全相同<br>方法重写：存在子父类之间的,子类定义的方法与父类中的方法具有相同的方法名字,相同的参数表和相同的返回类型 </p>
<p>重写的规则:<br> 　1. 参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。<br> 　2. 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。<br> 　3. 返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。<br> 　4. 访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</p>
<p>重载的规则：</p>
<ul>
<li>必须具有不同的参数列表；</li>
<li>可以有不责骂的返回类型，只要参数列表不同就可以了；</li>
<li>可以有不同的访问修饰符</li>
<li>可以抛出不同的异常</li>
</ul>
<blockquote>
<p>构造器是否可被重写<br>构造器不能被继承，因此不能被重写，但可以被重载。每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须一开始调用父类的构造函数。</p>
</blockquote>
<h2 id="14-抽象类和接口的区别是什么？"><a href="#14-抽象类和接口的区别是什么？" class="headerlink" title="14 抽象类和接口的区别是什么？"></a>14 抽象类和接口的区别是什么？</h2><p>相同点:</p>
<p>1、抽象类和接口都可以存在我们的抽象方法。</p>
<p>2、抽象类和接口都不能创建对象。</p>
<p>不同点:</p>
<p>1、抽象类中可以存在普通的成员方法、接口中载jdk1.8之后，可以存在default方法。</p>
<p>2、抽象可以声明成员变量，而接口中声明的成员变量都是常量。</p>
<p>3、接口中不能含有静态代码块以及静态方法，抽象类可以有静态代码块和静态方法。</p>
<p>4、一个接口可以被多次实现，一个抽象类只能被继承一次。</p>
<p>注意:定义抽象类就是让其他类继承，所以不能使用final进行修饰。</p>
<h2 id="15、java创建对象的几种方式"><a href="#15、java创建对象的几种方式" class="headerlink" title="15、java创建对象的几种方式"></a>15、java创建对象的几种方式</h2><p>1、第一中是通过我们的new关键字去进行创建。</p>
<p>2、使用我们Object中的clone方法进行克隆。</p>
<p>3、使用序列化和反序列化。使用ObjectOutputStream的流进行序列化。</p>
<p>4、使用我们的反射去创建我们的对象，通过class对象的newInstance静态方法调用无参的构造器创建对象。</p>
<h2 id="16、浅拷贝和深拷贝的区别"><a href="#16、浅拷贝和深拷贝的区别" class="headerlink" title="16、浅拷贝和深拷贝的区别"></a>16、浅拷贝和深拷贝的区别</h2><p>浅拷贝是将对象的进行拷贝，但是这个对象如果存在一些引用对象，不会进行克隆的，而是直接使用原对象的同一份数据。</p>
<p>深拷贝是指将对象进行克隆，但是会将这个对象中的其他引用对象，也会进行克隆。</p>
<blockquote>
<p>浅考贝的话直接使用我们实现我们的Cloneable，实现我们的方法clone方法。在里面直接使用super()调用即可完成浅拷贝。</p>
<p>深拷贝:要使用的我们的ObjectOutputStream来进行序列化。</p>
</blockquote>
<h2 id="17、值传递和引用传递的区别是什么"><a href="#17、值传递和引用传递的区别是什么" class="headerlink" title="17、值传递和引用传递的区别是什么"></a>17、值传递和引用传递的区别是什么</h2><p>1、值传递指的是方法调用时，传递的参数是按值的拷贝传递的，传递的值的拷贝，也就是传递后就互不相关了。</p>
<p>2、引用传递指的是在方法调用时，传递的参数时按引用进行传递，其实传递的是引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是传递前和传递后都指向同一个引用空间。</p>
<p>基本数据类型作为参数被传递肯定是值传递，引用类型做参数被传递也是我们的值传递，只不过是传递的引用所指向的内存地址。</p>
<h2 id="18、-x3D-x3D-和equals的区别"><a href="#18、-x3D-x3D-和equals的区别" class="headerlink" title="18、&#x3D;&#x3D;和equals的区别"></a>18、&#x3D;&#x3D;和equals的区别</h2><p>&#x3D;&#x3D;比较的基本的是基本数据类型，比较的是值，如果是比较的引用数据类型，那么比较的就是其内存地址是否相同。<br>equals,如果没有被重写，那么它底层使用的就是&#x3D;&#x3D;，如果有被重写，那么它判断就是两个对象的内容是否相等。</p>
<p>hashCode就是获取哈希码。也称为散列码。返回一个int整数。</p>
<p>hashCode和equals的关系就是:<br>如果hashCode值相等，那么这两个对象可能相同。<br>如果hashCode的值不相等，那么这两个对象肯定不相等。</p>
<h2 id="19、String为什么被设计成不可变"><a href="#19、String为什么被设计成不可变" class="headerlink" title="19、String为什么被设计成不可变"></a>19、String为什么被设计成不可变</h2><p>1、便于实现字符串常量池(String pool)</p>
<p>在java程序中，String被大量使用，如果每次声明一个String都去创建一个对象，那么将会造成极大的资源浪费。java中提出了字符常量池的概念来进行解决。就是创建一个常量池，将字符串放入其中，对已存在的字符串，直接服用即可就可以，没必要再去创建对象。</p>
<p>2、线程安全，因为String是不可变得。</p>
<p>3、避免安全问题。</p>
<p>因为在web开发中很多场景都使用了String做参数，比如一些url、路径地址之类都是使用String做为参数。将其设计成不可变对象，在一定程度上保证了程序的安全。</p>
<p>4、加快了字符串的处理速度。</p>
<p>由于字符串不可变，保证了HashCode的唯一性，于是在创建的对象时hashCode就可以放心的缓存了，不需要在重新计算。这也是我们map会为什么会喜欢将key选为String的原因。</p>
<h2 id="20、String、StringBuilder、StringBuffer"><a href="#20、String、StringBuilder、StringBuffer" class="headerlink" title="20、String、StringBuilder、StringBuffer"></a>20、String、StringBuilder、StringBuffer</h2><p>1、String是不可变的，因为其底层使用的是一个byte[]类型的数据，使用private final进行修饰。并没有提供对外进行操作的方法，所以没有办法对其进行修改。所以说String是不可变的。</p>
<p>2、StringBuilder和StringBuffer一个是线程不安全的，一个是线程安全的。这两个类都是用于字符串拼接的。都是使用apppend方法进行字符串拼接。但是因为我们的StringBuufer里面的方法使用的是synchronized简单的进行修饰，解决了线程安全问题，但是锁的粒度，很大。很耗费性能。</p>
<p>3、StringBuilder是非线程安全的。所以平常都是使用StringBuilder来拼接字符串。只能保证了在方法里面，不要超出方法的作用域，一般是不会出现线程安全的问题的。</p>
<h2 id="21、String的比较"><a href="#21、String的比较" class="headerlink" title="21、String的比较"></a>21、String的比较</h2><p><img src="https://cdn-a.markji.com/files/63e86bb86851df0522d3f23f_hd.png?e=1680517495782&token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:gJr3YWOwWn-4uqo2SNENRuEUqZc=" alt="img"></p>
<p>new String(“aaa”)与String str&#x3D;”aaa” 创建了几个对象。</p>
<p>new String一个对象，会在heap堆中分配空间存放新对象,同时会将”aaa”字符串放入常量池，相等于创建了两个对象。<br>String str&#x3D;”aaa”; 程序运行中会在字符常量池中查找”aaa”字符串，若没有,会将“aaa”字符串放进常量池,再将其地址赋给str.若有,将找到的”aaa”字符串的地址赋给a。</p>
<p>intern函数的作用是将对应的符号常量进入特殊处理，在DK1.6以前和JDK1.7以后有不同的处理；<br>在到DK1。6中，intern的处理是先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量，如果没有找到，则将该字符串常量加入到字符串常量区，也就是在字符串常量池中建立该常量；<br>在到JDKI1.7中，intern的处理是先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量，如果没有找到，说明该字符串常量在堆中，则处理是把堆区该对象的引用加入到字符串常量池中， 以后别人拿到的是该字符串常量的引用，实际存在堆中。</p>
<h2 id="22、包装类和基本数据类型"><a href="#22、包装类和基本数据类型" class="headerlink" title="22、包装类和基本数据类型"></a>22、包装类和基本数据类型</h2><p>1、包转类是引用数据类型，作用就是将我们的基本数据类型包转成引用数据类型，然后可以使用引用数据类型里面的方法。</p>
<p>2、java的容器类，只能存储我们的引用数据类型，不能存储我们的基本数据类型的。所以需要将基本数据类型转换成引用数据类型。</p>
<p>3、包转类型转换成基本数据类型成为拆箱，将基本数据类型转换成引用数据类型称为装箱。</p>
<p>4、基本数据存在默认值。而我们的包转类型的默认值是null。但是我们的数据库里的数据可能为null，如果使用基本数据类型的话，会进行拆箱操作。有可能会抛出为的NullPointException异常。</p>
<h2 id="23、String中常用的方法"><a href="#23、String中常用的方法" class="headerlink" title="23、String中常用的方法"></a>23、String中常用的方法</h2><p>chatAt:返回索引处的字符。参数是一个int整数、返回值是一个char类型</p>
<p>compareTo:比较两个字符串是否相等。参数是一个字符串</p>
<p>1、如果指定的数与参数相等返回0。</p>
<p>2、如果指定的数小于参数返回 -1。</p>
<p>3、如果指定的数大于参数返回 1。</p>
<p>equals比较的是两个字符串是否相等。</p>
<p>endsWith:是否以这个字符串结尾。参数是一个字符串，返回值是一个boolean类型。</p>
<p>startsWith:是否以这个字符串为开头，参数也是一个字符串，返回值是一个boolean类型。</p>
<p>equalsIgnoreCase:不区分大小的比较。</p>
<p>indexOf:返回第一次出现在字符串中的索引地址。</p>
<p>replace:替换我们的字符串对象。参数为两个char类型，一个是原字符串中的字符，一个要替换的字符。</p>
<p>lastIndexOf：最后一次出现在字符串中的索引位置。</p>
<p>subString:截取字符串。参数是一个int类型，从那开始.</p>
<p>Split:将字符串以某个格式进行分割，返回新的字符数组。</p>
<h2 id="24、类型之间的转换"><a href="#24、类型之间的转换" class="headerlink" title="24、类型之间的转换"></a>24、类型之间的转换</h2><p>Integer转换成String字符串类型:使用toString。</p>
<p>String类型转换成字符串使用Integer.parseInt来进行转换</p>
<h2 id="25、int和Integer的有什么区别"><a href="#25、int和Integer的有什么区别" class="headerlink" title="25、int和Integer的有什么区别"></a>25、int和Integer的有什么区别</h2><p>integer是int的类型的包装类，int是数据数据类型。</p>
<p>integer变量必须实例化才能使用，int变量不需要。</p>
<p>integer实际是对象的引用，指向此new的Integer对象，int是直接存储就是我们的数值。</p>
<p>Integer的默认值是null，int的默认值是0.</p>
<p>扩展:</p>
<p>Integer变量和int变量的对比</p>
<p>Integer变量和int变量比较时,只要两个变量的值是相等的，则结果为true</p>
<p>因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int,然后进行比较，实际上就变味了两个int变量的比较。</p>
<p>两个非new生成的Integer对象的对比</p>
<p>对于两个非new生成的Integer对象,进行比较时,如果两个变量的值在区间-128~127之间,则比较结果为true，如果两个变量的值不在此区间，则比较结果为false</p>
<h2 id="26、反射"><a href="#26、反射" class="headerlink" title="26、反射"></a>26、反射</h2><p>反射是在运行状态下，动态的获取任意一个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性;这种动态获取的信息以及动态调用对象的方法的功能称为java的反射。</p>
<p>反射的优缺点有哪些?</p>
<p>优点：能够运行时动态获取类的实例,提高灵活性,可与动态编译结合</p>
<p>缺点:使用反射性能较低,需要去解析我们的字节码文件，将内存中的对象进行解析。所以它的性能会有所降低。<br>其解决方案是:通过setAccessible(true)关闭jdk 的安全检查来提升反射速度。</p>
<h2 id="27、如何获取反射中的class对象"><a href="#27、如何获取反射中的class对象" class="headerlink" title="27、如何获取反射中的class对象"></a>27、如何获取反射中的class对象</h2><p>1、通过Class.forName(“类的权限定路径”)</p>
<p>2、第二种通过对象名.class的方式也可以获取我们的Class对象</p>
<p>3、可以通过我们的对象的getClass，也可以获取我们的Class对象。</p>
<p>4、如果是基本数据类型的包装类，可以使用包装类的TYPE属性，来获取我们的Class对象。</p>
<pre class=" language-java"><code class="language-java">        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> aClass <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"字符串/User.java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aClass<span class="token punctuation">)</span><span class="token punctuation">;</span>

        Class<span class="token operator">&lt;</span>User<span class="token operator">></span> userClass <span class="token operator">=</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>

        User user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">User</span><span class="token operator">></span> aClass1 <span class="token operator">=</span> user<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Class<span class="token operator">&lt;</span>Integer<span class="token operator">></span> type <span class="token operator">=</span> Integer<span class="token punctuation">.</span>TYPE<span class="token punctuation">;</span>
</code></pre>
<h2 id="28、java中的反射api"><a href="#28、java中的反射api" class="headerlink" title="28、java中的反射api"></a>28、java中的反射api</h2><p>java反射API的有几类</p>
<p>1、Class类:反射的核心类,可以获取类的属性、方法等信息</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//class类，反射的核心api</span>
        <span class="token comment" spellcheck="true">//第一种直接通过对象的class来获取我们的核心api</span>
        Class<span class="token operator">&lt;</span>Student<span class="token operator">></span> studentClass <span class="token operator">=</span> Student<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//        第二种使用我们的对象的</span>
        Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Student</span><span class="token operator">></span> aClass <span class="token operator">=</span> student<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment" spellcheck="true">//第三种是forName来获取我们的class对象</span>
<span class="token comment" spellcheck="true">//        Class&lt;?> aClass1 = Class.forName("反射/Student.java");</span>

        <span class="token comment" spellcheck="true">//获取它的字节码的文件名 获取的权限定路径名</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>studentClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//类载器</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>studentClass<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//</span>
        
    <span class="token punctuation">}</span>
</code></pre>
<p>2、Field类:反射包下的类，表示类的成员变量，可以用来获取和设置类之中的属性值</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//      获取我们的成员属性</span>
        Field field <span class="token operator">=</span> studentClass<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"stuNo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        field<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//获取我们的属性名</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//通过我们的newInstance来创建我们的对象</span>
        Student student1 <span class="token operator">=</span> studentClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//set设置我们的成员属性</span>
        field<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>student1<span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//get获取我们的成员属性</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>student1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>3、Method类:反射包下的类,表示类的方法，它可以用来获取类中的方法信息或执行方法。invoke方法，可以执行方法。</p>
<pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">//获取所有的方法</span>
        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> declaredMethods <span class="token operator">=</span> studentClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Method method <span class="token operator">:</span> declaredMethods<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">//获取class中的方法，第一参数是方法的名称，第二个参数是我们的传入的参数类型</span>
        Method method <span class="token operator">=</span> studentClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"setName"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//使用invoke执行我们的方法,第一个参数表示是那个对象，因为我们的方法和属性是属于我们对象的，必须先创建出对象，才能去调用他们。</span>
        <span class="token comment" spellcheck="true">//        第二个参数，你要执行的方法，传入的参数</span>
        method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>student1<span class="token punctuation">,</span> <span class="token string">"李四"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>4、Constructor类,可以用来类的构造器方法</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取我们的constructor 参数是我们的构造器的参数的类型</span>
        Constructor<span class="token operator">&lt;</span>Student<span class="token operator">></span> constructor <span class="token operator">=</span> studentClass<span class="token punctuation">.</span><span class="token function">getDeclaredConstructor</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">//构造器的名称</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>constructor<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//调用我们的构造器</span>
        Student student2 <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student2<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="29、反射的作用"><a href="#29、反射的作用" class="headerlink" title="29、反射的作用"></a>29、反射的作用</h2><p>1、反射让开发人员通过外部类的全限定路径名创建对象。并使用这些类，实现一些扩展的功能。</p>
<p>2、反射能提高程序的灵活性。</p>
<p>具体的应用:</p>
<p>1、加载JDBC的驱动</p>
<p>2、Spring的Bean的加载并创建。</p>
<h2 id="30、java中的泛型的作用"><a href="#30、java中的泛型的作用" class="headerlink" title="30、java中的泛型的作用"></a>30、java中的泛型的作用</h2><p>什么是泛型？</p>
<p>泛型主要是用于规范我们的集合的类型。如果没有泛型的话，我们不管是什么类型的对象存储到集合中，都会转化为我们的Object类型。如果进行取出的话也会是Object类型。这样如果发生转化的话，就会出现一些类型转换异常。</p>
<p>泛型是一种语法糖，泛型这种类的基本原理就是我们的泛型擦除。java泛型基本都是在编译阶段这个层面来进行实现，也就是说:泛型只存在编译阶段，而不存在我们的运行阶段。在编译后的class文件中，是没有泛型这个概念的。</p>
<p>泛型擦除:使用泛型的时候加上的类型的参数，编译器在编译的时候去掉类型的参数。</p>
<p>泛型的作用:</p>
<p>1、规范我们集合的类型，在我们创建这个集合的时候，就可以根据我们的泛型去规定我们集合中的元素的类型。</p>
<p>2、避免我们的类型转换异常，就是如果我们不使用泛型的话，存进集合中的对象都会转换成Object类型，取出还是Object类型。如果发型类型转换，有可能会报类型转换错误。</p>
<p>3、增加了程序的可读性。</p>
<h2 id="31、泛型中的限定通配符和非限定通配符"><a href="#31、泛型中的限定通配符和非限定通配符" class="headerlink" title="31、泛型中的限定通配符和非限定通配符"></a>31、泛型中的限定通配符和非限定通配符</h2><p>1、限定通配符对类型进行了限制。有两种限定通配符，</p>
<p>一种是&lt;？extends T&gt;它通过确保类型必须是T的子 类来设定类型的上界。</p>
<p>另一种是&lt;？super T&gt;它通过确保类型必须是T的父类来设定类型的下界。</p>
<p>泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。</p>
<p>2、非限定通配符？，可以用任意类型来替代。如Lst&lt;?&gt;的意思是这个集合是一个可以持有任意类型的集合，它可以是List<A>，也可以是List<B>，或者List<C>等等。</p>
<h2 id="32、java的序列化和反序列化"><a href="#32、java的序列化和反序列化" class="headerlink" title="32、java的序列化和反序列化"></a>32、java的序列化和反序列化</h2><p>1、将java对象转换成字节码进行输出，这就是我们的序列化</p>
<p>2、反序列化是指将我们的文件转换成我们的java对像。</p>
<p>3、序列化:序列化是把对象转换成有序字节流,以便在网络上传输或者保存在本地文件中。</p>
<p>核心作用是对象的保存和重建。我们知道java中的对象都是保存在我们的heap中的，一旦java heap不存在了，那么我们的java对象也就跟着消失了，而序列化提供了我们一种机制，就是可以将java对象转换成有序字节流存储在文件中，保存到磁盘。进行持久化保存。当我们需要的时候，重新进行加载即可。</p>
<p>4、反序列化:客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p>
<h2 id="33、为什么需要序列化和反序列化"><a href="#33、为什么需要序列化和反序列化" class="headerlink" title="33、为什么需要序列化和反序列化"></a>33、为什么需要序列化和反序列化</h2><p>1、对象序列化可以实现分布式对象</p>
<p>2、java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据</p>
<p>可以使用java序列化来完成对象的深拷贝，因为java的序列化，不仅会将当前对象进行序列化，而且会将我们对象中引用的对象也进行序列化。</p>
<p>3、序列化可以将内存中的类写入文件或数据库中</p>
<p>4、对象、文件、数据有许多不同的格式，很难统一传输和保存</p>
<p>序列化的实现方式:</p>
<p>1、需要将我们序列化的对象实现我们的Serializable加上我们的版本号。</p>
<p>2、有一些属性不需要序列化的话，可以使用我们的Transent来进行标注。</p>
<p>为什么需要我们的版本号:</p>
<p>就是因为我们java序列化的时候，会将我们的版本号一起序列化出去，如果不写，jvm会自动帮我们生成一个序列化uid，然后与属性一起进行序列化。在反序列化的时候，会先比较我们的版本号是否一致，如果一致，进行反序列化。如果不一致会报完名的序列化不一致异常。</p>
<h2 id="34、Java中的异常"><a href="#34、Java中的异常" class="headerlink" title="34、Java中的异常"></a>34、Java中的异常</h2><blockquote>
<p> 什么是异常?</p>
<p>就是指java程序运行过程中出现了错误，就是发生了异常。</p>
<p>在java中异常是一个类的形式来表示的。</p>
<p>在java程序中，出现了问题，jvm会直接new出一个对应的异常类，然后打印这个异常信息到我们 控制态上。</p>
</blockquote>
<p>1、java中所有的异常都有一个共同的祖先Throwable，Throwable类下有两个重要的子类:Exception类和Error类。</p>
<p>2、Exception和Error二者是java异常处理的重要子类，各自包含大量子类。</p>
<p>3、Exception:程序本身可以处理的异常，可以通过catch来进行捕捉，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。</p>
<p>4、Error:属于程序无法处理的错误，我们没有办法通过catch来进行捕获。例如:内存空间不足、系统崩溃等。编译器不会这这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本省无法恢复。</p>
<p><img src="https://img2020.cnblogs.com/blog/2057228/202007/2057228-20200706221142157-1058203780.png" alt="异常结构"></p>
<h2 id="35、非受检查异常和受检异常的区别是什么"><a href="#35、非受检查异常和受检异常的区别是什么" class="headerlink" title="35、非受检查异常和受检异常的区别是什么?"></a>35、非受检查异常和受检异常的区别是什么?</h2><p>1、是我们的Exception下面的子类。分为Check Exceptions和UnCheckExceptions两个类。</p>
<p>2、非受检查异常表示:在jvm运行期间可能会发生异常。java编译器不会检查这些异常。所以可以在编译阶段，不对其进行处理。常见的异常有:NullpointException、NumberformartException、数组下标越界、ClasscastException类型转换异常。</p>
<p>3、受检异常:表示jvm在运行期间一定会发生异常，所以要求我们在java编写阶段，要进行处理，使用try-catch和我们throw进行处理，都是可以的。但是一定要处理。常见的受检异常包括:SQLException、ClassNotFoundException、IOException。</p>
<p>4、区别:就在于是否需要在编译阶段强制要求我们进行处理，要求的就是我们的编译异常，不要求的就是非受检查异常。</p>
<h2 id="36、thorw和throws的区别是什么"><a href="#36、thorw和throws的区别是什么" class="headerlink" title="36、thorw和throws的区别是什么"></a>36、thorw和throws的区别是什么</h2><p>在java程序中只有两种处理异常的方式，一种使用try和catch进行捕捉，</p>
<p>一种是进行抛出，让它的调用者来进行处理。可以使用thorws可以使用在方法上进行抛出，throw只能在方法里面进行抛出。</p>
<p>throw在方法中进行抛出，但是只能抛出一种异常。thorws在方法上进行抛出，可以抛出多个异常。</p>
<h2 id="37、NotClassDefoundError和ClassNotFoundException的区别"><a href="#37、NotClassDefoundError和ClassNotFoundException的区别" class="headerlink" title="37、NotClassDefoundError和ClassNotFoundException的区别?"></a>37、NotClassDefoundError和ClassNotFoundException的区别?</h2><p>NotClassDefoundError是一个错误，在java程序中，错误是没有办法进行处理，必须由程序员手动的进行更改才可以。该错误的产生的原因是类加载错误，也就是jvm在尝试去加载这个类的时候，没有找到该类。那么在运行时就会抛出该错误。</p>
<p>ClassNotFoundException是一个异常，可以使用trycatch进行处理，或者使用throw进行抛出处理。异常产生的原因就是: 通过我们的反射去加载该类的时，没有找打该类。那么机会抛出这个异常。</p>
<h2 id="38、try、catch、finally那部分可以省略？"><a href="#38、try、catch、finally那部分可以省略？" class="headerlink" title="38、try、catch、finally那部分可以省略？"></a>38、try、catch、finally那部分可以省略？</h2><p>catch可以省略.更为严格的说法就是:try只适合处理运行时异常,try+catch适合处理运行时异常+普通异常。也就是说，如果你只使用处理普通异常却不加以catch处理，编译时不通过。因为编译器硬性规定，普通异常如果选择捕获，则必须加上catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以可以省略,你加上catch编译器也觉得无可厚非。</p>
<p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须 用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕 获以便进一步处理。<br>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾“处理。</p>
<p>至于加上finally，则是不管有没有捕捉异常，都要进行的扫尾处理。</p>
<h2 id="39、try-catch-finally中，如果catch中return了finally还会执行吗"><a href="#39、try-catch-finally中，如果catch中return了finally还会执行吗" class="headerlink" title="39、try-catch-finally中，如果catch中return了finally还会执行吗?"></a>39、try-catch-finally中，如果catch中return了finally还会执行吗?</h2><p>还是会执行的。会在return之前执行。</p>
<p>在finally中改变返回值的做法是不好的，因为如果存在finally代码块，try中的return语句不会立马进行返回调用者，而是记录下返回值待finally代码块执行完毕之后再向调用者返回其值,然后如果在finally中修改了返回值，就会返回修改后的值。显然，在finllay中返回或者修改返回值会对程序造成很大的困扰，java中也可以通过提升编译器的语法检查级别产生警告或错误。</p>
<h2 id="40、jvm如何处理异常"><a href="#40、jvm如何处理异常" class="headerlink" title="40、jvm如何处理异常?"></a>40、jvm如何处理异常?</h2><p>在一个执行过程中，如果一个方法发生了异常，就会创建一个异常对象，并转交给jvm，该异常对象包含异常名、异常信息、以及异常发生时应用程序的状态。创建异常对象并交给jvm的过程称为抛出异常。可以有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p>
<p>jvm会顺着调用栈去查找看是否可以处理异常的代码，如果有，则调用异常处理代码。当jvm发现可以处理异常的代码时，会把发生的异常传递给它。如果jvm没有找到可以处理该异常的代码块，jvm就会将该异常转交给默认的异常处理器，默认异常处理器打印异常信息并终止应用程序。</p>
<h2 id="41、Java中IO流"><a href="#41、Java中IO流" class="headerlink" title="41、Java中IO流"></a>41、Java中IO流</h2><p>1、java中的按照流的方法分为:输入(intputStream)、输出(OutputStream)</p>
<p>2、按照实现功能的分为:节点流(可以从或向一个特定的地方读写数据，如FilReader)和处理流(是一个以存在的流的连接和封装,通过所封装的流的功能调用实现数据读写BufferedReader)</p>
<p>3、按照处理数据的单位:字节流、字符流.分别是四个抽象类来表示：InputStream、OutputStream、Reader、Writer.java中其他多种多样的流都是从它们派生出来的。</p>
<p>字节流如何转换为字符流</p>
<p>字节输入流转字符输入流通过InputStreamReader实现，该类的构造函数可以传入InputStream对象。<br>字节输出流转字符输出流通过OutputStreamWriter实现，该类的构造函数可以传入OutputStream对象。</p>
<h2 id="42-、字符流与字节流的区别"><a href="#42-、字符流与字节流的区别" class="headerlink" title="42 、字符流与字节流的区别:"></a>42 、字符流与字节流的区别:</h2><p>读写的时候字节流是按字节读写，字符流按字符读写。</p>
<p>字节流适合所有类型文件的数据传输，因为计算机字节(Byte)是电脑中表示信息含义的最小单位。字符流只能够处理纯文本数据，其他类型数据不行，但是字符流处理文本要比字节流处理文本要方便。</p>
<p>在读写文件需要对内容按行处理，比如比较特定字符，处理某一行数据的时候一般会选择字符流 。只是读写文件，和文件内容无关时，一般选择字节流。</p>
<h2 id="43、IO流中常用流"><a href="#43、IO流中常用流" class="headerlink" title="43、IO流中常用流"></a>43、IO流中常用流</h2><p>1、文件专属<br>Java.io.FileInputStream 字节输出流</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>
        File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"/Users/kevintam/project/Review-Java/Day-1/src/main/java/IO流/date.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> temp<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>temp<span class="token operator">=</span>fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre>
<p>Java.io.FileOutputStream 字节的输出流<br>Java.io.FileReader 字符的输入流<br>Java.io.FileWrite 字符的输出流<br>2、转换流 (将字节流转换为字符流)<br>java.io.InputStreamReader 将我们的字节转换成字符流<br>java.io.OutputStreamWrite<br>3、缓存流专属<br>java.io.BufferedReder 自带换取区的流<br>java.io.BufferedWrite<br>java.io.BufferedInputStream<br>java.io.BufferedOutputStream<br>4、数据流专属<br>java.io.DataInputStream<br>java.io.DataOutputStream<br> 5、对象专属流<br>java.io.ObjectInputStream<br>java.io.ObjectOutputStream<br> 6、标志输出流<br>java.io.PrintWrite<br>java.io.PrintStream  </p>
<h2 id="44、什么是阻塞io、什么是非阻塞IO"><a href="#44、什么是阻塞io、什么是非阻塞IO" class="headerlink" title="44、什么是阻塞io、什么是非阻塞IO?"></a>44、什么是阻塞io、什么是非阻塞IO?</h2><p>IO操作包括:对硬盘的读写、对socket的读写以及外设的读写。</p>
<p>当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞O来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：</p>
<p>1、查看数据是否就绪<br>2、进行数据拷贝(内核将数据拷贝到用户线程)</p>
<p>那么阻塞(blocking IO)和非阻塞(non-blocking IO)的区别就在于第一个阶段，如果数据没有就绪， 在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。</p>
<p>Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。</p>
<blockquote>
<p>BIO、NIO、AIO的区别:</p>
<p>BIO：同步并阻塞，在服务器中实现的模式为一个连接一个线程。也就是说，客户端有连接请求<br>的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开<br>销，当然这也可以通过线程池机制改善。B1O一般适用于连接数目小且固定的架构，这种方式对<br>于服务器资源要求比较高，而且并发局限于应用中，是jDK1.4之前的唯一选择，但好在程序直观简<br>单，易理解。</p>
<p>NIO：同步并非阻塞，在服务器中实现的模式为一个请求一个线程，也就是说，客户端发送的连<br>接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。<br>NIO一般适用于连接数目多且连接比较短（轻操作）的架构，并发局限于应用中，编程比较复<br>杂，从jDK1.4开始支持。</p>
<p>AIO：异步并非阻塞，在服务器中实现的模式为一个有效请求一个线程，也就是说，客户端的1O<br>请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO一般适用于连接<br>数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从<br>DK1。7开始支持。</p>
</blockquote>
<h2 id="45-、NIO的三大组件"><a href="#45-、NIO的三大组件" class="headerlink" title="45 、NIO的三大组件"></a>45 、NIO的三大组件</h2><p>1、Channel和Buffer</p>
<p>channel有一点类似于stream流，他就是读写数据的双向通道，可以从channel将数据读入buffer，也可以将buffer的数据写入channel，而之前的stream要么是输入，要么是输出，channel比stream更为底层。</p>
<pre class=" language-mermaid"><code class="language-mermaid">graph LR
channel --> buffer
buffer --> channel
</code></pre>
<p>常见的channel有:</p>
<ul>
<li>FileChannel</li>
<li>DataramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>Buffer则用来缓冲读写数据，长江的buffer有</p>
<ul>
<li>ByteBuffer<ul>
<li>MappedByteBuffer</li>
<li>DirectByteBuffer</li>
<li>HeapByteBuffer</li>
</ul>
</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
<li>CharBuffer</li>
</ul>
<p>selector的作用就是配合一个线程来管理多个channel，获取这些channel上发生的事件，这些channel工作在非阻塞模式下，不会让线程吊死在一个channel上。适合连接特别多，但流量低多场景。</p>
<pre class=" language-mermaid"><code class="language-mermaid">graph TD
subgraph selector 版
thread --> selector
selector --> c1(channel)
selector --> c2(channel)
selector --> c3(channel)
end
</code></pre>
<p>调用selector的select()会阻塞直到channel发生了读写就绪事件，这些事件发生，select方法就会返回这些事件交给thread来处理。</p>
<h2 id="46、Java中常见的集合-5颗星🌟🌟🌟🌟🌟"><a href="#46、Java中常见的集合-5颗星🌟🌟🌟🌟🌟" class="headerlink" title="46、Java中常见的集合(5颗星🌟🌟🌟🌟🌟)"></a>46、Java中常见的集合(5颗星🌟🌟🌟🌟🌟)</h2><p>1、java中集合主要分为两种集合类型:单值集合、key-value键值对这样的类型的集合。</p>
<p>单值集合的父接口:Collection.键值对的父接口为Map。</p>
<p>Collection的类图:</p>
<p><img src="https://img-blog.csdnimg.cn/20200830230517798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTUxOTM4,size_16,color_FFFFFF,t_70#pic_center" alt="集合的结构图"></p>
<p>Collection中比较常见的集合:</p>
<p>Collection上面还有一个父类:iterable 可迭代的</p>
<p>1、list接口：表示有序可重负的集合，常用的实现类:ArrayList、Vector、LinkedList、Vector下面还有一个Stack这个集合。</p>
<ul>
<li>ArrayList的底层的数据结构是基于我们的数组的形式来进行实现的。所以可以根据我们的索引查找对应的下标。</li>
<li>Vector也是数组来进行实现的</li>
<li>LinkedList是基于我们的链表来进行实现的。</li>
<li>Stack是基于我们的栈的数据结构来进行实现的。</li>
</ul>
<p>2、queue接口:表示队列，表示先进先出。常见的Dqueue下面的LinkedList也是一个queue 集合。ArrayDqueue是以我们的数组的形式去实现了我们的队列。</p>
<p>3、set接口:表示无序不可重复。常用的实现类:HashSet、SortedSet下面有一个TreeSet集合。</p>
<ul>
<li>HashSet是基于我们的哈希表的数据结构来进行实现的。但是呢只使用了key部分，value部分没有进行使用。就是存储了一个Object对象。</li>
<li>TreeMap是使用我们的红黑树来进行实现。</li>
</ul>
<p>Map接口比较常见的集合:</p>
<p><img src="https://img-blog.csdnimg.cn/20200830230539537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMTUxOTM4,size_16,color_FFFFFF,t_70#pic_center" alt="map的结构图"></p>
<p>1、Map是以键值对形式进行存储的，key-value形式进行存储的。可以根据我们的key去访问我们的value。</p>
<p>2、所有的Map集合的特点:无序不可重复。</p>
<p>3、map下面比较常用的集合为:HashMap、HashTable、SortedMap下面的TreeMap。</p>
<h2 id="47、遍历Map的集合的方式"><a href="#47、遍历Map的集合的方式" class="headerlink" title="47、遍历Map的集合的方式"></a>47、遍历Map的集合的方式</h2><p>1、第一种使用的keySet拿到所有的key的集合。然后通过我们的迭代器进行遍历。</p>
<p>2、使用的forEach遍历我们的集合。forEach是函数式编程，可以得到我们的key、value键值对。</p>
<p>3、可以使用Values()的方法拿到所有value的集合。</p>
<h2 id="48、线程安全的集合有哪些、有哪些是线程不安全的"><a href="#48、线程安全的集合有哪些、有哪些是线程不安全的" class="headerlink" title="48、线程安全的集合有哪些、有哪些是线程不安全的?"></a>48、线程安全的集合有哪些、有哪些是线程不安全的?</h2><p>线程安全的集合:</p>
<p>1、HashTable：是线程安全的，在一些的重要的方法使用的是synchronized来进行修饰。</p>
<p>2、ConcurrentHashMap:是一种高效但是线程安全的集合。</p>
<p>3、Vector:是线程的安全的，比我们的ArrayList多了个同步化的机制。</p>
<p>4、Stack:栈 ，也是线程安全的。继承于Vector</p>
<p>线程不安全的:</p>
<p>1、HashMap</p>
<p>2、ArrayList</p>
<p>3、LinkedList</p>
<p>4、HashSet</p>
<p>5、TreeSet</p>
<p>6、TreeMap</p>
<h2 id="49、ArrayList和LinkedList的异同点"><a href="#49、ArrayList和LinkedList的异同点" class="headerlink" title="49、ArrayList和LinkedList的异同点:"></a>49、ArrayList和LinkedList的异同点:</h2><p>相同点:</p>
<p>1、ArrayList和LinkedList都是线程不安全的。</p>
<p>不同点:</p>
<p>1、底层的数据结构不同:ArrayList是基于数组的、LinkedList是基于双向链表来进行实现的。</p>
<p>2、插入和删除的不同:ArrayList是基于数组的所以在我们的插入和删除时，需要移动我们的数组中的数据，所以会损失一定的性能。当我们插入的数据比原数组的数据要大时，还需要进行扩容的操作。在创建一个更大的数组，然后将原数组的数据，拷贝到我们的这个数组，然后将需要插入的数据放入即可。</p>
<p>LinkedList是基于我们的双向链表来进行实现的。所以如果扩容的话，只需要通过我们的指针进行遍历，遍历到我们的需要插入的位置即可。然后将我们的链表的后继指针指向插入的数据即可。LinkedList不管的是插入还删除时间复杂度都是o(1).</p>
<p>3、随机存储:因为ArrayList是数组，所以有索引下标可以进行随机访问，而LinkedList不行，必须使用一个辅助指针，遍历这个辅助指针，来找到我对应的结点进行输出。</p>
<p>4、内存占用:链表的结点占用肯定是比数组要大的，因为不仅需要存储我们的元素还要存储前驱指针和后继指针。</p>
<h2 id="50、ArrayList和Vector的区别"><a href="#50、ArrayList和Vector的区别" class="headerlink" title="50、ArrayList和Vector的区别:"></a>50、ArrayList和Vector的区别:</h2><p>1、Vector是线程安全的，ArrayList不是线程安全的。</p>
<p>2、Vector在一些重要的方法加入了synchronized，可以保证我们的线程安全，但是锁的粒度太大的同时也会降低集合的效率。</p>
<p>3、扩容大小不同:ArrayList每次扩容会扩成原来的1.5倍，而Vector是扩容为原来的2倍。</p>
<h2 id="51、说一下ArrayList的扩容的机制"><a href="#51、说一下ArrayList的扩容的机制" class="headerlink" title="51、说一下ArrayList的扩容的机制"></a>51、说一下ArrayList的扩容的机制</h2><p>1、ArrayList扩容的本质就是数组的扩容。数组的扩容就是需要创建一个更大空闲的数组，用于copy一下原数组，让后将数组进行放入。ArrayList的默认情况是1.5倍。</p>
<p>add()方法进行扩容:</p>
<p>判断一下我们集合是否能存储新的元素，如果可以则直接放入即可。若不能，则调用grow()方法进行扩容。然后将元素放入到数组尾即可。grow方法会获取我们的elementData的数组的长度。获取到后，进行一个位运算，进行了一个右移1位，相当于&#x2F;2，加上我们的oldCapacity，相等于扩容为原来的1.5倍。然后去创建数组，调用Arrays.copy的方法将原数组的数据，copy到新的数组中。</p>
<h2 id="52、ArrayList和Array有什么区别-什么时候该用Array而不是ArrayList呢"><a href="#52、ArrayList和Array有什么区别-什么时候该用Array而不是ArrayList呢" class="headerlink" title="52、ArrayList和Array有什么区别?什么时候该用Array而不是ArrayList呢"></a>52、ArrayList和Array有什么区别?什么时候该用Array而不是ArrayList呢</h2><p>1、Array是可以包含我们的基本数据类型、ArrayList不能包含基本数据类型，只能包含引用数据类型。</p>
<p>2、Array的大小是固定的，ArrayList是可以进行自动扩容的。</p>
<p>3、ArrayList提供了更多的方法和特性，比如:add()、remove()方法等。</p>
<h2 id="53、HashMap的底层数据结构是什么？"><a href="#53、HashMap的底层数据结构是什么？" class="headerlink" title="53、HashMap的底层数据结构是什么？"></a>53、HashMap的底层数据结构是什么？</h2><p>不管是jdk1.7还是jdk1.8都是使用Hash 表来进行实现的，只不过具体的实现方式不同。</p>
<p>Jdk1.7采用的数组加链表来进行实现的，JDK1.8是采用数组加上链表加上红黑树来进行实现的。</p>
<p>jdk1.7中，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的。</p>
<p>在jdk1.8中，是有数组+链表+红黑树组成。当链表过长时，为了查询效率，将链表转换成红黑树，因为链表的查询效率时o(n).而我们的红黑树时o(logn).当我们的数组的长度大于等于64的时候，会将链表转换成红黑树。如果有一个要求没有达到，它就不会去转化成红黑树，而是先去数组进行扩容。</p>
<p><img src="https://cdn-a.markji.com/files/63ec50d29689ef18f9325a76_hd.png?e=1681034683550&token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:blF9F3c_k_qGYN4HFnC1M545ymU=" alt="img"></p>
<h2 id="54、解决Hash冲突的办法有哪些？Hash-Map用哪些？"><a href="#54、解决Hash冲突的办法有哪些？Hash-Map用哪些？" class="headerlink" title="54、解决Hash冲突的办法有哪些？Hash Map用哪些？"></a>54、解决Hash冲突的办法有哪些？Hash Map用哪些？</h2><p>解决Hash冲突方法有:开发定址法、再哈希法、链地址法、建立公共溢出区。HashMao中采用的是链地址法。</p>
<p>开放地址法也称为再散列法，基本思想就是，如果p&#x3D;H(key)出现冲突时，则以p为基础，再次hash，p1&#x3D;H(p),如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址p1。因此开放地址法锁需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以只能在删除的结点上做标记，而不能删除节点。</p>
<p>再哈希法，提供多个hash函数，当Rl&#x3D;H1(key1)发生冲突时，在计算R2&#x3D;H2(key1)，直到没有冲突为止。这样做虽然不易产生堆集，但增加了计算的时间。</p>
<p>链地址法(拉链法)，将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的数组中。</p>
<p>建立公共溢出区:将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>
<h2 id="55、Hash默认加载因子是多少-为什么是0-75，不是0-6或者0-8？"><a href="#55、Hash默认加载因子是多少-为什么是0-75，不是0-6或者0-8？" class="headerlink" title="55、Hash默认加载因子是多少?为什么是0.75，不是0.6或者0.8？"></a>55、Hash默认加载因子是多少?为什么是0.75，不是0.6或者0.8？</h2><p>回答这个问题之前,我们先看下HashMap的构造函数:</p>
<p>int threadold;&#x2F;&#x2F;容纳键值对的最大值</p>
<p>final float loadFactorr;&#x2F;&#x2F;负载因子</p>
<p>int modCount;</p>
<p>int size;</p>
<p>Node[] table的初始化长度length(默认值是16)，loadfactor为负载因子默认值是0.75，threadold是Hashmap所能容纳键值对的最大值。threshold&#x3D;length*loadfactor.也就是说数组定义好的长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>默认的loadFactor，是0.75，0.75是对空间和时间效率的一个平衡选择，一般不要修改，除非在时间和空间比较特殊的情况下：</p>
<ul>
<li>如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值。</li>
<li>相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1</li>
</ul>
<h2 id="56、为什么解决hash冲突的时候，不直接用红黑树？而是选择先用链表，在转红黑树？"><a href="#56、为什么解决hash冲突的时候，不直接用红黑树？而是选择先用链表，在转红黑树？" class="headerlink" title="56、为什么解决hash冲突的时候，不直接用红黑树？而是选择先用链表，在转红黑树？"></a>56、为什么解决hash冲突的时候，不直接用红黑树？而是选择先用链表，在转红黑树？</h2><p>因为红黑树要进行左旋、右旋、变色的操作来保证我们的红黑树之间的平衡。而链表不用。当元素小于8个时候，此时做查询操作，链表的查询会好一些。当元素大于8的时候，使用红黑树会好一些。因为红黑树的查询的时间复杂度时O(logn),而链表是o(n)。因为一开始使用红黑树结构，元素太少，而且需要进行一些变色操作等，会浪费性能。</p>
<h2 id="57、HashMap中key等存储索引是怎么计算的？"><a href="#57、HashMap中key等存储索引是怎么计算的？" class="headerlink" title="57、HashMap中key等存储索引是怎么计算的？"></a>57、HashMap中key等存储索引是怎么计算的？</h2><p>首先根据key的值计算出HashCode的值，然后根据HashCode计算出hash值，最后通过我们的hash&amp;(length-1)计算得到存储的位置。</p>
<p>jdk1.7 方法一:先计算hashCode值，然后进行取模操作。</p>
<p>jdk1.8 方法二：也是计算hashCode值，然后采用位运算，高位参与运行。HashCode值无符号右移16位。这样可以仅可能的减少我们的hash冲突。</p>
<h2 id="58、HashMap的put方法流程"><a href="#58、HashMap的put方法流程" class="headerlink" title="58、HashMap的put方法流程?"></a>58、HashMap的put方法流程?</h2><p>以jdk1.8为列:</p>
<p>1、首先根据key的值，计算出hashcode值，通过无符号右移16来确定该元素在数组中的下标。</p>
<p>2、如果数组是空的，则调用resize方法进行初始化，初始化为16</p>
<p>3、如果没有哈希冲突直接放在对应的数组下标里</p>
<p>4、如果冲突了，且key已经存在，通过调用equals来进行比较，如果相等，就覆盖掉value。</p>
<p>5、如果冲突后，发现该结点是红黑树，就将这个结点挂在树上。</p>
<p>6、如果冲突后是链表，判断该链表是否大于8，如果大于8并且数组容量小于64，就对我们的数组进行扩容；</p>
<p>如果链表结点大于8并且数组的容量大于64，则将这个结构转换成红黑树否则，链表插入键值对，若key存在，就覆盖掉value。</p>
<p><img src="https://cdn-a.markji.com/files/63ec5a673e49fef5c8bdbb85_hd.png?e=1681034683550&token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:ZP3AyOy2MEWLf-yISIh6itmHiOs=" alt="img"></p>
<h2 id="59、HashMap扩容方式？"><a href="#59、HashMap扩容方式？" class="headerlink" title="59、HashMap扩容方式？"></a>59、HashMap扩容方式？</h2><p>HashMap在容量超过负载因子所定义的容量之后，就会进行扩容。java里面数组是无法进行扩容的，方法是将HashMap的大小扩容为原来的两倍，并将原来的独享的数据放入到新的数组中。</p>
<p>jdk1.7之后:</p>
<p><img src="https://cdn-a.markji.com/files/63ec5b983e49fef5c8bdcc2c_hd.png?e=1681034683550&token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:UPqsZiuCsPzrjJNU0DGY5QBaxUQ=" alt="img"></p>
<p>JDK1.8:</p>
<p><img src="https://cdn-a.markji.com/files/63ec5bb19689ef18f93346ac_hd.png?e=1681047254339&token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:bEIqORoQgJT3n7SWqNenJlSKAsg=" alt="img"></p>
<p>⚠️注意:在jdk1.7中rehash的时候，旧链表迁移到新链表的时候，采用的头插法。jdk1.8不会倒置，使用尾插法。 所以在jdk1.7中并发下，会造成链表出现死循环。死链的产生.</p>
<h2 id="60、HashMap为什么线程不安全？"><a href="#60、HashMap为什么线程不安全？" class="headerlink" title="60、HashMap为什么线程不安全？"></a>60、HashMap为什么线程不安全？</h2><p>多线程下扩容死循环。jDK1.7中的HashMap使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，jDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</p>
<p>多线程的put可能导致元素的丢失。多线程同时执行put操作，如果计算出来的索引位置是相同的，那会造成前一个key被后一个key覆盖，从而导致元素的丢失。此问题在DK1.7和jDK1.8中都存在。</p>
<p>put和get并发时，可能导致get为null。线程1执行put时，因为元素个数超出thresholdi而导致 rehash，线程2此时执行get，有可能导致这个问题。此问题在DK1。7和jDK1。8中都存在。</p>
<h2 id="61、ConcurrentHashMap的实现原理是什么？"><a href="#61、ConcurrentHashMap的实现原理是什么？" class="headerlink" title="61、ConcurrentHashMap的实现原理是什么？"></a>61、ConcurrentHashMap的实现原理是什么？</h2><p>ConcurrentHashMap在jdk1.7和jdk1.8的实现方式是不同的。</p>
<p>jdk1.7中的ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成，即ConcurrentHashMap把哈希桶切分成小数组(segment),每个数组有n个HashEntry组成。</p>
<p><img src="https://cdn-a.markji.com/files/63ec5eae9689ef18f9336b9c_hd.png?e=1681034683550&token=xX63b9jqTlDOcGmctt5K9254rV0LG8hS9BmDeFBy:7c0B6U86j0S2Zm1pMOncaG_ls64=" alt="img"></p>
<p>首先将数据分为一段一段段存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段数据也能被其他线程访问，能够实现真正的并发访问。</p>
<p>jdk1.8:</p>
<p>在数据结构上，JDK1.8中的ConcurrentHashMap选择了与HashMap相同的数组+链表+红黑树结构；在锁的实现上，抛弃了原有的Segment分段锁，采用了cas+synchronized实现更加低粒度的锁。</p>
<p>将锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点(红黑树的根节点)，就不会影响其他的哈希桶元素的读写，大大提高了并发度。</p>
<p>ConcurrentHashMap的put方法执行逻辑是什么？</p>
<p>先来看jdk1.7</p>
<p>首先，会尝试获取锁，如果获取失败，利用自旋获取锁，如果自旋重试的次数超过64次，则改为阻塞获取锁。</p>
<p>获取锁后:</p>
<p>1、将当前Segment中table通过key的hashCode定位到我们的HashEntry。</p>
<p>2、遍历该HashEntry，如果不为空则判断传入的key和当前遍历的key是否相等，相等则覆盖旧的value。</p>
<p>3、不为空则需要新建一个HashEntry并加入到Segment中，同时会先判断是否需要进行扩容操作。</p>
<p>4、释放Segment锁。</p>
<p>jdk1.8步骤:</p>
<p>1、根据key计算出hash值。</p>
<p>2、判断是否需要进行初始化。</p>
<p>3、定位到node结点，拿到首结点f，判断首结点f：</p>
<ul>
<li>如果为null，则通过cas到方式尝试添加。</li>
<li>如果为f.hash&#x3D;moved&#x3D;-1,说明其他线程在扩容，参与一起扩容。</li>
<li>如果都满足，synchronized锁住f节点，判断是链表还是红黑树，遍历插入。</li>
</ul>
<p>4、当在链表长度到达8的时候，数据扩容或者将链表转化成红黑树。</p>
<h2 id="62、ConcurrentHashMap的不支持key或者value为null的原因？"><a href="#62、ConcurrentHashMap的不支持key或者value为null的原因？" class="headerlink" title="62、ConcurrentHashMap的不支持key或者value为null的原因？"></a>62、ConcurrentHashMap的不支持key或者value为null的原因？</h2><p>我们先来说value为什么不能为null，因为ConcurrentHashMap时用于多线程的，如果map.get(key)得到了null，无法判断，是映射的value是null，还是没有找到对应的key而为null，这就有了二义性。</p>
<h2 id="63、ConcurrentHashMap迭代器是强一致性还是弱一致性？"><a href="#63、ConcurrentHashMap迭代器是强一致性还是弱一致性？" class="headerlink" title="63、ConcurrentHashMap迭代器是强一致性还是弱一致性？"></a>63、ConcurrentHashMap迭代器是强一致性还是弱一致性？</h2><p>与HashMap迭代器是强一致性不同，ConcurrentHashMap迭代器是弱一致性。</p>
<p>ConcurrentHashMap的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元 素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</p>
<h2 id="64、JDk1-7与jdk1-8中ConcurrentHashMap的区别"><a href="#64、JDk1-7与jdk1-8中ConcurrentHashMap的区别" class="headerlink" title="64、JDk1.7与jdk1.8中ConcurrentHashMap的区别?"></a>64、JDk1.7与jdk1.8中ConcurrentHashMap的区别?</h2><p>数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。 </p>
<p>保证线程安全机制：JDK1。7采用Segment的分段锁机制实现线程安全，其中segment？继承自ReentrantLock。JDKI。8采用CAS+Synchronized保证线程安全。</p>
<p>锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁 (Node)</p>
<p>链表转化为红黑树：定位结点的hash算法简化会带来弊端，Hash冲突加剧，因此在链表节点数量大于8 时，会将链表转化为红黑树进行存储。</p>
<p>查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p>
<h2 id="65、多线程安全的操作map还有其他方法吗"><a href="#65、多线程安全的操作map还有其他方法吗" class="headerlink" title="65、多线程安全的操作map还有其他方法吗?"></a>65、多线程安全的操作map还有其他方法吗?</h2><p>1、还可以使用collections.synchronziedMap方法。</p>
<p>2、加上synchronized同步锁。</p>
<p>3、使用ConcurrentHashMap</p>
<h2 id="66、HashSet和HashMap的区别"><a href="#66、HashSet和HashMap的区别" class="headerlink" title="66、HashSet和HashMap的区别:"></a>66、HashSet和HashMap的区别:</h2><p>1、HashSet实现了set接口，Hash Map实现的是map接口</p>
<p>2、HashMap存储键值对，HashSet只能存储值</p>
<p>3、HashSet的底层就是使用的HashMap的key部分，value保存了一个虚值。</p>
<p>4、HashSet的使用add方法添加数据,HashMap使用put来添加数据</p>
<h2 id="67、Collection框架中实现比较怎么做？"><a href="#67、Collection框架中实现比较怎么做？" class="headerlink" title="67、Collection框架中实现比较怎么做？"></a>67、Collection框架中实现比较怎么做？</h2><p>1、去让我们的实体类实现Comparable接口，并实现compareTo(T t)方法，称为内部比较器，如果CompareTo方法返回的是一个正数表示从小到大的排序。升序排序的。如果是一个负数，就是降序排序的。如果是0表示等于。</p>
<h2 id="68、Iterator和Listerator有什么区别？"><a href="#68、Iterator和Listerator有什么区别？" class="headerlink" title="68、Iterator和Listerator有什么区别？"></a>68、Iterator和Listerator有什么区别？</h2><p>遍历。使用Iterator，可以遍历所有集合，如Map，List，Set；但只能在向前方向上遍历集合中的元素。</p>
<p>使用Listlterator，只能遍历List实现的对象，但可以向前和向后遍历集合中的元素。</p>
<p>添加元素。Iterator无法向集合中添加元素；而，Listlteror可以向集合添加元素。</p>
<p>修改元素。Iterator无法修改集合中的元素而，Listlterator可以使用set0修改集合中的元素。</p>
<p>索引。Iteratori无法获取集合中元素的索引；而，使用Listlterator，可以获取集合中元素的索引。</p>
<h2 id="69、讲一讲快速失败-fail-fast-和安全失败-fail-safe"><a href="#69、讲一讲快速失败-fail-fast-和安全失败-fail-safe" class="headerlink" title="69、讲一讲快速失败(fail-fast)和安全失败(fail-safe)"></a>69、讲一讲快速失败(fail-fast)和安全失败(fail-safe)</h2><p>快速失败（fail-fast）</p>
<p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改)，则会抛出ConcurrentModification Exception。</p>
<p>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个nodCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext(0&#x2F;next)遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值， 是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>注意：这里异常的抛出条件是检测到modCount！&#x3D;expectedmodCount这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p>
<p>场景: java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改,比如HashMap、ArrayList这些集合类。</p>
<p>安全失败(fail-fast):</p>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p>
<p>场景:java.util.concurrent包下的容器都是安全失败,可以在多线程下并发使用,并发修改，比如:ConcurrentHashMap</p>
<h2 id="70、在并发环境下使用什么list啊？"><a href="#70、在并发环境下使用什么list啊？" class="headerlink" title="70、在并发环境下使用什么list啊？"></a>70、在并发环境下使用什么list啊？</h2><p>1、最简单的方法就是直接使用Vector</p>
<p>2、使用collections.synchronziedList修饰这个list，将这个list保证成线程安全的。</p>
<p>3、使用我们的写时赋值技术，也就是CopyOnWriteArrayList</p>
<p>底层实现的写入时copy的思想，增删改操作会将底层数据拷贝一份，更改操作在新数组上执行，这时不影响其他线程的并发读，读写分离。</p>
<p>适合读多写少的场景</p>
<p>get弱一致性问题:</p>
<p>不如说我的集合中有1，2，3三个元素,这时线程1去读取元素，线程二去remove掉一个元素，拷贝出一个一摸一样的数组，然后去这个数组中去将1清除掉，这时赋值回去的时候，线程1还可以去原来的数组中去获取元素1。这就是CopyOnWirte的弱一致性。</p>
<h1 id="线程篇"><a href="#线程篇" class="headerlink" title="线程篇"></a>线程篇</h1><h2 id="1、创建线程的几种方式"><a href="#1、创建线程的几种方式" class="headerlink" title="1、创建线程的几种方式"></a>1、创建线程的几种方式</h2><ul>
<li>继承Thread，重写run方法</li>
<li>实现Runnalbe，实现run方法</li>
<li>实现Callable接口，实现call方法。</li>
<li>使用线程池创建线程。</li>
</ul>
<p>区别:</p>
<p>1、第一个方式因为是使用继承，所以不能在继承其他的类</p>
<p>2、第二种方式,就是因为使用实现，所以还是可以继续实现其他的接口，并且还可以继承其他的类，所以第二种的扩展性比较好</p>
<p>3、实现Callble的接口，call方法允许存在的泛型的，所以可以规范我们的传输数据。call方法可以存在的返回值。但是需要使用Future进行接收。call方法可以抛出异常的。</p>
<h2 id="2、线程池的创建"><a href="#2、线程池的创建" class="headerlink" title="2、线程池的创建"></a>2、线程池的创建</h2><p>1、可以使用Executors工具类创建线程.</p>
<p>Executors几种创建线程的方式:</p>
<p>1、newFixedThreadPool 固定线程数,核心线程和最大线程数一样的</p>
<p>2、newSingleThreadExecutor 一池一线程</p>
<p>3、newCachedThreadPool() 核心线程是0，最大线程数是Integer.MAX_VALUE</p>
<p>4、newScheduledThreadPool()：定时任务的线程池</p>
<p>2、使用ThreadPoolExecutor去创建我们的线程池。</p>
<p>自己去创建我们的线程池的七大参数:</p>
<p>1、corePoolSize:线程池的核心线程数</p>
<p>2、maxNumPoolSize:线程池的最大线程数</p>
<p>3、keepAliveTime:线程的存活时间</p>
<p>4、Unit：时间单元</p>
<p>5、ThreadFactory：线程的工厂，用于创建线程。</p>
<p>6、BlockingQueue:线程的阻塞队列。</p>
<p>7、Rejected：线程池的拒接策略。</p>
<h2 id="3、线程池的执行流程"><a href="#3、线程池的执行流程" class="headerlink" title="3、线程池的执行流程:"></a>3、线程池的执行流程:</h2><p>当我们的任务来了之后,线程池会去判断我们线程池中的线程是否小于corePoolSize，如果小于则直接创建线程执行任务,如果大于，就把当前线程放入到阻塞队列中。<br>当我们的阻塞队列中的任务，满了以后，会去判断我们当前线程池中的线程是否小于maxNumPoolSize的值，如果小于则去创建多余的线程去执行任务。如果当我们创建的线程数大于等于maxNumPoolSize了，那么我们就要启动拒接策略。去进行拒接。当我们的任务执行完之后，会去判断当前线程池中的线程是否大于corePoolSize，如果大于的话，会去等待这些线程的空闲时间大于或等于keepAliveTime，就会将这些多余的线程进行回收。</p>
<h2 id="4、线程池中有哪些拒接策略"><a href="#4、线程池中有哪些拒接策略" class="headerlink" title="4、线程池中有哪些拒接策略:"></a>4、线程池中有哪些拒接策略:</h2><p>1、AbortPolicy(阿婆特跑了c)(默认):直接抛出异常</p>
<p>2、CallerRunsPolicy:调用者运行的一种调节机制，该策略不会抛弃任务，也不会抛出异常，而是将这些任务退回到调用者，从而降低新任务的流量。</p>
<p>3、DiscardOldestPolicy:抛弃队列中等候最久的任务，然后把当前任务加入到队列中,尝试再次提交当前任务。</p>
<p>4、DiscardPolicy:该策略默默地丢弃无法处理的任务，不予任何处理也不抛异常。如果允许任务的丢失，这是最好的一种策略。</p>
<h2 id="5、进程与线程之间的区别"><a href="#5、进程与线程之间的区别" class="headerlink" title="5、进程与线程之间的区别:"></a>5、进程与线程之间的区别:</h2><p>1、进程:当我们启动一个程序，将我们程序的代码从磁盘中加载内存中，这就相当于开启了一个进程。例如说:启动了qq.exe,相当于开启了一个qq进程。我们进程是系统进行资源分配的最小单元。</p>
<p>2、线程:线程java允许过程中最小的调度单元。一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给cpu执行。</p>
<p>3、进程包含线程，也就是线程是进程的子集。</p>
<p>4、线程通信相对简单，因为它们共享进程内的内容。</p>
<p>5、线程的上下文切换比进程更加的轻量。</p>
<p>ps -ef ｜ grep 查询具体的进程。</p>
<p>kill -9 杀死我们的某个进程。</p>
<h2 id="6、Thread中常用的方法"><a href="#6、Thread中常用的方法" class="headerlink" title="6、Thread中常用的方法:"></a>6、Thread中常用的方法:</h2><p>1、start() 启动线程</p>
<p>2、run()方法,线程启动时会调用这个方法。</p>
<p>3、join 等待线程运行结束</p>
<p>4、getName 获取线程名称</p>
<p>5、getPriority（）获取线程优先级</p>
<p>6、getState 获取线程的状态</p>
<p>7、isInterrupted() 打断线程</p>
<p>8、isAlive 线程是否存活</p>
<p>9、currentThread() 获取当前正在执行的线程</p>
<h2 id="7、为什么要使用多线程呢？"><a href="#7、为什么要使用多线程呢？" class="headerlink" title="7、为什么要使用多线程呢？"></a>7、为什么要使用多线程呢？</h2><p>从计算机底层来说：线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核CPU时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</p>
<p>从当代互联网发展趋势来说：现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p>
<p>根本的原因就是单线程不够用吗。</p>
<h2 id="8、线程的状态切换"><a href="#8、线程的状态切换" class="headerlink" title="8、线程的状态切换:"></a>8、线程的状态切换:</h2><p>1、从系统层面来看的:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220113213622272.png" alt="image-20220113213622272"></p>
<p>1、初始状态:创建线程，还没有于我们的操作系统进行关联。</p>
<p>2、可运行状态:指该线程已经被创建，可以由cpu进行调度执行。</p>
<p>3、运行状态:指获取到了cpu的时间片。当时间片用完，会从运行状态转化成可运行状态，会进行现场上下文之间的切换。</p>
<p>4、阻塞状态:表示调用阻塞式的IO可能会导致线程的阻塞，比如调用了传统的IO比如FileOutputStream等。</p>
<p>5、终止状态:表示线程已经执行完毕，生命周期已经结束,不会再转换为其他状态</p>
<h2 id="9、start方法和run方法的区别"><a href="#9、start方法和run方法的区别" class="headerlink" title="9、start方法和run方法的区别:"></a>9、start方法和run方法的区别:</h2><p>start()方法是开启线程一个线程，其实底层调用的是一个使用native修饰的start0()方法来开启线程.线程启动之后，会去调用run方法。如果只是调用run()方法，就相当于只是去执行了run方法，没有去启动线程</p>
<h2 id="10、sleep和yield的区别"><a href="#10、sleep和yield的区别" class="headerlink" title="10、sleep和yield的区别:"></a>10、sleep和yield的区别:</h2><p>1、调用sleep会让当前线程从Running进入到Time waiting状态(阻塞)</p>
<p>2、其他线程可以使用interruptor来进行打断正在随眠的线程，这时sleep方法会抛InterruptorException</p>
<p>3、睡眠结束后的线程未必会立刻得到执行</p>
<p>4、yield会当当前线程从Running状态变为Runnable的就绪状态,然后去调度执行其他线程</p>
<p>5、具体实现依赖于操作系统的任务调度</p>
<blockquote>
<p> 线程的优先级:</p>
<p>1、线程优先级会提示调度器优先去调度该线程，但它仅仅是一个提示，调度器可以忽略它<br>2、如果cpu比较忙，那么优先级高的线程会获得更多的时间片，但cpu闲时,优先级几乎没作用。<br>使用setPriority</p>
</blockquote>
<h2 id="11、java层面的线程状态"><a href="#11、java层面的线程状态" class="headerlink" title="11、java层面的线程状态"></a>11、java层面的线程状态</h2><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220113215646043.png" alt="image-20220113215646043"></p>
<p>1、new状态:表示当前new Thread(),但是还没有调用start()方法。</p>
<p>2、runable:指当前线程调用start()方法，去抢夺cpu的时间片</p>
<p>3、waiting:等待</p>
<p>4、blocked:阻塞</p>
<p>5、time_waiting：等待时间</p>
<p>6、终止:程序执行完毕</p>
<p>之间的转换:</p>
<p>1、new—&gt;runnable 就是调用了start()方法就会从我们的new状态变为runnable</p>
<p>2、runnable–&gt;wait：就是当我们多个线程去抢夺synchronized的对象锁的时候，调用了Object.wait方法会让当前线程变为wait状态。</p>
<p>调用obj.notify()、notifyAll()、interrupt()时，就会去竞争锁成功,t线程从waiting—-&gt;runnable</p>
<p>竞争锁失败,t线程从waiting—-》blocked</p>
<p>调用LockSupport.park()方法会让当前线程从runnable–&gt;waiting</p>
<p>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</p>
<p>RUNNABLE –&gt; TIMED_WAITING:</p>
<p>1、调用的join()设置了时间<br>2、调用了sleep方法会让当前线程变为time_waiting<br>3、调用Locksupprot方法的park方法。<br>4、就是去抢夺对象锁的时候，调用了wait方法，并设置了等待时间。</p>
<p>runnable–&gt;blcoked<br>1、抢夺对象锁失败，就会进如到entryList中进行阻塞。</p>
<p>runnable–&gt;终止状态:程序执行完毕</p>
<h2 id="12、什么是临界区"><a href="#12、什么是临界区" class="headerlink" title="12、什么是临界区:"></a>12、什么是临界区:</h2><p>指一个程序运行多个线程本身是没有问题。</p>
<p>问题出在多个线程访问共享资源。<br>    1、多个线程共享资源其实没有问题。<br>    2、在多个线程对共享资源读写时发生指令交错，就会出现问题。</p>
<p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区。</p>
<p>竟态条件:</p>
<p> 多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之发生了竟太条件。</p>
<p>如何解决临界区问题:</p>
<p>1、阻塞式的解决方案;synchronized、lock</p>
<p>2、非阻塞式的解决方案:原子变量</p>
<p>解决方案：synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p>
<h2 id="13、互斥和同步的区别"><a href="#13、互斥和同步的区别" class="headerlink" title="13、互斥和同步的区别:"></a>13、互斥和同步的区别:</h2><p>互斥是防止临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</p>
<p>同步是由于线程执行的先后、顺序不同、需要一个线程等待其他线程运行到某个点</p>
<h2 id="14、synchronized"><a href="#14、synchronized" class="headerlink" title="14、synchronized"></a>14、synchronized</h2><p>java中的关键字,使用对象锁的方式来解决临界区问题。是一个可重入锁，是一个重量级锁。</p>
<p>可以修饰代码块、可以修饰静态方法、实例方法。</p>
<p>修饰静态方法，相当于锁当前的class，如果是修饰实例方法，相当于锁当前的对象。</p>
<p>理解:</p>
<p>当多个线程区执行到synchronized的时候，就会去抢夺对象锁，获取到对象锁后，就会执行任务，这时其他线程也想执行，发现对象锁已被获取，那么它就只能阻塞住，等别人去释放锁。有可能当前线程还没执行完的时候，cpu时间片用完了，被剔除了房间，但是当前房间依旧是上锁的，其他线程进不去，只能当前线程进去，继续执行，执行完毕之后，会去唤醒所有的阻塞线程去抢夺对象锁。</p>
<h2 id="15、变量的线程安全分析"><a href="#15、变量的线程安全分析" class="headerlink" title="15、变量的线程安全分析:"></a>15、变量的线程安全分析:</h2><p>1、成员变量和静态变量是否线程安全:</p>
<ul>
<li>如果它们没有共享，则线程安全。<ul>
<li>如果它们共享了，根据它们的状态能否能够改变，分为两种情况:<ul>
<li>如果只有读操作，则是线程安全</li>
<li>如果有写的操作,则这段代码是临界区，需要考虑线程安全。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>2、局部变量是否线程安全</p>
<ul>
<li>局部变量是线程安全，因为每个线程都有属于自己的栈帧。</li>
<li>但局部变量引用的对象则未必:<ul>
<li>如果该对象没有逃离方法的作用域，它是线程安全。</li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全。</li>
</ul>
</li>
</ul>
<h2 id="16、常见的线程安全的类"><a href="#16、常见的线程安全的类" class="headerlink" title="16、常见的线程安全的类"></a>16、常见的线程安全的类</h2><ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>Hashtable</li>
<li>juc包下的类</li>
</ul>
<p>这里说它们是线程安全的指,多个线程调用它们同一个实例的某个方法时，是线程安全的。它们的每个方法是原子的。<br>但注意它们多个方法的组合不是原子的。</p>
<p>一个对象是否是线程安全，取决于它是否被多个线程访问。</p>
<h2 id="17、synchronized的底层实现"><a href="#17、synchronized的底层实现" class="headerlink" title="17、synchronized的底层实现"></a>17、synchronized的底层实现</h2><p>java对象头:</p>
<p>普通对象分为:mark word、klass word</p>
<p>klass word里面存放的是对象类型。</p>
<p>其中的mark word对象头中存储了一个biased_lock的表示位:</p>
<pre class=" language-java"><code class="language-java"><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span>
<span class="token operator">|</span> Mark <span class="token function">Word</span> <span class="token punctuation">(</span><span class="token number">64</span> bits<span class="token punctuation">)</span> <span class="token operator">|</span> State <span class="token operator">|</span>
<span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span>
<span class="token operator">|</span> unused<span class="token operator">:</span><span class="token number">25</span> <span class="token operator">|</span> hashcode<span class="token operator">:</span><span class="token number">31</span> <span class="token operator">|</span> unused<span class="token operator">:</span><span class="token number">1</span> <span class="token operator">|</span> age<span class="token operator">:</span><span class="token number">4</span> <span class="token operator">|</span> biased_lock<span class="token operator">:</span><span class="token number">0</span> <span class="token operator">|</span> <span class="token number">01</span> <span class="token operator">|</span> Normal <span class="token operator">|</span>
<span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span>
<span class="token operator">|</span> thread<span class="token operator">:</span><span class="token number">54</span> <span class="token operator">|</span> epoch<span class="token operator">:</span><span class="token number">2</span> <span class="token operator">|</span> unused<span class="token operator">:</span><span class="token number">1</span> <span class="token operator">|</span> age<span class="token operator">:</span><span class="token number">4</span> <span class="token operator">|</span> biased_lock<span class="token operator">:</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">01</span> <span class="token operator">|</span> Biased <span class="token operator">|</span>
<span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span>
<span class="token operator">|</span> ptr_to_lock_record<span class="token operator">:</span><span class="token number">62</span> <span class="token operator">|</span> <span class="token number">00</span> <span class="token operator">|</span> Lightweight Locked <span class="token operator">|</span>
<span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span>
<span class="token operator">|</span> ptr_to_heavyweight_monitor<span class="token operator">:</span><span class="token number">62</span> <span class="token operator">|</span> <span class="token number">10</span> <span class="token operator">|</span> Heavyweight Locked <span class="token operator">|</span>
<span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span>
<span class="token operator">|</span> <span class="token operator">|</span> <span class="token number">11</span> <span class="token operator">|</span> Marked <span class="token keyword">for</span> GC <span class="token operator">|</span>
<span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">|</span>
</code></pre>
<p>hasCode、对象年龄等。<br>如果是0表示是偏向锁<br>如果是01:表示正常状态、并没有枷锁。如果00表示轻量级锁。10表示重量级锁。</p>
<p>每一个java对象都关联一个Minitor对象,如果使用synchronized给对象上锁之后，该对象头的Mark word中就被设置指向Minitor对象的指针。<br>Monitor结构如下:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220115221331431.png"></p>
<p>1、刚开始Minitor中Owner为null</p>
<p>2、当Thread-2执行了synchronized(obj)就会将Minitor的所有者Owner置为Thread-2,Minitor只能有一个</p>
<p>3、当Thread-2上锁的过程中，如果Thread-3、Thread-4、Thread-5也来执行synchronized(obj)，就会进入EntryList Blocked</p>
<p>4、当我们的Thread-2执行完同步代码块的内容，然后去唤醒EntryList中等待的线程来竞争锁，竞争是非公平的。</p>
<p>5、但我们在对象锁中调用wait方法，就会去释放锁，让后去到wating中进行等待notify到释放。</p>
<h2 id="18、synchronzied的优化"><a href="#18、synchronzied的优化" class="headerlink" title="18、synchronzied的优化"></a>18、synchronzied的优化</h2><p>从jdk1.6开始引入了synchronized的优化策略，锁升级的策略,也就是不是一开始就使用重量级锁,而是从偏向锁、轻量级锁、重量级锁这一过程。</p>
<p><font color="red">偏向锁的过程:</font></p>
<p>轻量级锁在没有竞争时，每次重入仍然需要执行CAS操场。所以在java6中引入了偏向锁，来做进一步的优化:只有第一次使用CAS将线程ID设置到对象Mark Word头，之后发现这个线程id是自己的就表示没有竞争，不用重新CAS。然后只要不发生竞争，这个对象就归当前线程所有。设置失败，表示存在竞争，进入到锁升级到状态中。</p>
<p>偏向状态:</p>
<p>java的头格式:</p>
<p>如果开启了偏向锁,那么对象创建后，markword值为0x05即最后3位为101，这时它的thread、epoch、age都为0</p>
<p>偏向锁默认是延迟的。如果没有开启偏向锁，那么对象创建后，markword值为后三位为001.</p>
<p>轻量级锁失效:</p>
<p>1、调用了hashCode以后，偏向锁会自动关闭，因为底层一旦hash码产生，他就没有办法去存储线程的锁记录了。</p>
<p>2、多个线程的同时调用，会导致竞争，会进入到锁升级状态<br>3、调用wait和notify的，因为是重量级锁，调用该方法偏向锁失效，进入到锁膨胀成为重量级锁。</p>
<p>批量重偏向:撤销偏向阈值超过20次后，jvm会进行重新偏向。</p>
<p>批量撤销:当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的.</p>
<p>锁消除:jvm底层有个jit编辑器,会自动优化你的代码，比如一个局部对象,使用synchronized的加锁,jit编辑器会认为你的加锁方式是无意义的,会在底层自动撤销掉这个锁.</p>
<p><font color="orange">轻量级锁:</font></p>
<p>使用场景:如果一个对象虽然有多线程要加锁，但加锁时间是错开，也就是没有竞争，那么可以使用轻量级锁来优化。</p>
<p>轻量级锁对使用者是透明的即语法仍然是synchronized。</p>
<p>假设有两个方法同步块，利用同一个对象加锁</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment" spellcheck="true">// 同步块 A</span>
        <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">synchronized</span><span class="token punctuation">(</span> obj <span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment" spellcheck="true">// 同步块 B</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>轻量级锁的流程:</p>
<p>1、创建一个锁记录(lock record)对象，</p>
<ul>
<li>每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word:</li>
</ul>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220115235021028.png" alt="image-20220115235021028"></p>
<p>2、让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录 </p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220115235544339.png" alt="image-20220115235544339"></p>
<p>3、如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220116000314509.png" alt="image-20220116000314509"></p>
<p>4、如果 cas 失败，有两种情况</p>
<ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li>
</ul>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220116000408974.png" alt="image-20220116000408974"></p>
<p>5、当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220116000508711.png" alt="image-20220116000508711"></p>
<p>6、当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</p>
<ul>
<li><p>成功，则解锁成功</p>
</li>
<li><p>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>
</li>
</ul>
<p><font color="red"><strong>总结:当我们的线程去获取对象锁时，jvm会创建一个锁记录,用于指向当前对象头，然后会去尝试去用锁记录去替换对象头中的markword，替换成功表示加锁成功。替换失败分为两种情况,一种是存在多个线程竞争，会进入锁膨胀阶段变为重量级锁。另一种，自己又去获取对象锁，这是进入到锁重入阶段，会再次创建一个锁记录，count+1。当我们去解锁的时候，会先去查看是否存在一个取值为null的锁记录，如果有表示该锁需要去重置锁记录，让锁记录-1，减到为0的时候，表示没有锁重入，这是就会去使用cas将MarkWord的值还给对象头，交换成功，表示解锁成功，归还失败，表示进入到重量级锁的解锁过程。</strong></font></p>
<blockquote>
<p>锁膨胀</p>
<p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<p>1、当我们的Thread-1进行轻量级加锁时，发现thread-0已经对该对象加了轻量级锁。</p>
<p>2、这时Thread-1加轻量级锁失败，进入锁膨胀流程</p>
<ul>
<li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址</li>
<li>然后自己进入 Monitor 的 EntryList BLOCKED</li>
</ul>
<p>3、当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</p>
</blockquote>
<blockquote>
<p>自旋优化</p>
<p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
</blockquote>
<h2 id="19、原理-wait和notify"><a href="#19、原理-wait和notify" class="headerlink" title="19、原理 wait和notify"></a>19、原理 wait和notify</h2><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220121231347259.png" alt="image-20220121231347259"></p>
<ul>
<li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li>
<li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li>
<li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li>
<li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li>
</ul>
<p> wait和notify使用</p>
<ul>
<li><p>obj.wait() 让进入 object 监视器的线程到 waitSet 等待</p>
</li>
<li><p>obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒</p>
</li>
<li><p>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒</p>
</li>
</ul>
<p>sleep和wait的区别:</p>
<p>  1、sleep是Thread的静态方法，而wait是Object中方法。<br>  2、sleep不需要强制和synchronized一起联合使用，wait需要和synchronized联合使用。<br>  3、sleep表示睡眠当前时间，但是它是不会释放锁，当wait也是让当前线程去waitSet中进行等待，但是会释放锁。<br>  4、它们的状态的Time_waiting状态</p>
<p>使用wait和notify的模版代码:使用while避免虚假唤醒。</p>
<p>使用场景:保护性暂停<br>在一个线程等待另一个线程的执行结果<br><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220124220039050.png" alt="image-20220124220039050"></p>
<p>代码实现:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>serookie<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * @author kevintam
 * @version 1.0
 * @title
 * @description
 * @createDate 2022/1/25
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GuardedDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        GuardedObject guarded <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GuardedObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"等待结果"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Object resp <span class="token operator">=</span> guarded<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"    "</span><span class="token operator">+</span>resp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"执行下载...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//模拟下载资源</span>
                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            guarded<span class="token punctuation">.</span><span class="token function">complete</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">GuardedObject</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> Object response<span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">//获取结果</span>
    <span class="token keyword">public</span> Object <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">while</span><span class="token punctuation">(</span>response<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> response<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">complete</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token operator">=</span>obj<span class="token punctuation">;</span>
           <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>join的底层的原理的就是使用wait和notifyAll</p>
<p>future的底层实现原理都是使用wait和notifyAll来进行实现的。</p>
<h2 id="20、Java的内存模型"><a href="#20、Java的内存模型" class="headerlink" title="20、Java的内存模型"></a>20、Java的内存模型</h2><p>JMM即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着cpu寄存器、缓存、硬件内存、cpu指令优化等。</p>
<p>JMM体现在以下几个方面:</p>
<ul>
<li>原子性:保证指令不会收到线程上下文切换的影响。</li>
<li>可见性:保证指令不会受到cpu等缓存的影响。</li>
<li>有序性:保证指令不会受到cpu指令并行优化的影响。</li>
</ul>
<p>原子性：表示一个指令操作不能被线程上下文之间的切换进行打断。即表示一个指令操作的必须是原子性的要么执行完，要么不执行。</p>
<p>可见性:</p>
<p>受到cpu缓存的影响，cpu缓存分为多级缓存，主内存和工作内存，当我们的线程频繁去访问我们的主内存中数据的时候，jit会进行优化，将我们的主内存中数据放到我们的工作内存中，让我们的当前线程一直操作工作内存的数据。这样就会导致一个问题就是，当前数据就只能被当前线程可见，对其他线程是不可见的。</p>
<p>解决的方式就是通过我们的<font color="red">volatile关键字</font>来进行解决。</p>
<p>volatile可以用于修饰的成员变量和静态的成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须强制到我们的主存中获取它的值，线程操作volatile变量都是直接操作主存。</p>
<p>volatile可以保证在多个线程之间，一个线程对变量的修改对另一个线程是可见的，不能保证原子性，仅用在一个写线程，多个读线程的情况。</p>
<p>有序性:</p>
<p>jvm在不影响结果正确性的情况下，它会优化我们的代码的执行顺序。这种特性称之为指令重排，多线程下指令重排会影响正确性。</p>
<p>volatile底层实现的是基于内存屏障，Memory Barrier</p>
<ul>
<li>对volatile变量的写指令后加入写屏障。</li>
<li>对volatile变量的读指令前会加入读屏障。</li>
</ul>
<p>如何保证可见性:</p>
<p>写屏障保证在该屏障之前，对共享变量的改动，都同步到我们的主存中。</p>
<p>读屏障保证在屏障之后，对共享变量的读，都是从我们的主存中进行读取。读到都是最新的数据。</p>
<p>如何解决有序性:</p>
<p>写屏障保证在指令重排序时，不会将写屏障之前的数据放到我们的屏障之后。</p>
<p>读屏障保证在指令重排序时，不会讲读屏障之后的数据放到我们的屏障之前。</p>
<p><font color="orange"><strong>volatile不能解决原子性。</strong></font></p>
<h2 id="21、happends-before原则-lt-重要🌟🌟🌟-gt"><a href="#21、happends-before原则-lt-重要🌟🌟🌟-gt" class="headerlink" title="21、happends-before原则:&lt;重要🌟🌟🌟&gt;"></a>21、happends-before原则:&lt;重要🌟🌟🌟&gt;</h2><p>规定了对共享变量的写操作对其他线程的读操作可见，它是可见性与有序性的一套规则总结。抛出以下happends-before原则，JMM并不能保证一个线程对共享变量的写，对于其他线程对该共享变量的读可见。</p>
<p>1、线程解锁之前对变量的写，对于接下来对加锁的其他线程的读可见。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JMM</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> Object obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//1、线程解锁之前对我们的线程写操作，对于接下来对加锁的其他线程的读可见。</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>2、线程对volatile变量的写，对该线程变量的读是可见的。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> day2<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * @author kevintam
 * @version 1.0
 * @title
 * @description
 * @createDate 2023/4/10
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JMM2</span> <span class="token punctuation">{</span>
    <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
            i<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>3、线程start前对变量的写，对该线程开始后对该变量的读可见的。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JMM3</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        i<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>4、线程结束前对变量的写，对其他线程得知它结束后对读可见。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JMM4</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>
        Thread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>
            i <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>5、线程t1打断t2前对变量的写，对于其他线程得知t2被打断后对变量的读可见。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">if</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
   <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
      t2<span class="token punctuation">.</span><span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"t1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>t2<span class="token punctuation">.</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>6、对变量默认值(0,false,null)的写，对其他线程对该变量的读可见。</p>
<p>7、具有传递性，如果x-hp-y  y-hp-z 那么我们的x-hp-z。</p>
<h2 id="22、无锁的实现"><a href="#22、无锁的实现" class="headerlink" title="22、无锁的实现:"></a>22、无锁的实现:</h2><p>volatile加cas来实现无锁并发。或者直接使用Atomic类。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true">//获取到最新的值</span>
   <span class="token keyword">int</span> prev<span class="token operator">=</span>money<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">//修改后的余额</span>
   <span class="token keyword">int</span> next<span class="token operator">=</span>prev<span class="token operator">-</span>num<span class="token punctuation">;</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>money<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">break</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>compareAndSet：在set前，先去获取最新的值与当前值做比较，如果不一致，next作废，返回false失败，如果是一致，以next设置新值，返回true成功。</p>
<p>其中的关键是compareAndSet，它的简称就是CAS，它必须是原子操作。</p>
<p>注意:CAS的底层使用lock cmpxchg指令，在单核cpu和多核cpu下都能保证cas的原子性。在多核的状态下，某个指令执行到带lock的指令时，cpu会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性,是原子的。</p>
<p>CAS必须借助volatile才能读取到共享变量的最新值来实现[比较并交换]的效果。</p>
<p>CAS必须搭配volatile一起使用。</p>
<p>无锁并发适合线程数少、多核cpu的场景下。</p>
<h2 id="23、为什么无锁的效率高"><a href="#23、为什么无锁的效率高" class="headerlink" title="23、为什么无锁的效率高"></a>23、为什么无锁的效率高</h2><p>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，<br>等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p>
<h2 id="24、CAS的特点"><a href="#24、CAS的特点" class="headerlink" title="24、CAS的特点:"></a>24、CAS的特点:</h2><p>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。<br>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</p>
<p>CAS 体现的是无锁并发、无阻塞并发。</p>
<p>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一，但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</p>
<h2 id="25、ABA问题"><a href="#25、ABA问题" class="headerlink" title="25、ABA问题"></a>25、ABA问题</h2><p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：</p>
<p>只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号</p>
<p>使用这个类就可以解决AtomicStampedReference里面有一个版本号需要更新</p>
<p>原子累加器</p>
<p>LongAdder:性能提升的原因很简单，就是在有竞争时,设置多个累加单元,Thread-0累加共享变量1,而Thread-1累加共享变量2…最后将结果汇总。这样它们在累加时操作的不同的共享变量，因此减少了cas重试失败，从而提升性能。</p>
<p>扩展了解:</p>
<blockquote>
<p>Unsafe:</p>
<p>CAS的底层就是使用Unsafe来进行实现的。</p>
<p>Unsafe是java提供给我们能够直接操作内存空间的方法。只能通过java反射来进行暴力的获取。</p>
<p>Unsafe类中的.compareAndSwapInt就是CAS底层的原理。</p>
<p>要获取到属性的偏移量，然后根据偏移量来进行修改。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Unsafe1</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchFieldException<span class="token punctuation">,</span> IllegalAccessException <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//通过反射获取我们的属性 unsafe</span>
        Field theUnsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"theUnsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        theUnsafe<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Unsafe unsafe<span class="token operator">=</span><span class="token punctuation">(</span>Unsafe<span class="token punctuation">)</span>theUnsafe<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Student student <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//获取对象的偏移量</span>
        Field name <span class="token operator">=</span> Student<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Field id <span class="token operator">=</span> Student<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> nameOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> idOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
        unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span>student<span class="token punctuation">,</span>idOffset<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapObject</span><span class="token punctuation">(</span>student<span class="token punctuation">,</span>nameOffset<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>student<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</blockquote>
<h2 id="26、ThreadLocal"><a href="#26、ThreadLocal" class="headerlink" title="26、ThreadLocal"></a>26、ThreadLocal</h2><p>1、ThreadLocal可以实现资源对象的线程的隔离，让每个线程各用各的资源对象，避免引发线程安全的问题。</p>
<p>2、ThreadLocal同时实现线程内的资源共享</p>
<p>能干嘛？</p>
<p>实现每一个线程都有自己专属的本地变量副本(自己用自己的变量不麻烦别人,不和其他人共享,人人有份，人格一份)，主要解决了让每个线程绑定自己的值，通过使用get()和set()方法，获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全问题。</p>
<p>ThreadLocal和synchronized的区别:</p>
<p>虽然ThreadLocal模式与synchronized关键字都用于处理多线程并发访问变量的问题,不过两者处理问题的角度的和思路不同。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220228172356806.png" alt="image-20220228172356806"></p>
<p>源码分析:</p>
<p>1、Thread，点击发现有一个Thread Locals，点击ThreadLocal发现里面有一个静态的内部类ThreadLocalMap。三者之间的关系:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220707214316966.png" alt="image-20220707214316966"></p>
<p>ThreadLocalMap实际上就是一个以ThreadLocal为key，任意对象为value的entry对象。</p>
<p>当我们为threadlocal变量赋值，实际上就是以当前threadLocal实例为key,值为value的Entry往这个threadLocalMap中存放。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220707222252090.png" alt="image-20220707222252090"></p>
<p>1、获取当前线程实例，调用getMap方法，参数为当前线程，返回值为ThreadLocalMap。去拿到ThreadLocalMap的值</p>
<p>2、判断map是否为null，如果为null，则调用Initialvalue进行初始化。</p>
<p>3、如果不为null,则调用map的getEntry方法，传入当前线程，返回一个Entry对象，拿到entry对象中的value值，进行一个返回。</p>
<p>4、entry对象以key，value键值对的形式存储数据，key为ThreadLocal，value为object对象。来进行取值和存值。</p>
<p>在ThreadLocalMap的entry对象继承了WeakReference，包转成了一个弱引用对象，当我们的垃圾收集器来进行垃圾收集的时候，不管内存空间是否足够，都会清理到ThreadLocalMap中的对象。</p>
<p>出现的问题:</p>
<p>必须回收自定义的ThreadLocal变量，尤其在线程池场景下，线程经常会被复用,如果不清理自定义的ThreadLocal变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用try-finlly块进行回收。</p>
<h2 id="27、什么是线程的死锁？如何避免死锁"><a href="#27、什么是线程的死锁？如何避免死锁" class="headerlink" title="27、什么是线程的死锁？如何避免死锁?"></a>27、什么是线程的死锁？如何避免死锁?</h2><p>死锁:一个线程需要同时获取多把锁，这时就容易发生死锁</p>
<p>t1 线程获得A对象锁，接下来想获取 B对象的锁 t2 线程获得B对象锁,接下来想获取A对象的锁,这样就会产生死锁。</p>
<p>死锁必须具备以下四个条件:</p>
<ul>
<li>互斥条件:该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程以获得的资源在未使用完之前不能被其他线程强行剥夺，只能自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>如何避免死锁:</p>
<p>通过调整获取的锁的顺序来解决死锁的问题，比如规定:要想获取B对象锁，必须先获取A对象锁才可以。按顺序来取锁就可以避免死锁的产生。</p>
<h2 id="28、Park和unPark的使用"><a href="#28、Park和unPark的使用" class="headerlink" title="28、Park和unPark的使用"></a>28、Park和unPark的使用</h2><p>使用LockSuport类中的方法，</p>
<p>&#x2F;&#x2F; 暂停当前线程<br>LockSupport.park(); </p>
<p>&#x2F;&#x2F; 恢复某个线程的运行<br>LockSupport.unpark(暂停线程对象)</p>
<p>与 Object 的 wait &amp; notify 相比：</p>
<p>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</p>
<p>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll </p>
<p>是唤醒所有等待线程，就不那么【精确】</p>
<p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</p>
<p>底层实现原理:也是使用的Unsafe类的unpark方法。</p>
<h2 id="29、Lock锁"><a href="#29、Lock锁" class="headerlink" title="29、Lock锁"></a>29、Lock锁</h2><p>Lock实现提供比使用synchronized方法和语句可以获得的更广泛的锁定操作。 它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个相关联的对象Condition.</p>
<p>对比synchronzied的特点:</p>
<p>1、可重入</p>
<p>2、可以设置超时时间</p>
<p>3、可以设置为公平锁</p>
<p>4、支持多个条件变量</p>
<p>ReentrantLock(可重入锁)、ReentrantReadWriteLock.ReadLock（读锁）、ReentrantReadWriteLock.WriteLock(写锁)</p>
<p>如何使用</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UseReentrantLock</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> ReentrantLock lock<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">try</span><span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">//所需操作</span>
         <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>
             e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{</span>
             lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="30、lock和synchronized的区别"><a href="#30、lock和synchronized的区别" class="headerlink" title="30、lock和synchronized的区别:"></a>30、lock和synchronized的区别:</h2><p>1、lock是java.utils.current包下的接口，synchronzied是属于java官方给内置关键字。</p>
<p>2、synchronized无法判断获取锁的状态，lock可以判断是否获取锁。</p>
<p>3、synchronized会执行我们的业务操作后会自动释放锁，而我们的lock是需要我们搭配tryfinally一起使用手动的释放锁。</p>
<p>4、synchronzied如果存在多个线程获取锁的话，其中只有一个线程可以获取到锁，其他的线程会被阻塞住。lock锁可以去尝试获取锁。</p>
<p>5、synchronized的锁是可重入、不可中断、非公平，lock锁可重入、可中断、可公平的锁。</p>
<h2 id="31、如何精准的控制lock"><a href="#31、如何精准的控制lock" class="headerlink" title="31、如何精准的控制lock:"></a>31、如何精准的控制lock:</h2><p>使用的是条件变量来进行控制.</p>
<p>synchronized提供了wait和notify来进行线程之间的通信.</p>
<p>而ReentrantLock的条件变量比synchronized强大之处就在于，它是支持多个条件变量的。</p>
<p>synchronized是那些不满足条件的线程在同一间休息室中等消息。</p>
<p>而ReentrantLock支持多件休息室，让不同的条件的线程进入到不同的休息室。然后进行精确唤醒.</p>
<p>await方法，线程等待</p>
<p>signal()方法，唤醒线程</p>
<h2 id="32、JUC的几个辅助类"><a href="#32、JUC的几个辅助类" class="headerlink" title="32、JUC的几个辅助类:"></a>32、JUC的几个辅助类:</h2><p>1、CountDownLatch类，允许一个类或多个类等待直到其他线程执行完一组操作的同步辅助</p>
<p>用来进行线程同步协作，等待所有线程完成倒计时。其中构造参数用来初始化等待计数值，await()用来等待计数归零，countDown()用来让计数减一</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountDawnLatch1</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> CountDownLatch count<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
           <span class="token keyword">try</span> <span class="token punctuation">{</span>
               TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程一正在执行....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           count<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程二正在执行....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            count<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程三正在执行....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            count<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            count<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"线程四正在执行...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>2、CyclicBarrier</p>
<p>允许一组线程全部等待彼此达到共同屏障点的同步辅助。 循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。 屏障被称为循环 ，因为它可以在等待的线程被释放之后重新使用。</p>
<p>作用：它的作用就是会让所有线程都等待完成后才会继续下一步行动。<br>它和CountDownLatch一样，只不过一个时减一个时加</p>
<p>CyclicBarrier是使用我们的ReentrantLock来进行实现的。</p>
<p>如果调用了await()方法,</p>
<p><strong>1、先检查前面是否已经有count个线程了，如果没有线程则会进入等待状态</strong><br><strong>2、当检测到屏障已经有count个线程了，则所有线程会冲出屏障继续执行（如果有Runnable参数的构造方法先执行汇总方法）</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CyclicBarrierDemo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        CyclicBarrier cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"老师进行关门"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t 学生出门"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>

            <span class="token punctuation">}</span><span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>3、Semaphore</p>
<p>1、acquire(获取)当一个线程调用acquire操作时,它要么通过成功获取信号量(信号量减一)，要么一直等下去,直到有线程释法信号量，或超时。</p>
<p>2、release(释放)实际上会将信号量的值加1，然后唤醒等待的线程。</p>
<p>信号量主要作用于两个目的,一个时用于多个线程共享资源的互斥使用,另一个用于并发线程数的控制</p>
<p>使用Semaphore限流，在访问最高峰期时,让请求线程阻塞，高峰期过去在释放许可,当然它只适合限制单机线程数量，并且仅是限制线程数，而不是限制资源数</p>
<p>用Semaphore实现简单连接池，对比享元模式下的实现(wait notify)，性能和可读性显然更好。</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Semaphore1</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//抢车位 可以用来秒杀业务</span>
        Semaphore semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//只有三个车位</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span><span class="token number">6</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t 抢占类车位"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">try</span> <span class="token punctuation">{</span>
                        TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"\t 离开类车位"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>
                    semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Semaphore原理:</p>
<p>加锁解锁流程:</p>
<p>Semaphore有点像一个停车场,permits就好像停车位数量，当线程获取了permist就像是获得了停车位，然后停车场显示空余车位减一</p>
<p>刚开始,permist为3，这时5个线程来获取资源</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220803165430483.png" alt="image-20220803165430483"></p>
<p>假设其中Thread-1，Thread-2，Thread-4 cas竞争成功,而Thread-0和Thread-3竞争失败,进入AQS队列park阻塞。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220803173153987.png" alt="image-20220803173153987"></p>
<p>这时Thread-4释放了permist，状态如下:</p>
<pre class=" language-java"><code class="language-java">sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220803173235251.png" alt="image-20220803173235251"></p>
<p>接下来Thread-0竞争成功，permist再次设置为0，设置自己为head节点，断开原来的head节点，unpark接下来Thread-3节点，但由于permist是0，因此Thread-3在尝试不成功后再次进入park状态。</p>
<h2 id="33、AQS是什么？"><a href="#33、AQS是什么？" class="headerlink" title="33、AQS是什么？"></a>33、AQS是什么？</h2><p>全称是AbstractQueuedSynchronized是阻塞式锁和同步器工具开发的框架。</p>
<p>特点:</p>
<p>使用state属性来表示资源的状态,子类需要定义如何维护这个状态，控制如何获取。</p>
<p>锁的获取和释放：</p>
<ul>
<li>getState：获取锁的状态</li>
<li>setState：设置state的状态</li>
<li>compareAndSetState:利用cas来设置state状态</li>
</ul>
<p>独占模式表示只有一个线程能访问资源，而共享模式可以允许多个线程访问资源。</p>
<p>提供了机遇FIFO的等待队列。类似于MInitor的EntryList。条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet子类主要实现这样一些方法(默认抛出UNsupportedOperationException)</p>
<p>tryAcquice尝试获取锁<br>tryRelease 尝试释放锁</p>
<p>基本思想:</p>
<p>  通过修改AQS中的state来判断是否加锁成功，如果cas为1，则表示加锁成功，然后将owner置为当前线程。<br>  释放锁的逻辑，判断state是否为1，为1表示有锁，修改0，表示无锁，然后将owner置为null。<br>要点:</p>
<ul>
<li>原子维护state状态。</li>
<li>阻塞及恢复线程</li>
<li>维护队列</li>
</ul>
<p>state使用volatile配合cas包装其修改时的原子性</p>
<h2 id="34、ReentrantLock原理"><a href="#34、ReentrantLock原理" class="headerlink" title="34、ReentrantLock原理:"></a>34、ReentrantLock原理:</h2><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220706110401775.png" alt="image-20220706110401775"></p>
<p>非公共锁的实现:</p>
<p>加锁流程:</p>
<p>先从构造器开始看,默认为非公平锁实现: sync&#x3D;new NonfairSync即成于AQS<br>没有竞争时:</p>
<p>直接将锁NofairSync里面的owner置为当前线程即可。</p>
<p>当有竞争时:</p>
<p>1、Thread-1去尝试执行cas改为1，结果失败的。</p>
<p>2、进入到tryAcquire逻辑，这时state已经是1，结果仍然失败。</p>
<p>3、接下来进入addWaiter逻辑，构造Node队列:</p>
<p>其中第一个Node称为头节点，用来占位，并不关联线程。</p>
<p>4、当前线程会进入到AcquireQueued逻辑:</p>
<ul>
<li>acquireQueued会在一个死循环中不断尝试获取锁，失败后进入park阻塞。</li>
<li>如果自己是近邻着head(排第二位),那么再次tryAcquire尝试获取锁，当然这是state仍未1，失败。</li>
<li>进入shouIdParkAfterFailedAcquire逻辑，将前驱node，即head到waitStatus改为-1，这次返回false</li>
</ul>
<p>5、shouIdparkAfterFailedAcquired执行完毕回到acquireQueued，再次tryAcquire尝试获取锁，当然这是state仍为1，失败。</p>
<p>6、当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</p>
<p>7、进入 parkAndCheckInterrupt， Thread-1 park(灰色表示)</p>
<p>8、再次有多个线程经历上述过程竞争失败，变成这个样子</p>
<p>9、Thread-0 释放锁，进入 tryRelease 流程，如果成功</p>
<ul>
<li>设置onwer为null，将state改为0.表示解锁成功。</li>
</ul>
<p>10、当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor 流程找到队列中离 head 最近的一个 Node(没取消的)，unpark 恢复其运行，本例中即为 Thread-1 回到Thread-1 的 acquireQueued 流程</p>
<p>11、如果加锁成功(没有竞争)，会设置omwer为当前线程，并把这个state设置1.表示加锁成功,head指向刚刚Thread-1所在的Node，该Node清空Thread。原本的Head因为链表断开，被垃圾回收。</p>
<h2 id="35、读写锁ReadWirteLock"><a href="#35、读写锁ReadWirteLock" class="headerlink" title="35、读写锁ReadWirteLock"></a>35、读写锁ReadWirteLock</h2><p>读写锁ReadWirteLock:一对关联的locks，一个用于只读操作，一个用于写入。</p>
<p>为什么会存在呢</p>
<p>因为之前的lock它是全锁而不是分离锁，我们一般情况下只有在修改的情况下才需要加锁，在读的情况下，是不需要加锁的。</p>
<p>读读可共享、读写谢谢要独占。</p>
<p>总结：读的时候是共享锁(都能读,不能写),写的时候排它锁(只能当下的线程写，不能读)</p>
<h2 id="36、Blocking"><a href="#36、Blocking" class="headerlink" title="36、Blocking"></a>36、Blocking</h2><p>Blocking大部分实现基于锁,并提供用来阻塞的方法</p>
<p>BlockingQueue阻塞队列：先进先出</p>
<p>当队列是空的，从队列中获取元素的操作将会被阻塞</p>
<p>当队列是满的，从队列中添加元素的操作将会被阻塞</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1、OSI-和-TCP-x2F-IP-网络分层模型"><a href="#1、OSI-和-TCP-x2F-IP-网络分层模型" class="headerlink" title="1、OSI 和 TCP&#x2F;IP 网络分层模型"></a>1、OSI 和 TCP&#x2F;IP 网络分层模型</h2><p>OSI七层模式时国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示:</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-model-detail.png" alt="img"></p>
<p>1、物理层:机械、电子、定时接口通信信道上的原始比特流传输</p>
<p>2、数据链路层:物理寻址，同时将原始比特流转变为逻辑传输线路。</p>
<p>3、网络层:控制子网的允许，如逻辑编址、分组传输、路由选择。</p>
<p>4、传输层:接收上一层的数据，在必要的时候把数据进行分割，并将这些数据交给网络层，且保证这些数据段有效到达对端。</p>
<p>5、会话层:不同机器上的用户之间建立及管理会话。</p>
<p>6、表示层:信息的语法语义以及它们的关联，如加密解密、转换翻译、压缩解压缩。</p>
<p>7、应用层:各种应用程序协议，如http、ftp等</p>
<h2 id="2、TCP-x2F-IP四层模型"><a href="#2、TCP-x2F-IP四层模型" class="headerlink" title="2、TCP&#x2F;IP四层模型"></a>2、TCP&#x2F;IP四层模型</h2><p><strong>TCP&#x2F;IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP &#x2F; IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p>1、应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。我们把应用层交互的数据单元称为报文。</p>
<p>应用层协议定义网络通信规则，对于不同的网络应用需要不同的应用层协议。web应用的http协议。邮件SMTP协议等。</p>
<p>2、传输层</p>
<p>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。”通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<p>运输层主要使用以下两种协议:</p>
<ul>
<li><p>传输控制协议TCP– 提供面向连接的可靠的数据传输服务。</p>
</li>
<li><p>用户传输协议UDP– 提供无连接的，尽最大努力的数据传输服务(不保证数据传输的可靠性)</p>
</li>
</ul>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/transport-layer-protocol.png" alt="传输层重要协议"></p>
<p>3、网络层</p>
<p>网路层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP&#x2F;IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<p><strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p>
<p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p>
<p>网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Prococol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/nerwork-layer-protocol.png" alt="网络层重要协议"></p>
<p><strong>网络层常见协议</strong> ：</p>
<ul>
<li>IP协议：网际协议 IP 是TCP&#x2F;IP协议中最重要的协议之一，也是网络层最重要的协议之一，IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。目前IP协议主要分为两种，一种是过去的IPv4，另一种是较新的IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li>
</ul>
<p>4、网络接口层</p>
<p>我们把网络接口层看作是数据链路层和物理层的合体。</p>
<p>1、数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></p>
<p>2、物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/network-interface-layer-protocol.png" alt="网络接口层重要协议"></p>
<p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p>
<h2 id="3、应用层有哪些常见的协议"><a href="#3、应用层有哪些常见的协议" class="headerlink" title="3、应用层有哪些常见的协议"></a>3、应用层有哪些常见的协议</h2><p>1、HTTP:超文本传输协议</p>
<p><strong>超文本传输协议（HTTP，HyperText Transfer Protocol)</strong> 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/450px-HTTP-Header.png" alt="img"></p>
<p>HTTP 协议是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p>
<p>另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。</p>
<p>2、SMTP协议:简单邮件传输协议</p>
<p><strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong> 基于 TCP 协议，用来发送电子邮件。SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p>
<ol>
<li>电子邮件的发送过程</li>
<li>如何判断邮箱是真正存在的？</li>
</ol>
<p><strong>电子邮件的发送过程？</strong></p>
<p>比如我的邮箱是“<a href="mailto:&#x64;&#97;&#98;&#97;&#x69;&#x40;&#99;&#115;&#x7a;&#104;&#105;&#110;&#97;&#110;&#x2e;&#x63;&#111;&#x6d;">&#x64;&#97;&#98;&#97;&#x69;&#x40;&#99;&#115;&#x7a;&#104;&#105;&#110;&#97;&#110;&#x2e;&#x63;&#111;&#x6d;</a>”，我要向“<a href="mailto:&#x78;&#x69;&#97;&#111;&#109;&#x61;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;">&#x78;&#x69;&#97;&#111;&#109;&#x61;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;</a>”发送邮件，整个过程可以简单分为下面几步：</p>
<ol>
<li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给163邮箱服务器（邮局）。</li>
<li>163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。</li>
<li>qq邮箱服务器接收邮件之后就通知邮箱为“<a href="mailto:&#x78;&#x69;&#97;&#x6f;&#x6d;&#97;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d;">&#x78;&#x69;&#97;&#x6f;&#x6d;&#97;&#64;&#113;&#113;&#46;&#99;&#111;&#x6d;</a>”的用户来收邮件，然后用户就通过 <strong>POP3&#x2F;IMAP</strong> 协议将邮件取出。</li>
</ol>
<p>注意⚠️：<strong>接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p>
<p><strong>如何判断邮箱是真正存在的？</strong></p>
<p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p>
<ol>
<li>查找邮箱域名对应的 SMTP 服务器地址</li>
<li>尝试与服务器建立连接</li>
<li>连接成功后尝试向需要验证的邮箱发送邮件</li>
<li>根据返回结果判定邮箱地址的真实性</li>
</ol>
<p>3、FTP:文件传输协议</p>
<p><strong>FTP 协议</strong> 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p>
<p>FTP 是基于客户—服务器（C&#x2F;S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p>
<blockquote>
<p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p>
<ol>
<li>控制连接：用于传送控制信息（命令和响应）</li>
<li>数据连接：用于数据传送；</li>
</ol>
<p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p>
</blockquote>
<p>4、SSH:安全的网络传输协议</p>
<p><strong>SSH（ Secure Shell）</strong> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</p>
<h2 id="4、TCP和UDP的区别"><a href="#4、TCP和UDP的区别" class="headerlink" title="4、TCP和UDP的区别"></a>4、TCP和UDP的区别</h2><p>1、是否面向连接:UDP在传输数据之前不需要先建立连接。而TCP提供面向连接的服务，在传输数据之前必须先建立连接，数据传输结束后释放连接。</p>
<p>2、是否是可靠传输:远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p>
<p>3、是否有状态:TCP是传输有状态，记录自己发送消息的状态比如是否发送了、是否被接收了等等。UDP是无状态服务。简单来说就是不管发出去之后的事情。</p>
<p>4、传输效率:UDP传输是高于我们的TCP。</p>
<p>5、传输形式:TCP是面向字节流的，UDP是面向报文的。</p>
<p>6、是否提供广播服务:TCP只支持点对点的通信，UDP支持一对一、一对多、多对多。</p>
<p>应用场景:</p>
<p>1、udp一般用于即时通信,比如:语音、视频、直播等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别不是很大。</p>
<p>2、TCP一般用于传输准确性要求特别高的场景，比如:文件传输、发送和接收邮件等。</p>
<h2 id="5、HTTP基于TCP还是UDP？"><a href="#5、HTTP基于TCP还是UDP？" class="headerlink" title="5、HTTP基于TCP还是UDP？"></a>5、HTTP基于TCP还是UDP？</h2><p>HTTP 3.0 之前是基于 TCP 协议的，而 HTTP3.0 将弃用 TCP，改用 <strong>基于 UDP 的 QUIC 协议</strong> 。此变化主要为了解决 HTTP&#x2F;2 中存在的队头阻塞问题。由于 HTTP&#x2F;2 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。</p>
<h2 id="6、使用TCP端协议有哪些？使用UDP端协议有哪些？"><a href="#6、使用TCP端协议有哪些？使用UDP端协议有哪些？" class="headerlink" title="6、使用TCP端协议有哪些？使用UDP端协议有哪些？"></a>6、使用TCP端协议有哪些？使用UDP端协议有哪些？</h2><p>运行于TCP协议之上的协议：</p>
<p>1、HTTP协议:超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</p>
<p>2、HTTPS协议:更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</p>
<p>3、<strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，<strong>基于 TCP</strong> 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p>
<p>4、<strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</p>
<p>运行于UDP协议:</p>
<ol>
<li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li>
<li><strong>DNS</strong> ： <strong>域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。</strong> 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。</li>
</ol>
<h2 id="7、TCP三次握手和四次挥手-非常重要🌟🌟🌟🌟🌟"><a href="#7、TCP三次握手和四次挥手-非常重要🌟🌟🌟🌟🌟" class="headerlink" title="7、TCP三次握手和四次挥手(非常重要🌟🌟🌟🌟🌟)"></a>7、TCP三次握手和四次挥手(非常重要🌟🌟🌟🌟🌟)</h2><h3 id="7-1-、TCP三次握手"><a href="#7-1-、TCP三次握手" class="headerlink" title="7.1 、TCP三次握手:"></a>7.1 、TCP三次握手:</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" alt="TCP 三次握手图解"></p>
<p>建立一个TCP连接需要”三次握手”,缺一不可:</p>
<ul>
<li>一次握手:客户端发送带有SYN(SEQ&#x3D;x)标志的数据包–&gt;服务端，然后客户端会进入到send状态，等待服务器端确认。</li>
<li>二次握手:服务端发送带有SYN+ACK标志的数据包–&gt;客户端。</li>
<li>第三次握手:客户端发送带有ACK(ACK&#x3D;y+1)标志的数据包–&gt;服务端，然后客户端和服务器都进入<strong>确认状态</strong>完成TCP三次握手。</li>
</ul>
<p>当建立三次握手之后，客户端和服务器就可以传输数据啦！</p>
<h3 id="7-2-、为什么要三次握手"><a href="#7-2-、为什么要三次握手" class="headerlink" title="7.2 、为什么要三次握手"></a>7.2 、为什么要三次握手</h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<p><strong>第一次握手</strong> ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p><strong>第二次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p><strong>第三次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<p>三次握手就能确认双方收发功能都正常，缺一不可。</p>
<h2 id="7-3-断开连接-TCP-四次挥手"><a href="#7-3-断开连接-TCP-四次挥手" class="headerlink" title="7.3  断开连接-TCP 四次挥手"></a>7.3  断开连接-TCP 四次挥手</h2><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-waves-four-times.png" alt="TCP 四次挥手图解"></p>
<p>断开一个TCP连接则需要”四次挥手”,缺一不可:</p>
<p><strong>第一次挥手</strong> ：客户端发送一个 FIN（SEQ&#x3D;X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</p>
<p><strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （SEQ&#x3D;X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</p>
<p><strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</p>
<p><strong>第四次挥手</strong> ：客户端发送 ACK (SEQ&#x3D;y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</p>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>
<h3 id="7-4-为什么要四次挥手？"><a href="#7-4-为什么要四次挥手？" class="headerlink" title="7.4 为什么要四次挥手？"></a>7.4 为什么要四次挥手？</h3><p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后。</p>
<ol>
<li><strong>第一次挥手</strong> ： A 说“我没啥要说的了”</li>
<li><strong>第二次挥手</strong> ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li>
<li><strong>第三次挥手</strong> ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li>
<li><strong>第四次挥手</strong> ：A 回答“知道了”，这样通话才算结束。</li>
</ol>
<h2 id="8、HTTP"><a href="#8、HTTP" class="headerlink" title="8、HTTP"></a>8、HTTP</h2><p>从输入URL到页面展示到底发生了什么？(非常重要🌟🌟🌟🌟🌟)</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="img"></p>
<p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS 解析:将浏览器的域名解析(DNS)成IP地址</li>
<li>TCP 连接：浏览器会向我们的服务器发送一个HTTP请求之前，会先经过我们的三次握手建立一个TCP连接。发送数据在网络层使用IP协议来进行数据的发送。</li>
<li>发送 HTTP 请求:使用HTTP协议访问网页。</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h2 id="9、HTTP状态码"><a href="#9、HTTP状态码" class="headerlink" title="9、HTTP状态码"></a>9、HTTP状态码</h2><p>HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png" alt="常见 HTTP 状态码"></p>
<h2 id="10、HTTP和HTTPS有什么区别"><a href="#10、HTTP和HTTPS有什么区别" class="headerlink" title="10、HTTP和HTTPS有什么区别?"></a>10、HTTP和HTTPS有什么区别?</h2><p><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</p>
<p><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</p>
<p><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p>
<h2 id="11、HTTP-是不保存状态的协议-如何保存用户状态"><a href="#11、HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="11、HTTP 是不保存状态的协议, 如何保存用户状态?"></a>11、HTTP 是不保存状态的协议, 如何保存用户状态?</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p>
<h2 id="12-、URI-和-URL-的区别是什么"><a href="#12-、URI-和-URL-的区别是什么" class="headerlink" title="12 、URI 和 URL 的区别是什么?"></a>12 、URI 和 URL 的区别是什么?</h2><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="13、ARP"><a href="#13、ARP" class="headerlink" title="13、ARP"></a>13、ARP</h2><h3 id="什么是-Mac-地址？"><a href="#什么是-Mac-地址？" class="headerlink" title="什么是 Mac 地址？"></a>什么是 Mac 地址？</h3><p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。</p>
<p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p>
<blockquote>
<p> 还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。</p>
</blockquote>
<p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（$2^{48}$），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。</p>
<p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p>
<p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p>
<h3 id="ARP-协议解决了什么问题地位如何？"><a href="#ARP-协议解决了什么问题地位如何？" class="headerlink" title="ARP 协议解决了什么问题地位如何？"></a>ARP 协议解决了什么问题地位如何？</h3><p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">kevintam</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E9%A2%98/">http://example.com/2023/04/06/%E9%9D%A2%E8%AF%95%E9%A2%98/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint policy. If reproduced, please indicate source
                    <a href="/about" target="_blank">kevintam</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/java/">
                                    <span class="chip bg-color">java</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;Current
            </div>
            <div class="card">
                <a href="/2023/04/06/%E9%9D%A2%E8%AF%95%E9%A2%98/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="面试题">
                        
                        <span class="card-title">面试题</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-04-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/java/">
                        <span class="chip bg-color">java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/03/29/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="原型模式">
                        
                        <span class="card-title">原型模式</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-03-29
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                        <span class="chip bg-color">设计模式</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + 'From: kevintam<br />'
            + 'Author: kevintam<br />'
            + 'Link: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">kevintam</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;Total visits:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;Total visitors:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/txh-rookie" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=843808107" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 843808107" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
