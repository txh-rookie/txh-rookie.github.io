<!DOCTYPE HTML>
<html lang="zh">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="kevintam">
    <meta name="description" content="MySQL篇1、mysql中的配置文件1、bin-log：二进制文件，用于主从复制
2、错误日志log-error：默认关闭，记录严重的警告和错误信息
3、查询日志show-log：记录查询的SQL语句
4、mysql中的innodb存储文">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>kevintam</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">kevintam</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">kevintam</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/txh-rookie" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>txh-rookie
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/txh-rookie" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="txh-rookie" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2023-05-02
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="MySQL篇"><a href="#MySQL篇" class="headerlink" title="MySQL篇"></a>MySQL篇</h1><h2 id="1、mysql中的配置文件"><a href="#1、mysql中的配置文件" class="headerlink" title="1、mysql中的配置文件"></a>1、mysql中的配置文件</h2><p>1、bin-log：二进制文件，用于主从复制</p>
<p>2、错误日志log-error：默认关闭，记录严重的警告和错误信息</p>
<p>3、查询日志show-log：记录查询的SQL语句</p>
<p>4、mysql中的innodb存储文件的格式:</p>
<p>frm文件:存放表结构</p>
<p>myd:存储表数据</p>
<p>myi:存放表索引</p>
<h2 id="2、MYSQL的架构"><a href="#2、MYSQL的架构" class="headerlink" title="2、MYSQL的架构"></a>2、MYSQL的架构</h2><p><img src="https://images2018.cnblogs.com/blog/706569/201806/706569-20180621091238334-962479342.png" alt="截图"></p>
<p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。<br>主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离。<br>这种架构可以根据业务的需求和实际需要选择合适的存储引擎<br>1、连接层:最上层的连接，主要用于与各种客户端进行连接tcp&#x2F;ip的通信。主要完成一些连接处理、授权登录等相关的安全方案。<br>2、服务层:</p>
<ul>
<li>Management servcie:系统管理</li>
<li>SQl interface:接收用户的sql语句，并且返回用户需要查询的结果。</li>
<li>parser解析器:将sql命令传递到解析器的时候会被解析验证。</li>
<li>OPtimizer:查询优化器.SQL语句在查询之前会使用查询优化器对查询语句进行优化。</li>
<li>cache:缓存，就是将查询的数据加入到缓存中，下次来直接去缓存中拿即可。但是因为mysql的cache缓存设计的不是很好，所以在8.0版本移除了缓存。</li>
</ul>
<p>3、引擎层：</p>
<ul>
<li>存储引擎层,存储引擎层真正的负责了MySQL中数据的存储和提取，服务器通过Api与存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和innoDB</li>
</ul>
<p>4、存储层，数据存储层，主要是将数据库中的数据存储在磁盘中。</p>
<h2 id="3、查询流程"><a href="#3、查询流程" class="headerlink" title="3、查询流程"></a>3、查询流程</h2><p> 1、mysql客户端通过协议与MySQL服务器建利连接，发送查询语句，先检查查询缓存，如果命中，直接返回，否则就会进入语句解析。</p>
<p>2、首先mysql通过关键字将sql语句进行解析，并生成一颗对应的解析树。mysql解析器将会使用mysql语法规则验证和解析查询，预处理器则根据一些mysql规则进一步检查解析树是否合法。</p>
<p>3、查询优化器当解析树被认为是合法的了，并且由优化器将其转化成执行计划，一条查询可以有很多中执行方式，最终都会返回相同的结果。优化器作用就是找到这其中最好的执行计划。</p>
<p>4、然后，mysql默认使用的Btree索引，并且一个大致方向是:无论怎么折腾sql，至少在目前来说，mysql最多只用到表中的一个索引。</p>
<h2 id="4、存储的引擎的对比"><a href="#4、存储的引擎的对比" class="headerlink" title="4、存储的引擎的对比"></a>4、存储的引擎的对比</h2><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220107210125472.png" alt="image-20220107210125472"></p>
<h3 id="各个引擎的区别"><a href="#各个引擎的区别" class="headerlink" title="各个引擎的区别"></a>各个引擎的区别</h3><ol>
<li><p><strong>InnoDB</strong>存储引擎：InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。行级锁，适合高并发情况</p>
</li>
<li><p><strong>MyISAM</strong>存储引擎：MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁(myisam改表时会将整个表全锁住)，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</p>
</li>
<li><p>Archive引擎：Archive存储引擎只支持INSERT和SELECT操作，在MySQL5.1之前不支持索引。Archive表适合日志和数据采集类应用。适合低访问量大数据等情况。根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</p>
</li>
<li><p>Blackhole引擎：Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。</p>
</li>
<li><p>CSV引擎：CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。CSV引擎可以作为一种数据交换的机制，非常有用。CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。</p>
</li>
<li><p>Memory引擎：如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。Memory表至少比MyISAM表要快一个数量级。(使用专业的内存数据库更快，如redis)</p>
<p>Memory引擎使用就是我们的Hash索引。</p>
</li>
<li><p>Federated引擎：Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</p>
</li>
</ol>
<h2 id="5、分析SQL性能下降、执行时间长、等待时间长"><a href="#5、分析SQL性能下降、执行时间长、等待时间长" class="headerlink" title="5、分析SQL性能下降、执行时间长、等待时间长"></a>5、分析SQL性能下降、执行时间长、等待时间长</h2><p>1、关联数据过多</p>
<p>2、关联了太多的表，太多的join，join原理。用A表去循环扫描B表里的数据，所以需要优先过滤</p>
<p>3、没有使用索引。</p>
<h2 id="6、JOIN的关联图"><a href="#6、JOIN的关联图" class="headerlink" title="6、JOIN的关联图"></a>6、JOIN的关联图</h2><p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230123154254603.png" alt="image-20230123154254603"></p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> DEPT <span class="token number">d</span> <span class="token keyword">inner</span> <span class="token keyword">join</span> emp <span class="token number">e</span> <span class="token keyword">on</span> <span class="token number">d</span><span class="token punctuation">.</span>DEPTNO<span class="token operator">=</span><span class="token number">e</span><span class="token punctuation">.</span>DEPTNO <span class="token comment" spellcheck="true">#去交集</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> dept <span class="token number">d</span> <span class="token keyword">left</span> <span class="token keyword">join</span> emp <span class="token number">e</span> <span class="token keyword">on</span> <span class="token number">d</span><span class="token punctuation">.</span>DEPTNO<span class="token operator">=</span><span class="token number">e</span><span class="token punctuation">.</span>DEPTNO <span class="token comment" spellcheck="true">#取a表的全部和a和b的交集</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> dept <span class="token number">d</span> <span class="token keyword">left</span> <span class="token keyword">join</span> emp <span class="token number">e</span> <span class="token keyword">on</span> <span class="token number">d</span><span class="token punctuation">.</span>DEPTNO<span class="token operator">=</span><span class="token number">e</span><span class="token punctuation">.</span>DEPTNO <span class="token keyword">where</span> <span class="token number">e</span><span class="token punctuation">.</span>DEPTNO  <span class="token operator">is</span> <span class="token boolean">null</span> <span class="token comment" spellcheck="true">#取a独有的部分</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> dept <span class="token number">d</span> <span class="token keyword">right</span> <span class="token keyword">join</span> emp <span class="token number">e</span> <span class="token keyword">on</span> <span class="token number">d</span><span class="token punctuation">.</span>DEPTNO<span class="token operator">=</span><span class="token number">e</span><span class="token punctuation">.</span>DEPTNO

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> dept <span class="token number">d</span> <span class="token keyword">right</span> <span class="token keyword">join</span> emp <span class="token number">e</span> <span class="token keyword">on</span> <span class="token number">d</span><span class="token punctuation">.</span>DEPTNO<span class="token operator">=</span><span class="token number">e</span><span class="token punctuation">.</span>DEPTNO <span class="token keyword">where</span> <span class="token number">d</span><span class="token punctuation">.</span>DEPTNO <span class="token operator">is</span> <span class="token boolean">null</span>

<span class="token comment" spellcheck="true">#UNION的联合加去重</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> dept <span class="token number">d</span> <span class="token keyword">left</span> <span class="token keyword">join</span> emp <span class="token number">e</span> <span class="token keyword">on</span> <span class="token number">d</span><span class="token punctuation">.</span>DEPTNO<span class="token operator">=</span><span class="token number">e</span><span class="token punctuation">.</span>DEPTNO <span class="token keyword">where</span> <span class="token number">e</span><span class="token punctuation">.</span>DEPTNO <span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span> 
<span class="token keyword">union</span> 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> dept <span class="token number">d</span> <span class="token keyword">right</span> <span class="token keyword">join</span> emp <span class="token number">e</span> <span class="token keyword">on</span> <span class="token number">d</span><span class="token punctuation">.</span>DEPTNO<span class="token operator">=</span><span class="token number">e</span><span class="token punctuation">.</span>DEPTNO <span class="token keyword">where</span> <span class="token number">d</span><span class="token punctuation">.</span>DEPTNO <span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span> <span class="token punctuation">;</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> dept <span class="token number">d</span> <span class="token keyword">left</span> <span class="token keyword">join</span> emp <span class="token number">e</span> <span class="token keyword">on</span> <span class="token number">d</span><span class="token punctuation">.</span>DEPTNO<span class="token operator">=</span><span class="token number">e</span><span class="token punctuation">.</span>DEPTNO 

<span class="token keyword">union</span>

<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> dept <span class="token number">d</span> <span class="token keyword">right</span> <span class="token keyword">join</span> emp <span class="token number">e</span> <span class="token keyword">on</span> <span class="token number">d</span><span class="token punctuation">.</span>DEPTNO<span class="token operator">=</span><span class="token number">e</span><span class="token punctuation">.</span>DEPTNO <span class="token keyword">where</span> <span class="token number">d</span><span class="token punctuation">.</span>DEPTNO <span class="token operator">is</span>  <span class="token boolean">null</span> <span class="token operator">or</span> <span class="token number">e</span><span class="token punctuation">.</span>DEPTNO <span class="token operator">is</span> <span class="token boolean">null</span> <span class="token punctuation">;</span>
</code></pre>
<h2 id="7、SQL的执行顺序"><a href="#7、SQL的执行顺序" class="headerlink" title="7、SQL的执行顺序"></a>7、SQL的执行顺序</h2><p>我们常写的SQL顺序如下:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220107230821802.png" alt="image-20220107230821802"></p>
<p>机器顺序如下:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220107230947024.png" alt="image-20220107230947024"></p>
<p>机器执行顺序:</p>
<p>From 那张表</p>
<p>left join 关联那张表</p>
<p>on 连接条件的查询</p>
<p>where 对我们关联查询的数据进行过滤</p>
<p>group by对我们的数据进行分组</p>
<p>having:对我们的数据做进一步的过滤。</p>
<p>select:映射，找出你想显示的数据</p>
<p>&#x2F;&#x2F;分组函数</p>
<p>distinct 进行过滤</p>
<p>order by:进行排序</p>
<p>limit:进行截取 根据我们的选择进行截取</p>
<p>limit 起始字段、去的数据数</p>
<p>分页 limit (pageNo-1)*PageSize 得到我们的起始地址。</p>
<p>总结:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230123160452134.png" alt="image-20230123160452134"></p>
<h2 id="8、索引相关的面试题"><a href="#8、索引相关的面试题" class="headerlink" title="8、索引相关的面试题"></a>8、索引相关的面试题</h2><h3 id="8-1-、索引是什么"><a href="#8-1-、索引是什么" class="headerlink" title="8.1 、索引是什么"></a>8.1 、索引是什么</h3><p>索引是帮助我们高效查询的数据结构，也就是我们常说的b+树。</p>
<p>索引是在存储引擎中实现的,因此每种存储引擎的索引不一定完全相同,并且每种存储引擎不一定支持所有索引类型。</p>
<p>优点:</p>
<p>类似大学图书馆建书目索引,提高数据检索的效率,降低数据库的IO成本.</p>
<p>通过创建唯一索引,可以保证数据库表中每一行数据的唯一行在使用分组和排序子句进行数据查询时,可以显著减少查询中分组和排序的时间,降低CPU的消耗</p>
<p>缺点:<br>创建索引和维护索引要耗费时间，并且随着数据量大增加，所耗费的时间也会增加。</p>
<p>索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，存储在磁盘上。虽然索引大大提高了查询速度，同时却会降低更新表的速度。</p>
<h3 id="8-2-实现索引的方式"><a href="#8-2-实现索引的方式" class="headerlink" title="8.2 实现索引的方式"></a>8.2 实现索引的方式</h3><p>1、二叉排序树<br>2、hahs<br>3、多路平衡二叉树（Btree）<br>4、B+tree</p>
<p>二叉树的优缺点:就是二叉树在一种特殊的状态的下，可以会导致转成链表，可能导致变成全表扫描</p>
<p>hash，因为时间复杂度是0(1)非常快，也适合做索引，但是hash只能做等值索引，范围索引，使用不了hash。所以也不是很适合。</p>
<p>BTree因为节点里面都会存储数据，数据分布在整颗树上的。然后通过左旋和右旋来不定的平衡这个二叉树，所以可以解决二叉树的问题。但是Btree有一个的问题，我们去插入&#x2F;修改操作多时，B-TREE会不断调整平衡，消耗性能。btree的搜索的效率等与二分查询法。</p>
<p>B+Tree因为会将数据全部存储在叶子节点上，而且内部使用一个指针进行连接，形成一个链表方式，然后叶子节点之间会使用双向链表进行连接，来保证的数据的大小顺序。然后非叶子节点存储的叶子节点的索引，非叶子节点不存储任何数据，只存储指向叶子节点的指针。通过存储叶子节点的指针来缩小的树的高度。</p>
<p>mysql中数据的存储是页来进行的，每页中会有一些标识符，比如，record_type就是用于标识，如果为1标识普通的数据，2标识最小的数据，3标识最多的数据，依靠这个record_type来进行的排序，为1标识非叶子节点的数据，也就是存储的索引，也即是说用record_type来区分存储的是索引节点还是叶子节点。每个数据页的结构为:record_type、next指针，用于指各个数据页。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/63f468a6e4ea3560987268c1_hd.jpeg" alt="img"></p>
<h3 id="8-3、聚簇索引和非聚簇索引"><a href="#8-3、聚簇索引和非聚簇索引" class="headerlink" title="8.3、聚簇索引和非聚簇索引"></a>8.3、聚簇索引和非聚簇索引</h3><p>聚簇索引并不是一个单独的索引的结构,而是索引的存储方式。将所有的用户数据，存储在我们的叶子节点。这就是我们常说的聚簇索引。</p>
<p>主键索引就是一个典型的聚簇索引。</p>
<p>聚簇指的就是将多个数据行以相邻的方式存储在一起。</p>
<p>聚簇索引的特点:<br>  1、将数据存储在叶子节点，然后根据主键的大小进行排序，然后让我们的叶子节点里面的值以单向链表形式进行连接<br>  2、各自叶子节点之间使用根据主键的大小进行排序，然后根据双向链表来进行连接</p>
<p>聚簇索引inndb会自动帮我们进行创建。以主键进行创建。</p>
<p>优点:</p>
<p>1、数据访问块</p>
<p>2、聚簇索引对于主键的排序查找和范围查找速度非常快</p>
<p>3、按照聚簇索引排列顺序,查询显示一定范围数据的时候,由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io操作。</p>
<p>缺点:</p>
<p>插入速度严重依赖于插入顺序,按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。我们一般为了解决这种情况都会使用自增的id列为主键。</p>
<p>更新的主键的代价很高。</p>
<p>一张表只能有一个聚簇索引。但是可以多个二级索引。</p>
<p>非聚簇索引(二级索引):</p>
<p>在叶子节点中只存储表中的主键值，或者说是我们的建立的索引的字段值，不存储我们的数据。如果需要找到对应的结果,需要进行一次回表操作，去聚簇索引中查找对应的值。</p>
<h3 id="8-4、回表的概念"><a href="#8-4、回表的概念" class="headerlink" title="8.4、回表的概念"></a>8.4、回表的概念</h3><p>我们根据创建索引的字段会帮助我们生成一个B+树，我们创建这个B+树只能查找对应记录的主键值，没有办法找到数据库表中对应其他的数据。所以我们还要根据这个索引值，去主键索引也就是聚簇索引中去查找我们所需要的数据。我们称这种操作为回表。</p>
<p>为什么需要一次回表，为什么不把完整的用户记录放到二级索引上的叶子节点中？<br>如果把完整的用户记录放到叶子节点是可以不用回表，但是太占地方了，相当于每建立一颗B+树都需要把所有的用户记录再都拷贝一遍,这就优点太浪费存储空间了。</p>
<h2 id="8-5-索引的分类"><a href="#8-5-索引的分类" class="headerlink" title="8.5 索引的分类"></a>8.5 索引的分类</h2><p>从物理存储方式来划分:聚簇索引和非聚簇索引</p>
<p>从功能来划分:普通索引、主键索引、唯一索引</p>
<p>按照作用来进行划分:单值索引、复合索引、唯一索引</p>
<p>create index 索引名 on 表名(字段名)</p>
<p>Alter table 表明 add index 索引名 on(字段)</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">index</span> emp_name <span class="token keyword">on</span> emp<span class="token punctuation">(</span>ename<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">alter</span> <span class="token keyword">table</span> emp <span class="token keyword">add</span> <span class="token keyword">index</span> emp_salon<span class="token punctuation">(</span>sal<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>查看索引</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> 表明<span class="token punctuation">;</span>
</code></pre>
<p>删除索引:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">index</span> 表名<span class="token punctuation">;</span>
</code></pre>
<h3 id="8-6、哪些情况需要添加索引"><a href="#8-6、哪些情况需要添加索引" class="headerlink" title="8.6、哪些情况需要添加索引"></a>8.6、哪些情况需要添加索引</h3><p>1、数据量比较大的时候，更新不是很频繁的数据，为了提升查询效率需要添加索引。</p>
<p>2、主键会自动帮我们创建一个索引</p>
<p>3、频繁作为查询条件的字段可以添加索引，也就是where条件经常用到的字段添加索引。</p>
<p>4、需要进行排序的字段也可以添加索引。添加索引可以提高我们的排序速度。</p>
<p>5、where条件用不到的数据不需要创建索引。</p>
<p>6、查询统计或分组的字段可以创建索引。</p>
<p>7、update、delete的where条件列</p>
<p>8、使用比较频繁的字段需要放到联合索引的左侧。这样满足我们最佳左前缀原则。</p>
<p>9、使用distinct可以使用索引。</p>
<h3 id="8-7-哪些情况不需要创建索引"><a href="#8-7-哪些情况不需要创建索引" class="headerlink" title="8.7 哪些情况不需要创建索引"></a>8.7 哪些情况不需要创建索引</h3><p>1、数据量不大的情况。</p>
<p>2、频繁更新的字段，你就不要加索引了。</p>
<p>3、如果这个字段存在大量的重复值，也不需要创建索引，比如说性别字段。它只有男、女。</p>
<p>4、where使用不到的字段，不建议创建索引</p>
<p>5、不建议使用无序的字段来作为索引。</p>
<h3 id="8-8-什么是覆盖索引"><a href="#8-8-什么是覆盖索引" class="headerlink" title="8.8 什么是覆盖索引"></a>8.8 什么是覆盖索引</h3><p>就是select需要的数据列只使用索引中字段即可，不需要再进行一些回表操作。</p>
<p>也就是查询的列要被我们创建的索引覆盖。</p>
<p>一个索引包含了满足查询结果的数据就叫覆盖索引。</p>
<h3 id="8-9、索引失效的情况"><a href="#8-9、索引失效的情况" class="headerlink" title="8.9、索引失效的情况"></a>8.9、索引失效的情况</h3><p>1、使用一个计算的手段，可能会导致我们的索引失效。</p>
<p>2、使用or查询，但是只有一边有索引，也会导致索引失效</p>
<p>3、在查询时，使用一些函数，也会导致索引失效。</p>
<p>4、使用is null的时候，也会导致我们的索引失效。</p>
<p>5、就是在使用like的时候，第一位就是百分号</p>
<p>6、使用!&#x3D;、&lt;&gt;等也会导致后面的字段索引失效。</p>
<h3 id="8-1-0、建立索引等原则"><a href="#8-1-0、建立索引等原则" class="headerlink" title="8.1.0、建立索引等原则"></a>8.1.0、建立索引等原则</h3><p>1、遵循我们最左前缀原则，非常重要的原则，MYSQL会一直向右匹配直到遇到范围查询(&lt;、&gt;、between)就停止匹配，比如a&#x3D;1 and b&#x3D;2 c&gt;3 and b&#x3D;4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a，b，d的顺序可以任意调整。</p>
<p>2、&#x3D;和in可以乱序，比如a&#x3D;1 and b&#x3D;2 c&#x3D;3 ，建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
<p>3、尽量选择区分度高的列做为索引。区分度的公式count(distinct&#x2F;count(*))，表示字段不重复的比较，比例越大我们扫描的记录数越少，唯一键的区分度是1.</p>
<p>4、索引值不能参与计算，保持列干净。</p>
<p>5、尽量的扩展索引，不要新建索引。比如表中有a的索引，现在要加(a,b)索引，那么只需要修改原来的索引即可。</p>
<h2 id="9、MySQL的性能分析"><a href="#9、MySQL的性能分析" class="headerlink" title="9、MySQL的性能分析:"></a>9、MySQL的性能分析:</h2><p>mysql的常见瓶颈:<br>1、cpu饱和</p>
<p>2、io频繁</p>
<p>3、服务器硬件的性能瓶颈，可以使用top、free来查看系统的性能状态</p>
<p>explain关键字来分析sql性能:</p>
<p>explain:查看我们sql的执行计划，使用explain关键字可以模拟执行sql查询语句，从而得知mysql是如何处理的你的sql语句的。分析你的查询语句或是表结构的性能瓶颈。</p>
<p>怎么用explain+sql语句</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/63f4721f8036b925cc50cb63_hd.jpeg" alt="img"></p>
<p>id：select查询的表的顺序</p>
<ul>
<li>id相同，执行顺序就是从上而下</li>
<li>id不同，如果是子查询，id的序号会递增，id的值越大优先级越高，越先被执行</li>
</ul>
<p>select_type:查询的类型</p>
<ul>
<li>查询类型:普通查询、联合查询、自查询等组合的复杂复杂。</li>
<li>simple:简单的select查询</li>
<li>parimay:查询中包含若干复杂子部分</li>
<li>derived:使用的子查询</li>
<li>union:连表进行查询</li>
</ul>
<p>table:显示查询的数据是在哪一张表的</p>
<p>type:访问的类型，是检验SQL性能的指标:</p>
<ul>
<li>system:表中数据只有一行</li>
<li>const:常数，表示只通过一个索引就可以找到。const匹配比较多的是parimary key</li>
<li>eq_ref：唯一性索引扫描，对于每一个索引值，表中只有一条记录与之匹配。常用语主键或唯一索引扫描</li>
<li>ref:非唯一性索引扫描，返回匹配某个单独值的所有的行。</li>
<li>range：检索范围的行，使用的是索引来选择行。一般是between、&lt;、&gt;</li>
<li>index ：就是遍历了整个索引树。通过也比我们的all要快。index和all都是读全表，index是索引中去读，而我们的all是全表中去</li>
<li>all ：全表扫描</li>
</ul>
<p>Possiable_key：表示可能会用到的索引</p>
<p>Key:实际用到的索引</p>
<p>key_len：索引中的使用的字节数</p>
<p>rows:检查的行数</p>
<p>extra:用来说明一些额外的信息</p>
<p>当我们使用全表扫描来执行某个表的查询，并且该语句的where字句中有除了索引包含列之外的数据条件时，会报Using where</p>
<ul>
<li>当我们查询列表以及索引条件只包含某个索引的列，也就是使用覆盖索引的情况下.Using index</li>
<li>有些搜索条件中虽然出现了索引列，但却不能使用到索引。Using index condition 索引条件下推</li>
<li>在链接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫join buffer的内存块来加快查询速度。也就是基于块的嵌套循环算法。Using join buffer</li>
<li>Using filesort ：表示使用文件来进行排序。很多的情况下排序无法使用到索引，只能在内存中或者磁盘中进行排序。</li>
<li>usring temporary:表示建立临时表，这种情况下比较耗费程序的性能。</li>
</ul>
<p>扫描时索引的条件下推: 主要是用于减少我们回表操作。</p>
<ul>
<li>如果我们查询某一条数据，先去二级索引中去查，如果找到，那么就找到对应的主键值，找到以后，会进行一个回表操作，去拿到对应的值，但是这时加入了索引条件下推吗，所以需要先去判断我们的找到的二级索引对应的值是否存在，使用like去表中进行查询，查询到了，才会去进行回表操作，如果不到则不需要进行回表操作。</li>
</ul>
<h2 id="10、索引优化"><a href="#10、索引优化" class="headerlink" title="10、索引优化"></a>10、索引优化</h2><p>1、使用explain分析sql执行，发现type显示为all或者出现了extra里的Using filesort，那么就需要进行优化。</p>
<p>2、去创建索引，单表操作的话只需要建立where后的字段，范围字段可以先跳过。范围字段不要放在左边，遵守我们的最佳左前缀原则。</p>
<p>3、两张表的情况。使用的是left外连接的话，建立相反的索引，left的外连接的话，以左边表为主表。我们就可以建右边的条件为索引</p>
<p>4、多张表的话，使用的是嵌套查询的话，建小表的索引来驱动达标。包装join语句中被驱动表上join条件已经被索引。</p>
<h2 id="11、慢查询日志"><a href="#11、慢查询日志" class="headerlink" title="11、慢查询日志"></a>11、慢查询日志</h2><p>用来记录MYSQL中响应时间超过阈值的语句。具体指标运行时间超过log_query_time值的SQL。</p>
<p>慢查询日志分析工具:mysqldumpslow</p>
<p>查询慢查询日志功能是否开启:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%slow_query_log'</span><span class="token punctuation">;</span>
</code></pre>
<p>开启慢查询</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token keyword">global</span> slow_query_log<span class="token operator">=</span><span class="token keyword">on</span><span class="token punctuation">;</span>
</code></pre>
<p>查询慢查询日志的位置:</p>
<pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%slow_query_log%'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">---------------------+------------------------------------------------------+</span>
<span class="token operator">|</span> Variable_name       <span class="token operator">|</span> <span class="token keyword">Value</span>                                                <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">---------------------+------------------------------------------------------+</span>
<span class="token operator">|</span> slow_query_log      <span class="token operator">|</span> <span class="token keyword">OFF</span>                                                  <span class="token operator">|</span>
<span class="token operator">|</span> slow_query_log_file <span class="token operator">|</span> <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token keyword">local</span><span class="token operator">/</span>mysql<span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>kevintamdeMacBook<span class="token operator">-</span>Pro<span class="token operator">-</span>slow<span class="token punctuation">.</span>log <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">---------------------+------------------------------------------------------+</span>
<span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre>
<p>修改long_query_time阈值:</p>
<pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%long_query_time%'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">-----------------+-----------+</span>
<span class="token operator">|</span> Variable_name   <span class="token operator">|</span> <span class="token keyword">Value</span>     <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">-----------------+-----------+</span>
<span class="token operator">|</span> long_query_time <span class="token operator">|</span> <span class="token number">10.000000</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">-----------------+-----------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre>
<p>查询当前系统中有多少条慢查询记录:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token keyword">global</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">'%slow_queries%'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+-------+</span>
<span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+-------+</span>
<span class="token operator">|</span> Slow_queries  <span class="token operator">|</span> <span class="token number">0</span>     <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">---------------+-------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre>
<h2 id="12、关联查询优化"><a href="#12、关联查询优化" class="headerlink" title="12、关联查询优化"></a>12、关联查询优化</h2><p>1、左外连接</p>
<p>左外连接的优化在于，左边的表会做主表,所以需要给右边的表做索引来进行优化。</p>
<p>左边的叫驱动表，右边表叫被驱动表。</p>
<p>2、内连接</p>
<p>采用inner join的话，MySQL的存储引擎会自动帮我们选择驱动表。</p>
<p>对于内连接来说，在两个表的连接条件都存在索引的情况下,会选择小表作为驱动表。<font color="red">‘小表驱动大表’</font></p>
<p>JOIN语句的原理:</p>
<p>本质就是各个表之间数据的循环匹配。</p>
<p>在mysql5.5版本之前，只支持一种表间关联方式，就是嵌套循环(Nested Loop Join)。如果关联表的数据量很大，则join关联的执行时间会非常长。在MySQL5.5以后的版本中，MySQL通过引入BNLJ算法来优化嵌套执行。</p>
<blockquote>
<p>扩展:JOIN实现的算法</p>
<p>Nested Loop Join：简单嵌套循环算法</p>
<p>算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到Result，以此类推，驱动表A中的每一条记录与驱动表B的数据进行判断。</p>
<p>可以看出这种方式效率非常低的，以上述表A数据100表，表B数据10000条数据，则A*B&#x3D;100万次。开销统计如下：</p>
<p>读取记录数：A+B*A</p>
<p>Join比较次数:B*A</p>
<p>当然mysql的肯定不会采用这种算法取执行，所以出现了两种优化算法。</p>
<p>索引嵌套循环连接、Block Nested Loop Join 块循环嵌套循环连接</p>
<p>Index Nested-Loop Join其优化的思路主要减少内层表数据的匹配次数。所以要求驱动表上必须有索引才行。</p>
<p>通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录取进行比较，这样极大的减少了对内层表的匹配次数。</p>
<p>如果驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还得进行一次回表查询。相比，被驱动表的索引是主键索引，效率会更高。</p>
<p>Block Nested-Loop Join 块嵌套循环连接</p>
<p>如果存在索引，那么直接使用索引嵌套连接即可，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把驱动表的记录加载到内存匹配，这样周而复始，大大增加了io次数。为了减少被驱动表的io次数，就出现了Block Nested-Loop Join方式。</p>
<p>不再是逐条获取驱动表的数据，而是一块一块的获取，映入了join buffer缓存区，将驱动表join相关的部分数据列缓存到join buffer中，然后全表扫描被驱动表，被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配,将简单嵌套循环中的多次比较合并一次，降低了被驱动表的访问频率。</p>
<p>⚠️注意</p>
<p>这里join buffer不只是缓存关联表的列，select后面的列也会缓存起来。尽量减少不必要的字段。</p>
<p>HASH JOIN：</p>
<p>从mysql8.0版本开始废弃了BNLJ，因为从8.0开始加入了Hash Join，默认会使用Hash Join</p>
<p>Hash Join是做大数据集连接时的常用方式,优化器会使用两个表中较小(相对较小)的表利用Join key再内存中建立散列表，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。</p>
<ul>
<li>这种方式适合于较小的表完全可以放入内存中的情况，这样总成本就是访问两张表的成本之和。</li>
<li>在表很大的情况下并不能完全放入内存，这时优化器会将它分割成若干不同的分区，不能放入内存的部分就把该分区放入磁盘的临时段，此时要求较大的临时段从而尽量提高IO的性能。</li>
<li>它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它时Join的重型升降机。Hash Join只能应用于等值连接(如where a.xx&#x3D;bxxx)，这时由hash的特点决定的</li>
</ul>
</blockquote>
<p>Join小结:</p>
<p>1、整体效率比较:LNLJ&gt;BNLJ&gt;SNLJ</p>
<p>2、永远用小结果集驱动大结果集(其本质就是减少外层循环的数据数量)(小的度量单位指的是表行数*每行大小)</p>
<p>3、为被驱动表匹配的条件增加索引(减少内层表的循环匹配次数)</p>
<p>4、增大Join Buffer size的大小</p>
<h2 id="13、排序优化"><a href="#13、排序优化" class="headerlink" title="13、排序优化"></a>13、排序优化</h2><p>问题：在where条件字段上加索引，但是为什么在order by 字段上还要加索引呢?</p>
<p>回答：</p>
<p>在mysql中，支持两种排序方式,分别是FileSort和index排序</p>
<ul>
<li>index排序中，索引可以保证数据的有序性,不需要再进行排序，效率更高</li>
<li>FileSort排序则一般在内存中进行排序，占用cpu较多。如果待排结果较大，会产生临时文件i&#x2F;o到磁盘进行排序的情况，效率较低。</li>
</ul>
<p>排序优化</p>
<p>1、sql中，可以在where子句和order by子句中使用索引，目的是在where子句中避免全表扫描，在order by 子句避免使用FileSort排序。当然，某些情况下全表扫描，或者FileSort排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。</p>
<p>2、尽量使用index完成order by 排序。如果where和order by 后面是相同的列就使用单索引列，如果不是就使用复合索引。</p>
<p>3、无法使用Index时，需要对FileSort方式进行调优。</p>
<p>排序和分组索引情况:</p>
<p>1、order by时不limit，有可能会导致索引失效。</p>
<p>2、order by时顺序错误，索引失效。</p>
<p>3、order by时规则不一致，索引失效</p>
<p>4、无过滤，不索引</p>
<p>总结:</p>
<ul>
<li>遵守最左前缀原则</li>
<li>如果where使用索引的最左前缀定义为常量，则order by能使用索引。</li>
<li>不能使用索引进行排序</li>
</ul>
<blockquote>
<p>FileSort算法:</p>
<p>双路排序:</p>
<p>mysql在4.1之前使用是双路排序，字面意思就是两次扫描磁盘，最终得到数据，读取行指针和 order by 列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出.</p>
<p>单路算法:<br>从磁盘读取查询需要的 所有列 ，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空 间， 因为它把每一行都保存在内存中了。</p>
</blockquote>
<p>**优化策略<br>** 1. <strong>尝试提高</strong> sort_buffer_size</p>
<ul>
<li>不管使用哪种算法，提高这个参数都会提高效率，要根据系统的能力去提高，因为这个参数是针对每个进程的1m-8m之间调整。</li>
</ul>
<pre class=" language-mysql"><code class="language-mysql">show variables like '%sort_buffer_size%';
</code></pre>
<ol start="2">
<li><strong>尝试提高</strong> max_length_for_sort_data</li>
</ol>
<ul>
<li>提高这个算法，会增加用改进算法的概念</li>
</ul>
<ol start="3">
<li>Order by <strong>时</strong>select * <strong>是一个大忌。最好只</strong>Query<strong>需要的字段。</strong></li>
</ol>
<h2 id="14、MySQL中主键的设计"><a href="#14、MySQL中主键的设计" class="headerlink" title="14、MySQL中主键的设计"></a>14、MySQL中主键的设计</h2><p>建议使用bigint做主键。</p>
<p>1、自增id的问题。</p>
<p>​      自增ID做主键，简单易懂，几乎所有数据库都支持自增类型，只是实现上各自所不同而已。自增ID除了键的，其他都是缺点。</p>
<pre><code>  - 可靠性不高，存在自增id回溯的问题。
        - 安全性不高，对外暴露接口的可以非常容器猜测对应的信息
        -  局部唯一性: 自增id时局部唯一，没有办法保证全局唯一，也就是说在分布式的系统中，这会出现问题。
</code></pre>
<p>所以，建议尽量不要用跟业务有关的字段做主键。毕竟，作为项目设计的技术人员，我们谁也无法预测在项目的整个生命周期中，哪个业务字段会因为项目的业务需求而有重复，或者重用之类的情况出现。</p>
<p>2、主键的设计</p>
<p>1、主键设计至少应该是全局唯一且是单调递增</p>
<p>2、可以采用雪花算法:全局唯一性、不会出现有重复的ID标识 第一位是符号位、第二位到42是时间戳加10比特到时间机器、最后加上12位到序列号。</p>
<p>怎么设计数据库</p>
<p>我们在设计数据表的时候，要考虑很多问题。比如:<br>   1、用户都需要什么数据?需要在数据表中保存哪些数据？<br>   2、如何保证数据表中数据的正确性<br>   3、如何降低数据表的数据冗余度。<br>   4、如果让负责数据库维护的人员更方便地使用数据库?</p>
<h2 id="15、范式"><a href="#15、范式" class="headerlink" title="15、范式"></a>15、范式</h2><p>从低到高分别是: 第一范式(1NF)、第二范式 (2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)和第五范式(5NF，又称完美 范式) </p>
<p>键相关属性的概念:<br>     1、超键:能唯一标识元组的属性集叫做超键<br>     2、 候选键：如果超键不包括多余的属性，那么这个超键就是候选键<br>     3、 主键：用户可以从候选键中选择一个作为主键<br>     4、  外键:如果数据库表中某个属性不是表的主键，而不是另一个表的主键，那么这个属性就是外键<br>     5、 主属性:包含在任何一候选键中的属性称为主属性<br>     6、  非主属性: 与主属性相对，指的是不包含在任何一个候选键中的属性。<br> 举例:</p>
<p>这里有两个表<br>球员表(player) :球员编号 | 姓名 | 身份证号 | 年龄 |<br>球队编号 球队表(team) :球队编号 | 主教练 | 球队所在地<br>超键 :对于球员表来说，超键就是包括球员编号或者身份证号的任意组合，比如(球员编号) (球员编号，姓名)(身份证号，年龄)等。<br>候选键 :就是最小的超键，对于球员表来说，候选键就是(球员编号)或者(身份证号)。<br>主键 :我们自己选定，也就是从候选键中选择一个，比如(球员编号)。<br>外键 :球员表中的球队编号。<br>主属性 、 非主属性 :在球员表中，主属性是(球员编号)(身份证号)，其他的属性(姓名)(年龄)(球队编号)都是非主属性。</p>
<p>第一范式:主要确保数据表中每个字段的值必须具有原子性，也就是说数据表中每个字段的值都是不可拆分的。</p>
<p>第二范式:在满足第一范式的基础上，要满足数据表里的每一条数据记录，都是可唯一标识的。而且所有非主键字段，都必须完全依赖主键。</p>
<p>第三范式:在满足第二范式的基础上，确保数据表中的每一个非主键字段都于主键字段直接相关，也就是说，要求数据表中的所有非主键字段不能依赖与其他非主键字段。该规则的意思是所有非主键属性之间不能有依赖关系，必须相互独立。</p>
<p>反范式化<br>有的时候不能简单按照规范要求设计数据表，因为有的数据看似冗余，其实对业务来说十分重要。这个时候，我们就要遵守业务优先的原则，首先满足业务需求，再尽量减少冗余。</p>
<h2 id="16、事务-重要🌟🌟🌟🌟🌟"><a href="#16、事务-重要🌟🌟🌟🌟🌟" class="headerlink" title="16、事务(重要🌟🌟🌟🌟🌟)"></a>16、事务(重要🌟🌟🌟🌟🌟)</h2><h3 id="16-1-什么是事务"><a href="#16-1-什么是事务" class="headerlink" title="16.1 什么是事务"></a>16.1 什么是事务</h3><p>事务就是一组逻辑操作单元。是数据从一种状态转换成另一种状态。</p>
<p>事务处理的原则:保证所有的事物都作为一个工作单元来执行，即使出现故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交，那么这些修改会被永久保存下来了，要么数据库系统放弃所作的所有的修改，整个事务回滚到最初状态</p>
<h3 id="16-2-事务的特性ACID"><a href="#16-2-事务的特性ACID" class="headerlink" title="16.2 事务的特性ACID"></a>16.2 事务的特性ACID</h3><p>原子性:原子性是指事务一个不可分割工作单元，要么全部提交，要么全部提交失败回滚。</p>
<p>一致性:是指事务的执行前后，数据从一个合法性状态变为另一个合法性状态。这种合法性指的是语义上的而不是语法上的，根据具体的业务相关。比如说,A余额100转账10给我们的B，那么余额变成了90，B加了10，这就是一致性的，如果不是90，那么就没有遵守一致性。</p>
<p>隔离性：事务的隔离性是指一个事务的执行，即一个事务内部的操作及使用的数据对并发其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
<p>持久性:一个事务一旦被提交，它对数据库中的数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
<p>持久性是通过事务日志来保证的。日志包括了重做日志和回滚日志。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后在对数据库中对应的行进行修改，这样做的好处就是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统的重做日志，重新执行，从而是事务具有持久性。</p>
<h3 id="16-3-事务的状态"><a href="#16-3-事务的状态" class="headerlink" title="16.3 事务的状态"></a>16.3 事务的状态</h3><p>1、活动的 表示事务正在执行过程中</p>
<p>2、部分提交的： 当事务中的最后一个操作执行完成，但由于操作都在内存中完成，所造成的影响并没有刷新到磁盘时，我们就说该事务处在部分提交的状态。</p>
<p>3、失败的:当事务处在活动或者部分提交时，可能遇到某些错误，导致无法进行，我们就说该事务处在失败的状态。</p>
<p>4、终止:如果事务执行了一部分而变为失败的状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。这个过程我们称之为回滚。</p>
<p>5、提交的:当一个处在部分提交的状态的事务将修改过的数据都同步到磁盘上之后，我们就可以说该事务处在了提交的状态。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/63f5e76da8b6df92e394c08b_hd-20230413231245497.jpeg" alt="img"></p>
<h3 id="16-4-如何使用事务"><a href="#16-4-如何使用事务" class="headerlink" title="16.4 如何使用事务"></a>16.4 如何使用事务</h3><p>1、显示事务:就是使用命令开启事务 begin、start transaction</p>
<p>区别:start transaction 后面可以携带参数比如说Read only标识是一个只读的事务。</p>
<p>read wirte标识当前事务是一个读写事务。默认是读写的事务。</p>
<p>roback进行回滚、commit进行提交。</p>
<p>savepoint：还可以创建保存点。回滚到指定的保存点。</p>
<p>2、隐藏事务:是我们的系统变量aotocommit</p>
<h3 id="16-5-、事务数据并发的问题"><a href="#16-5-、事务数据并发的问题" class="headerlink" title="16.5 、事务数据并发的问题"></a>16.5 、事务数据并发的问题</h3><p> 1、脏写:对于两个事务sessionA、sessionB，如果事务sessionA修改了另一个未提交事务B的数据，那几意味着发生了脏写。</p>
<p>2、脏读:对于两个事务，事务A可以读到事务B未提交的数据，我们称发生了脏读现象。</p>
<p>3、不可重复读:指的两个事务A、事务B，事务A读到的一个数据，然后事务B取修改这个数据，然后事务又去读取了这个数据，但是前后的结果是不一致的，我们称这种行为为不可重负读。</p>
<p>4、幻读:对于事务A、事务B，事务A从事务B中读取了一个数据，然后事务B在该表插入了一个新的行，之后，事务A再去读取同一个表，就会多出几行，那么就意味着发生了幻读。select某记录是否存在，不存在，准备插入，但执行insert操作时发现此记录已存在，无法插入，此时就发生了幻读。</p>
<h3 id="16-6、MySQL的四种隔离级别"><a href="#16-6、MySQL的四种隔离级别" class="headerlink" title="16.6、MySQL的四种隔离级别"></a>16.6、MySQL的四种隔离级别</h3><p>1、读未提交:所有的事务都能读到其他没有提交的事务的数据。不能避免脏读、不可重复读、幻读</p>
<p>2、读已提交:事务可以读到以后提交的事务的数据。可以避免脏读现象，但是无法出现不可重复读和幻读。</p>
<p>3、可重复读：事务A读到一条数据之后，事务B去修改了该数据，但我们读事务A再次去读取数据，读到还是原来的内容。可以避免脏读、不可重复读。会出现幻读。</p>
<p>4、序列化:串行化。让所有的事务都排队执行。不会出现如何问题。但是会严重影响数据库的性能。</p>
<h3 id="16-7-MySQL的事务日志"><a href="#16-7-MySQL的事务日志" class="headerlink" title="16.7 MySQL的事务日志"></a>16.7 MySQL的事务日志</h3><p>1、事务的隔离级别是使用锁机制来进行实现。</p>
<p>事务的原子性、一致性和持久性由事务的redo日志和undo日志来实现的。</p>
<p>2、Redo log称为重做日志，提供在写入操作，提交事务修改的页操作，用来保证事务的持久性。</p>
<p>3、Undo log称为回滚日志，回滚日志记录某个特性版本，用来保证事务的原子性、一致性。</p>
<p>Redo和Undo都可以视为一种恢复操作:</p>
<p>Redo log：存储引擎层生成的日志，记录的是物理级别上的页修改操作，比如页号xxx、偏移量写入了zz数据。主要为了保证数据的可靠性。</p>
<p>Undo log:是存储引擎层生成的日志，记录的是逻辑操作日志，比如说某一行数据进行insert操作，那么undo log日志就会写入一个delete操作。主要用于事务的回滚操作和事务的一致性非锁定读。</p>
<h4 id="redo-log-和undo-log的详情"><a href="#redo-log-和undo-log的详情" class="headerlink" title="redo log 和undo log的详情"></a>redo log 和undo log的详情</h4><p>innodb存储引擎是以页为单位来管理存储空间的。在真正访问页面之前，需要把在磁盘上的页缓存到内存中的Buffer pool之后才可以访问。所有的变更都必须先更新缓存池中的数据，然后缓存池中的脏页会以一定频率被刷入磁盘。通过缓存池来优化cpu和磁盘之间的鸿沟，这样就可以保证整体的性能不会下降太多。</p>
<p>为什么需要redo log日志:</p>
<p>一方面，缓存池可以帮助我们消除cpu和磁盘之间的鸿沟，checkpoint机制可以保证数据的最终落盘，然后由于checkpoint并不是每次变更的时候就触发，而是master线程隔离一段时间去处理的。所以最坏的情况就是事务提交后，刚写完缓存池，数据库宕机了，那么这段数据就是丢失，无法恢复。</p>
<p>Innodb引擎的事务采用了WAL技术,这种技术的思想就是先写缓存，再写磁盘，只有日志写入成功，才算事务提交成功，这里的日志就是redo log。当发生宕机且数据未刷到磁盘的时候，可以通过redo log来恢复，保证ACID的D，这就是redo log的作用。</p>
<p>特点:</p>
<p>1、Redo 日志是顺序写入磁盘的</p>
<p>在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序io，效率比随机io块。</p>
<p>2、事务执行过程中，redo log不断记录。</p>
<p>redo log跟bin log的区别，redo log是存储层产生.而bin log是数据库层产生的。假设一个事务，对表做10万行的记录插入，在这个过程中，一直不断的往redo log顺序记录，而bin log不会记录，直到这个事务提交，才会一次写入到bin log文件中。</p>
<p>redo 日志的组成:</p>
<p>1、重做日志的缓存，保存在内存中，是易失的。</p>
<p>2、重做日志文件,保存在硬盘中，是持久的。</p>
<p>redo的整体流程:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/63f5fe3da8b6df92e39714ef_hd.jpeg" alt="img"></p>
<p>1、先将原始数据从磁盘中读如内存中来，修改数据的内存拷贝</p>
<p>2、生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</p>
<p>3、当事务commit时，将redo log buffer中的内容刷新到redo log file，对redo log file采用追加写的方式</p>
<p>4、定期将内存中修改的数据刷新到磁盘中</p>
<p>Redo log的刷盘策略:</p>
<p>Redo log的写入并不是直接写入磁盘的，innodb引擎会在写redo log的时候先写redo log buffer，之后会一定的频率刷入到真正的redo log file中。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/63f5ffa4fc2e629cb4098549_hd.jpeg" alt="img"></p>
<p>注意: redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到文件系统缓存中去，真正的写入会交给系统自己来决定。</p>
<p>那么对于innodb来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也就丢失了。</p>
<p>针对这种情况,Innodb给出了三种策略:</p>
<p>1、表示每次事务提交时不进行刷盘操作。让系统去进行，每隔1s进行一次重做日志的同步。</p>
<p>2、表示每次事务提交时都将进行同步，刷盘操作。</p>
<p>3、表示每次事务提交时都只把redo log buffer内容写入文件缓存，不进行同步。由系统自己决定什么时候同步到磁盘文件。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/63f6015efc2e629cb409fafe_hd.jpeg" alt="img"></p>
<p>Undo log日志:</p>
<p>redo log是事务持久性的保证，undo log是事务原子性的保证。在事务中更新数据的前置操作其实是要写入一个undo log。</p>
<p>如何理解Undo log日志:</p>
<p>事务需要保证原子性，也就是事务中的操作要么全部完成，要么什么也不做，但有时候事务执行到一半会出现一些情况，比如:</p>
<ul>
<li><p>情况一:事务执行过程中可能遇到各种错误，比如服务器本身的错误，操作系统错误等</p>
</li>
<li><p>情况二:程序员可以在事务执行过程中手动输入rollback语句结束当前事务的执行。</p>
</li>
</ul>
<p>以上情况的产生出现，数据库会将数据进行回滚，回到原来的数据。这样就造成了一个假象，这个事务看起来什么都没做，所以符合原子性要求。</p>
<p>你插入一条记录时，至少要把这条记录的主键值记下来，之后回滚的时候只需要把这个主键值对应的记录删掉就好了。</p>
<p>你删除一条记录，至少要把这条记录中内容都记下来，这样之后回滚时再把这些内容组成的记录插入到表中就好了。</p>
<p>你修改了一条记录，至少要把修改这条记录前到旧值都记录下来，这样之后回滚时再把这条记录更新为旧值就好了。</p>
<p>mysql把这些为了回滚而记录的这些内容称之为撤销日志或者回滚日子.注意，由于查询操作并不会修改任何用户记录，所以在查询操作执行时，并不需要记录相应的undo日志。</p>
<p>此外，undo log会产生redo log,也就是undo log的产生会伴随着redo log的产生，这是因为undo log也需要持久性的保护。</p>
<p>Undo的作用:</p>
<p>1、回滚数据</p>
<p>用户对undo日志可能有误解:undo用于将数据库物理地恢复到执行语句或事务之前的样子。但事务并非如此。undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑取消了，但是数据结构本身在回滚之后可能大不相同。</p>
<p>2、MVCC多版本并发控制。</p>
<h2 id="17、MySQL中的锁"><a href="#17、MySQL中的锁" class="headerlink" title="17、MySQL中的锁"></a>17、MySQL中的锁</h2><p>事务的隔离性是由锁来进行实现的。</p>
<p>为什么需要使用锁:数据也是共享资源，会被许多用户共享的资源。为了保证数据的一致性，需要对并发操作进行控制，因此产生了锁。</p>
<p>MySQL并发事务访问相同记录划分为3种:</p>
<p>1、读-读情况</p>
<p>读-读情况，即并发事务相继读取相同的记录。读取操作本身不会对记录有任何影响，并不会引起什么问题，所以允许这种情况的发生。</p>
<p>2、写-写情况</p>
<p>写-写情况，即并发事务相继对相同的记录做出改动。会发生脏写问题，任何一种隔离级别都不允许这种问题的发生。所以在多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过锁来实现的。这个所谓的锁其实是一个内存中的结构，在事务执行前本来是没有锁的，也就是说一开始是没有锁结构和记录关联的。</p>
<p>当一个事务对一条结构，做出改变的时候，首先会看看内存中有没有与这条记录关联的锁结构，当没有的时候就会在内存中生成一个锁结构与之关联。比如，事务t1要对这条记录做改动，就需要生成一个锁记录与之关联。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/63f6de1da8b6df92e3a47004_hd.jpeg" alt="img"></p>
<p>在锁结构中有两个比较重要的信息:</p>
<p>1、trx信息:代表这个锁结构和那个事务进行关联</p>
<p>2、is_waiting:代表当前事务是否在等待。</p>
<p>当事务T1改动了这条记录后，就生成了一个锁记录与该记录关联，因为之前没有别的事务为这条记录加锁，所以is_waiting属性就为false，我们把这个场景就称之为获取锁成功，或者加锁成功，然后就可以继续操作了。</p>
<p>当事务T1提交之前，另一个事务T2也想对该记录进行修改，然后获取内存中看是否有一个锁记录与这条记录进行关联，如果有一个锁结构与之关联，那么就会创建一个锁记录，与这条记录想关联。不过里面is_wating该为true。表示需要进行等待。我们称这种场景为获取锁失败</p>
<p>3、读-写情况</p>
<p>读-写情况，即一个事务在读取，一个事务在写入。这种情况下会发生脏读、不可重负读、幻读的问题。mysql采用了mvvc来解决了幻读读问题。</p>
<h3 id="17-1、并发问题解决方案"><a href="#17-1、并发问题解决方案" class="headerlink" title="17.1、并发问题解决方案"></a>17.1、并发问题解决方案</h3><p>怎么解决脏读、不可重复读、幻读这些问题呢？其实有两种可选读解决方案。</p>
<p>方案一:</p>
<p>读操作利用多版本并发控制(mvcc),写操作进行加锁。</p>
<p>所谓的MVCC，就是生成一个ReadView，通过ReadView找到所有符合条件的记录版本(历史版本由undo日志构建)。查询语句只能读到在生成ReadView之前已经提交事务所做的更改，在生成ReadVIew之前未提交的事务或者之后才开启的事务所做的更改是看不到。而写操作肯定针对的是最新版本的记录，读操作的历史版本和改动记录的最新版本并不冲突，也就是采用MVCC时，读写操作并不冲突。</p>
<p>方案二:读写操作都采用加锁的方式。</p>
<h3 id="17-2、MySQL中的不同角度的锁"><a href="#17-2、MySQL中的不同角度的锁" class="headerlink" title="17.2、MySQL中的不同角度的锁"></a>17.2、MySQL中的不同角度的锁</h3><p>对锁的操作划分为:读锁、写锁</p>
<p>锁的粒度角度划分为:表级锁(表级别的读锁和写锁、意向锁、自增锁、MDL锁)、行级锁:(record locks、gap locks、next-key locks、插入意向锁)、页级锁</p>
<p>对带锁的态度划分为:悲观锁、乐观锁</p>
<p>对加锁方式:隐式锁、显示锁</p>
<p>其他:死锁、全局锁</p>
<p>MYSQL从数据操作划分为读锁、写锁:</p>
<ul>
<li>读锁:针对同一份数据，多个事务的读操作可以同时进行，不会互相影响，相互不阻塞。</li>
<li>写锁，针对同一份数据，多个事务的写操作不可以同时进行的，会互相影响，相互阻塞。当前事务没有对该做完操作之前，其他的事务想要修改该记录的，会被阻塞住的。这样就可以保证同一时间只有一个事务对该数据进行修改，可以解决并发出现的问题。</li>
</ul>
<p>MySQL的语法:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share mode</span><span class="token punctuation">;</span>读锁
<span class="token number">8.0</span>
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> share<span class="token punctuation">;</span>
写锁
<span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
</code></pre>
<p>在5.7版本之前，去尝试获取锁，如果没有获取到锁，会一直阻塞，直到超过。在8.0的版本添加了NoWait、skip locked语法，跳过等待时间、或者跳过锁定。</p>
<p>写操作:</p>
<p>mysql中的写操作无非是insert、delete、update。</p>
<p>​     delete:对一条数据进行删除操作的过程其实就是先在B+tree树中定位到这条记录的位置，然后获取这条记录的写锁，在执行delete操作。我们也可以把这个定位带删除记录在B+树中的位置的过程看做是一个获取x锁的锁定读。</p>
<p>​    update:在一条记录做update操作时分为三种情况：</p>
<p>​        情况1:未修改该记录的键值，并且被更新的列占用的存储空间在修改前后未发生变化。则先在B+树中定位到这条记录的位置，然后再获取一下记录的X锁，最后在原记录的位置进行修改操作。我们也可以把这个定位待修改记录在B+树中位置的工程看成是一个获取X锁的锁定读</p>
<p>​        情况2:未修改该记录的键值，并且至少有一个被更新的列占用的存储空间在修改前后发生变化。则先在B+树中定位到这条记录的位置，然后获取一下记录的X锁，将该记录彻底删除掉，最后再插入一条新记录。这个定位待修改记录在B+树中位置的过程看成一个获取X锁的锁定读，新插入的记录由INSERT操作提供的隐式锁进行保护。</p>
<p>​        情况3:修改了该记录的键值，则相当于在原记录上做delete操作之后再来一次INSERT操作，加锁操作就需要按照delete和insert的规则进行了</p>
<p>​    insert:一般情况下,新插入一条记录的操作并不加锁，通过一致称之为隐式锁的结构来保护这条新插入的记录在本事务提交前不被别的事务访问。</p>
<h3 id="17-3-从数据操作的粒度划分-表记锁、页级锁、行锁"><a href="#17-3-从数据操作的粒度划分-表记锁、页级锁、行锁" class="headerlink" title="17.3 从数据操作的粒度划分:表记锁、页级锁、行锁"></a>17.3 从数据操作的粒度划分:表记锁、页级锁、行锁</h3><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次锁定当前操作的数据方案会得到最大的并发度，但是管理锁是很耗费资源的事情。因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了锁粒度的概念。</p>
<h4 id="1、表锁-Table-Lock"><a href="#1、表锁-Table-Lock" class="headerlink" title="1、表锁(Table Lock)"></a>1、<strong>表锁(<strong>Table Lock</strong>)</strong></h4><p>该锁会锁定整张表，它是MySQL中最基本的锁策略，并不依赖于存储引擎,并且表锁是开销最小的策略。由于表级锁一次会将整个表锁定，所以可以很好的避免死锁问题。当然，锁的粒度大所带来最大的负面影响就是出现锁资源争用的概率也会最高，导致并发率大打折扣。</p>
<h4 id="1⃣️-表级别的S锁、X锁"><a href="#1⃣️-表级别的S锁、X锁" class="headerlink" title="1⃣️ 表级别的S锁、X锁"></a>1⃣️ 表级别的S锁、X锁</h4><p>在对某个表执行select、insert、delete、update语句时，Innodb存储引擎是不会为这个表添加表级别的读锁或者写锁的。在对某个表执行一些诸如alter table、drop table这类的DDL语句时，其他事务对这个表并发执行诸如SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞。同理，某个事务中对某个表执行SELECT、INSERT、DELETE、UPDATE语句时，在其他会话中对这个表执行 DDL 语句也会 发生阻塞。这个过程其实是通过在 server层 使用一种称之为 元数据锁 (英文名: Metadata Locks ， 简称 MDL )结构来实现的。</p>
<p>一般情况下，不会使用InnoDB存储引擎提供的表级别的 S锁 和 X锁 。只会在一些特殊情况下，比方说崩溃恢复过程中用到。比如，在系统变量 autocommit&#x3D;0，innodb_table_locks &#x3D; 1 时， 手动获取 InnoDB存储引擎提供的表t 的 S锁 或者 X锁 可以这么写:</p>
<ul>
<li>lock tables t read:Innodb存储会对表t加表级别的S锁</li>
<li>lock tables t write：innodb存储引擎会对表t加表级别的X锁。</li>
</ul>
<p>不过尽量避免使用innodb存储引擎的表上使用lock tables这样的手动锁表语句，它们并不会提供什么额外的保护，只是会降低并发能力而已。Innodb的厉害之处还是实现了更细粒度的行锁，关于innodb的表级锁了解即可。</p>
<p>语法举例:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">#查看表上加过的锁</span>
<span class="token keyword">show</span> <span class="token keyword">open</span> <span class="token keyword">tables</span><span class="token punctuation">;</span>
<span class="token keyword">show</span> <span class="token keyword">open</span> <span class="token keyword">tables</span> <span class="token keyword">where</span> In_use<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">#加读锁</span>
<span class="token keyword">lock</span> <span class="token keyword">tables</span> t <span class="token keyword">read</span><span class="token punctuation">;</span>  
<span class="token keyword">lock</span> <span class="token keyword">tables</span> table_name <span class="token keyword">read</span><span class="token punctuation">;</span>
<span class="token keyword">lock</span> <span class="token keyword">tables</span> t <span class="token keyword">write</span><span class="token punctuation">;</span> 
<span class="token keyword">lock</span> <span class="token keyword">tables</span> table_name <span class="token keyword">write</span><span class="token punctuation">;</span>
</code></pre>
<p>MySQL的表级锁有两种模式:(以MyISAM表进行操作的演示)</p>
<ul>
<li>表共享读锁(Table Read Lock)</li>
<li>表独占写锁(Table Write Lock)</li>
</ul>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220811001557809.png" alt="image-20220811001557809"></p>
<p>2⃣️ 意向锁</p>
<p>Innodb支持多粒度锁,它允许行级锁与表级锁共存。而意向锁就是其中的一种表锁。</p>
<p>1、意向锁的存在是为了协调行锁和表锁的关系，支持多粒度锁的并存。</p>
<p>2、意向锁是一种不与行级锁冲突表级锁，这一点非常重要</p>
<p>3、表明”某个事务正在某些行持有了锁或该事务准备去持有锁”</p>
<p>即:意向锁是由存储引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，Innodb会先获取该数据行所在数据表的对应意向锁。</p>
<p>意向锁分为两种:</p>
<ul>
<li>意向共享锁:事务有意向对表中的某些行加共享锁(s锁)</li>
<li>意向排它锁:事务有意向对表中的某些行加排它锁(x锁)</li>
</ul>
<p>意向锁来解决的问题:</p>
<p>​    现在有两个事务，分别是t1和t2，其中t2视图在该表级别上应用共享锁和排它锁，如果没有意向锁的存在，那么t2需要去检查内存中的页和行是否存在锁，如果存在意向锁，那么此时就会受到t1控制的表级别意向锁的阻塞。T2在锁定该表前不必检查各个页或行锁，而只需要检查表上的意向锁。简单来说就是给更大一级别的空间示意里面是否已经上过锁。</p>
<p>​    在数据表的场景中，如果我们给某一行数据加上排它锁，数据库会自动给更大一级大空间，比如数据页或数据表加上意向锁，告诉其他人这个数据或数据表已经有人上过排它锁。这样其他事物在来获取表的锁的时候，只需要去看它的更高一级是否存在意向锁即可。</p>
<p>​    如果事务想要获取数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。</p>
<p>​    如果事务想要获取数据表中某些记录的排它锁，就需要在数据表上添加意向排它锁。</p>
<p>意向锁不会与行级的共享 &#x2F; 排他锁互斥!正因为如此，意向锁并不会影响到多个事务对不同数据行加排他锁时的并发性。</p>
<h4 id="5⃣️自增锁"><a href="#5⃣️自增锁" class="headerlink" title="5⃣️自增锁"></a>5⃣️自增锁</h4><p>在使用MySQL过程中，我们可以为表的某个列添加AUTO_increment属性,mysql会自动加上一个自增锁.</p>
<p>因为我们的自增锁也是一种表锁。</p>
<h4 id="6⃣️-元数据锁-MDL锁"><a href="#6⃣️-元数据锁-MDL锁" class="headerlink" title="6⃣️ 元数据锁(MDL锁)"></a>6⃣️ 元数据锁(MDL锁)</h4><p>MySQL引入了mate date lock，简称MDL锁，属于表锁范畴。MDL的作用是:保证读写的正确性,如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构作变更。增加了一列，那么查询线程拿到的结果更表结果对不上，肯定是不行的。因此，当对一个表进行增删改查的操作的时候，加mdl锁，当要对表结果做变更操作的时候加上MDL写锁。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁是互斥的，用来保证变更表结构操作的安全性，解决了DML和DDL操作之间的一致性问题。不需要显式使用，在访问一个表的时候会被自动加上。</p>
<h4 id="7⃣️记录锁"><a href="#7⃣️记录锁" class="headerlink" title="7⃣️记录锁"></a>7⃣️记录锁</h4><p>行锁也称为记录锁，股明思议，就是锁住某一行，需要注意的是,MySQL服务器层并没有实现行锁机制，行级锁只在存储引擎层。</p>
<p>​    优点:锁定粒度小，发生锁冲突概率低，可以实现的并发度高。</p>
<p>​    缺点:对于锁的开销比较大，加锁会比较慢，容易出现死锁情况。</p>
<p>InnoDB与MYISAM的最大的不同点在于:一是支持事务，二是采用行级锁。</p>
<p>记录锁也就是仅仅把一条记录锁上。比如说我们把id为8的那条记录加一个记录锁的示意图如图所示。仅仅是锁住了id值为8的记录，对周围的数据没有影响。</p>
<p>记录锁是有x锁和s锁，称之为s记录锁和x性记录锁:</p>
<p>​    当一个事务去获取了s锁后，其他事物也可以去尝试去获取s锁，但不可以去获取x锁。</p>
<p>​    当一个事务获取记录的X锁后，其他事物既不能获取s锁也不能获取x锁。</p>
<h4 id="8⃣️间隙锁"><a href="#8⃣️间隙锁" class="headerlink" title="8⃣️间隙锁:"></a>8⃣️间隙锁:</h4><p>MYSQL在可重负读中会出现幻读问题，解决方案为两种，第一种采用多版本并发控制，第二种就是采用加锁的方式。但是在使用加锁的方案时有个大问题，就是事务在第一次执行读取操作时，那些幻影记录尚不存在，我们无法给这些幻影记录加上记录锁。所以Innodb提出了一种gap locks 锁。我们简称gap锁。比如说把id值为8的数据加上一个gap锁示意图:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/63f6f93afc2e629cb41b1387_hd.jpeg" alt="img"></p>
<p>图中的id值为8的记录加上了gap锁，意味着不允许别的事务在id值为8的记录前边的间隙插入新的记录，其实就是id列尾(3-8)这个区间的新记录是不允许立即插入的。比如:有另外一个事务再想插入一条id值为4的新记录，它定位gap锁的事务提交之后，id列的值在区间(3,8)中的新记录才可以被插入。</p>
<p>gap锁的提出仅仅是为了防止插入幻影记录而提出的。</p>
<p>注意:给一条记录加上gap锁只是不允许其他事务往这条记录前边的间隙进行插入新记录，那对于最后一条记录之后的间隙，也就是最后一条数据之后的间隙该怎么办呢？</p>
<p>因为我们的数据页中有两个属性，一个表示最大值、一个表示最小值。所以可以根据我们的最后一条的记录的数据的id和我们的最大值这个区间，加上一个间隙锁，那么就可以阻止往我们这个表中最后一行后添加数据。</p>
<p>间隙锁有可能会产生死锁的:</p>
<p>因为这个区间不保证当前数据，比如说区间是(0~3),但是不包括3的，如果我们这时插入一条为3的记录值，那么就有可能会造成死锁。</p>
<h4 id="9⃣️临建锁"><a href="#9⃣️临建锁" class="headerlink" title="9⃣️临建锁:"></a>9⃣️临建锁:</h4><p>​        有时候我们即想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新数据，所以inndb提出了next-key locks，也是就是临建锁。可以帮我们解决间隙锁的死锁问题。</p>
<p>next-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。</p>
<p>next-key locks 是在innodb、事务级别在可重负读情况下使用的数据锁。Innodb默认的锁就是Next-key locks。</p>
<h4 id="🔟插入意向锁"><a href="#🔟插入意向锁" class="headerlink" title="🔟插入意向锁:"></a>🔟插入意向锁:</h4><p>​    我们说一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了gap锁,如果有的话，插入操作需要等待，直到拥有gap锁的那个事务提交。但是innodb规定事务在等待的时候也需要在内存中生成一个锁结构，表明有事务想在某个间隙中插入新记录，但是现在在等待。Innodb就把这种类型的锁命名为Insert Intention locks，官方的类型名称为:LOCK_INSERT_INTENTION，我们称为插入意向锁。插入意向锁是一种Gap锁，不是意向锁，在insert操作时产生。</p>
<p>​    插入意向锁是在插入一条记录行前，有insert操作产生的一种间隙锁。该锁用以表示插入意向，当多个事务在同一区间插入位置不同的多条数据时,事务之间不需要互相等待。假设存在两条值分别为4和7的记录，两个不同的事务分别试图插入值为5和6的两条记录，每个事务在获取插入行上独占的锁前，都会获取(4,7)之间的间隙锁，但是因为数据行之间并不冲突，所以两个事务之间并不会产生冲突(阻塞等待)。总结来说，插入意向锁的特性可以分为两部分:</p>
<p>​    (1)插入意向锁是一种特殊的间隙锁–间隙锁可以锁定开区间内的部分记录。</p>
<p>​    (2)插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身(主键、唯一索引)不冲突，那么事务之间就不会出现冲突等待。</p>
<p>注意,虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于间隙锁，因为意向锁是表锁而插入意向锁是行锁。</p>
<h4 id="从对待态度划分为-乐观锁、悲观锁"><a href="#从对待态度划分为-乐观锁、悲观锁" class="headerlink" title="从对待态度划分为:乐观锁、悲观锁"></a>从对待态度划分为:乐观锁、悲观锁</h4><p>​    悲观锁:表示很悲观，每次用户来获取数据的时候，都会认为会修改该数据，所以会添加锁机制，来保护数据的排他性。</p>
<p>悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁(共享资源每次只给一个线程使用，其它线程阻塞， 用完后再把资源转让给其它线程 )。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当 其他线程想要访问数据时，都需要阻塞挂起。Java中 synchronized 和 ReentrantLock 等独占锁就是 悲观锁思想的实现。</p>
<p>​    MySQL使用的行锁来进行实现,具体语法:</p>
<p>​    select…. for update;</p>
<p>select ….. for update语句执行过程中所有扫描的行都会被锁上,因此在mysql中用悲观锁必须确定使用索引，而不是全表扫描，否则将会把整个表锁住。</p>
<p>​    乐观锁:</p>
<p>​    乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，也就是不采用数据库本身的锁机制，而是通过程序来实现。在程序中，我们可以采用版本号机制活着cas机制实现。乐观锁适用于多读点应用类型，这样可以提高吞吐量。在java中使用atomic包下的原子类都是使用了乐观锁的一种实现方式:cas实现的。</p>
<p>​    1、乐观锁的版本号机制</p>
<p>在表中设计一个版本字段version，第一次读读时候,会获取version字段的取值.然后对数据进行更新或删除操作时,会执行update….set version&#x3D;version+1 where version&#x3D;version.此时如果已经有事务对这条数据进行更改，修改就不会成功。</p>
<p>这种方式类似我们熟悉的svn版本管理系统，当我们修改了代码进行提交时，首先会检查当前版本号与服务器上的版本号是否一致，如果一致就可以直接提交，如果不一致就需要更新服务器上的最新代码，然后再进行提交。</p>
<p>​    2、乐观锁的事件戳机制</p>
<p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行比较，如果两者一致则更新成功，否则就是版本冲突。你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳(版本号或者时间戳)，从而证明当前拿到的数据是否最新。</p>
<p>全局锁:</p>
<p>全局锁就是对整个数据库实例加锁。当你需要让整个库处于只读状态的时候.</p>
<p>flush tables with read lock;</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。</p>
<p>比如就是当事务去给id为1的值加了写锁，而事务B又去给id为2的值加了写锁。然后事务A又想去获取id为2的的写锁，而事务B又想去获取事务A的写锁。从而导致双方在互相等待对方的资源释放，就是进行了死锁状态。</p>
<p>死锁的两种策略:</p>
<p>   直接进入等待、直到超时&#x2F;通过设置参数来 innodb_lock_wait_timeout.</p>
<p>​    发起死锁检查。当发生死锁，主动进行回滚其中的某一个事务让其回到之前，这样就可以解决死锁问题。开启事务这个逻辑。</p>
<p>死锁检测的原理是构建一个以事务为顶点、锁为边的有向图，判断有向图是否存在环，存在即有死锁。</p>
<h2 id="18、MVCC-多版本并发控制"><a href="#18、MVCC-多版本并发控制" class="headerlink" title="18、MVCC(多版本并发控制)"></a>18、MVCC(多版本并发控制)</h2><p>在MYSQL Innodb的实现主要是为了提高数据库并发性能。用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读，而这个读指的是快照读，而非当前读。当前读实际上是一种加锁的操作 ，是悲观锁的实现。而MVCC本质是采用乐观锁来实现。</p>
<p>快照读又叫一致性读，读取的是快照数据。不加锁的简单的select都属于快照读。即不加锁的非阻塞读。select * from。。。。</p>
<p>既然叫快照读，那么读取的数据不一定是最新的数据，而有可能是我们的之前的历史版本数据。</p>
<p>快照读前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读。</p>
<p>当前读读取的是记录的最新版本，也就是最新的数据，读取时还要保证其他并发事务不能修改当前记录，会对当前记录进行加锁操作。加锁的seelct，或者对数据进行增删改都会进行当前读。</p>
<p>因为mysql数据库的默认的隔离界别是我们可重负读，所以在理论级别是没有办法解决幻读的问题。所以mysql采用了mvcc的多版本并发控制和next-key locks来解决这个幻读问题。</p>
<p>因为我们的mvcc基于undo log来进行实现.</p>
<p>我们需要知道undo日志的版本链。它的聚簇索引记录中包含了两个必要的隐藏列。</p>
<ul>
<li>trx_id；每次事务对某条聚簇索引记录进行改动时，都会把改事务的事务id赋值给trx_id隐藏列。</li>
<li>roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到改记录修改前的信息。</li>
</ul>
<p>通过这个roll_pointer指针会串联出一个单向链表的版本链。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230419230227900.png" alt="image-20230419230227900"></p>
<p>对该记录每次更新后，都会将旧值放到一条 undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_ponter属性连接成一个链表，我们把这个链表称之为 版本链 ，版本链的头节点就是当前记录最新的值。</p>
<p>每个版本中还包含生存该版本时对应的事务id。</p>
<p>mvcc的实现依赖于:隐藏字段、undo log、read view。</p>
<h3 id="什么是版本链"><a href="#什么是版本链" class="headerlink" title="什么是版本链"></a>什么是版本链</h3><p>在mvcc机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo log里。 如果一个事务想要查询这个记录，需要读取那个版本的行记录呢？这时就需要使用ReadVIew了，它帮我们解决了行的可见性问题。</p>
<p>ReadView就是事务在使用MVCC机制进行快照读操作时产生的读视图。当事务启动时，会生成数据库系统当前的一个快照，Innodb为每个事务构造了一个数组，用来记录并维护系统当前活跃事务的ID(活跃指的就是，启动了但还没提交)。</p>
<p>使用Read uncommited隔离级别的事务，由于可以读到未提交事务修改过的记录，所以直接读取记录的最新版本就好了。</p>
<p>使用serializable隔离级别的事务，Innodb规定使用加锁的方式来访问记录。</p>
<p>使用 READ COMMITTED 和 REPEATABLE READ 隔离级别的事务，都必须保证读到 已经提交了的 事务修改 过的记录。假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中的哪个版本是当前事务可见的，这是ReadView要解决的主要问题。</p>
<p>这个ReadView中主要包含4个比较重要的内容，分别如下:</p>
<ol>
<li>creator_trx_id，创建这个Read View的事务ID。</li>
<li>trx_ids,表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。</li>
<li>up_limit_id，活跃的事务中最小的事务ID</li>
<li>low_limit_id，表示生成ReadView时系统中应该分配给下一个事务的id值。low_limit_id是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务id。</li>
</ol>
<blockquote>
<p>说明:只是在对表中的记录做改动时(执行insert、delete、update这些语句时)才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0.</p>
</blockquote>
<blockquote>
<p> 注意:low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1， 2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时， trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4（3+1）。</p>
</blockquote>
<p>举例:</p>
<p>Try_ids为trx2、trx3、trx5和trx8的集合，系统的最大事务ID(low_limit_id)为trx8+1(如果之前没有其他的新增事务),活跃的最小事务ID(up_limit_id)为trx2.</p>
<h3 id="什么是Read-View的规则"><a href="#什么是Read-View的规则" class="headerlink" title="什么是Read View的规则"></a>什么是Read View的规则</h3><p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见。</p>
<ul>
<li>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事 务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判 断一下trx_id属性值是不是在 trx_ids 列表中。<ul>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
</li>
</ul>
<p>MVCC的执行的流程:</p>
<ol>
<li>首先获取事务自己的版本号，也就是事务 ID;</li>
<li>获取 ReadView;</li>
<li>查询得到的数据，然后与 ReadView 中的事务版本号进行比较;</li>
<li>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照;</li>
<li>最后返回符合规则的数据。</li>
</ol>
<p>如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依次类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么意味着该条记录对该事务完全不可见，查询结果就不包含该记录。</p>
<blockquote>
<p>Innodb中，mvcc是通过Undo Log+Read View进行数据读取，Undo log保存了历史快照，而Read View规则帮我们判断当前版本的数据是否可见。</p>
</blockquote>
<blockquote>
<p>在可重复读中我们每执行一个select就会去重新获取这个Read view。因为产生了不同的ReadView就会出现幻读的问题。</p>
</blockquote>
<p>例子:</p>
<p>有一张学生表，里面有一个数字为为张三的学生信息。</p>
<p>现在有两个 事务id 分别为 10 、 20 的事务在执行:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># Transaction 10</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"李四"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> student <span class="token keyword">SET</span> name<span class="token operator">=</span><span class="token string">"王五"</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true"># Transaction 20</span>
<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true"># 更新了一些别的表的记录 ...</span>
</code></pre>
<p>此刻，表student 中 id 为 1 的记录得到的版本链表如下所示:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220812204101481.png" alt="image-20220812204101481"></p>
<p>假设现在有一个使用 READ COMMITTED 隔离级别的事务开始执行:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true"># 使用READ COMMITTED隔离级别的事务 BEGIN;</span>
<span class="token comment" spellcheck="true"># SELECT1:Transaction 10、20未提交</span>

<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> student <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 得到的列name的值为'张三'</span>
</code></pre>
<p>分析一下为什么是”张三”:</p>
<ol>
<li><p>在执行select语句时会生成一个ReadView，ReadView的trx_ids列表为[10,20],up_limit_id为10、low_limit_id为21，create_trx_id为10.</p>
</li>
<li><p>从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是王五，该版本的trx_id值为10，在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。</p>
</li>
<li><p>下一版本的列为“李四”,该版本的trx_id值为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</p>
</li>
<li><p>张三的版本，该版本的trx_id值为8，小于ReadView中的up_limit_id值为10，所以这个版本是符合要求的，最后返回给用户的就是这个name为”张三”的记录。</p>
</li>
</ol>
<h3 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h3><p>什么是幻读:</p>
<p>幻读是指当我们两个事务执行过程中，一个事务去查询当前数据库的条数为30条，但是这是我们的事务B往这个数据库中插入两条数据。这个事务A再去读，发现条数变为了32条，这就表示发生了幻读。</p>
<p>那么MVCC是如何解决的呢?</p>
<p>假设现在表 student 中只有一条数据，数据内容中，主键 id&#x3D;1，隐藏的 trx_id&#x3D;10，它的 undo log 如下图 所示。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220812214440049.png" alt="image-20220812214440049"></p>
<p>假设现在有事务A和事务B并发执行， 事务A的事务id为 20 ， 事务B的事务id为 30 。</p>
<p>步骤1:事务A开始第一次查询数据，查询的SQL语句如下：</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> student <span class="token keyword">where</span> id<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre>
<p>在开始查询之前，MySQL会为事务A产生一个ReadView，此时ReadView的内容如下:try_ids&#x3D;[20,30],up_limit_id&#x3D;20,low_limit_id&#x3D;31,creator_trx_id&#x3D;20.</p>
<p>由于此时表student中只有一个数据，且符合where id&gt;&#x3D;1条件，因此会查询出来。然后根据ReadView机制，发现该行数据的trx_id&#x3D;10,小于事务A的ReadVIew里up_limi_id,这表示这条数据是事务 A 开启之前，其他事务就已经提交了的数据，因此事务 A 可以读取到。</p>
<p>结论：事务A的第一次查询，能读取到一条数据，id&#x3D;1；</p>
<p>2、接着事务 B(trx_id&#x3D;30)，往表 student 中新插入两条数据，并提交事务。</p>
<pre class=" language-sql"><code class="language-sql"> <span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">'李四'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
 <span class="token keyword">insert</span> <span class="token keyword">into</span> student<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'王五'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>此时表student 中就有三条数据了，对应的 undo 如下图所示:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220812214832346.png" alt="image-20220812214832346"></p>
<p>3、接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A 并不会再重新生成 ReadView。此时表 student 中的 3 条数据都满足 where id&gt;&#x3D;1 的条件，因此会先查出来。然后根据 ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p>
<p>1、首先 id&#x3D;1 的这条数据，前面已经说过了，可以被事务 A 看到。</p>
<p>2、然后是 id&#x3D;2 的数据，它的 trx_id&#x3D;30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之 间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids&#x3D;[20,30]，因此在数组内，这表 示 id&#x3D;2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</p>
<p>3、同理，id&#x3D;3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220812214956195.png" alt="image-20220812214956195"></p>
<p>结论:最终事务 A 的第二次查询，只能查询出 id&#x3D;1 的这条数据。这和事务 A 的第一次查询的结果是一样的，因此没有出现幻读现象，所以说在 MySQL 的可重复读隔离级别下，不存在幻读问题。</p>
<h2 id="19、MYSQL中的日志"><a href="#19、MYSQL中的日志" class="headerlink" title="19、MYSQL中的日志"></a>19、MYSQL中的日志</h2><h3 id="19-1-日志类型"><a href="#19-1-日志类型" class="headerlink" title="19.1 日志类型"></a>19.1 <strong>日志类型</strong></h3><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为 二机制日志、错误日志、通用查询日志和慢查询日志 ，这也是常用的4种。MySQL 8又新增两种支持的日志: 中继日志和数据定义语句日志。使用这些日志文件，可以查看MySQL内部发生的事情。</p>
<p><strong>这</strong>6<strong>类日志分别为:</strong></p>
<ul>
<li>**慢查询日志:**记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</li>
<li><strong>通用查询日志:</strong> 记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令， 对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</li>
<li><strong>错误日志:</strong> 记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</li>
<li><strong>二进制日志:</strong> 记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</li>
<li><strong>中继日志:</strong> 用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。 从服务器通过读取中继日志的内容，来同步主服务器上的操作。</li>
<li><strong>数据定义语句日志:</strong> 记录数据定义语句执行的元数据操作。</li>
</ul>
<p>除二进制日志外，其他日志都是文本文件 。默认情况下，所有日志创建于 MySQL数据目录 中。</p>
<p>日志的弊端:</p>
<p>日志功能会降低MYSQL数据库的性能 。</p>
<p>日志会占用大量的磁盘空间。</p>
<h4 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h4><p>通用查询日志用来包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，<strong>查看通用查询日志， 还原操作时的具体场景</strong> ，可以帮助我们准确定位问题。</p>
<p>查看当前状态</p>
<pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%general%'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+-------------------------------------------------+</span>
<span class="token operator">|</span> Variable_name    <span class="token operator">|</span> <span class="token keyword">Value</span>                                           <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+-------------------------------------------------+</span>
<span class="token operator">|</span> general_log      <span class="token operator">|</span> <span class="token keyword">OFF</span>                                             <span class="token operator">|</span>
<span class="token operator">|</span> general_log_file <span class="token operator">|</span> <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token keyword">local</span><span class="token operator">/</span>mysql<span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>kevintamdeMacBook<span class="token operator">-</span>Pro<span class="token punctuation">.</span>log <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+-------------------------------------------------+</span>
<span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre>
<p>开启临时性日志:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> general_log<span class="token operator">=</span><span class="token keyword">on</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true"># 开启通用查询日志</span>
</code></pre>
<h4 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h4><p>在MySQL数据库中，错误日志功能是 默认开启的。而且，错误日志无法被禁止 。</p>
<p>如果需要制定文件名，则需要在my.cnf或者my.ini中做如下配置:</p>
<pre class=" language-sql"><code class="language-sql"> <span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>
log<span class="token operator">-</span>error<span class="token operator">=</span><span class="token punctuation">[</span>path<span class="token operator">/</span><span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#path为日志文件所在的目录路径，filename为日志文件名</span>
</code></pre>
<p><strong>查看日志</strong></p>
<pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'log_err%'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">----------------------------+----------------------------------------+</span>
<span class="token operator">|</span> Variable_name              <span class="token operator">|</span> <span class="token keyword">Value</span>                                  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">----------------------------+----------------------------------------+</span>
<span class="token operator">|</span> log_error                  <span class="token operator">|</span> <span class="token operator">/</span>var<span class="token operator">/</span>log<span class="token operator">/</span>mysqld<span class="token punctuation">.</span>log                    <span class="token operator">|</span>
<span class="token operator">|</span> log_error_services         <span class="token operator">|</span> log_filter_internal<span class="token punctuation">;</span> log_sink_internal <span class="token operator">|</span>
<span class="token operator">|</span> log_error_suppression_list <span class="token operator">|</span>                                        <span class="token operator">|</span>
<span class="token operator">|</span> log_error_verbosity        <span class="token operator">|</span> <span class="token number">2</span>                                      <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">----------------------------+----------------------------------------+</span>
<span class="token number">4</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre>
<p><strong>删除</strong>刷新日志</p>
<pre class=" language-sql"><code class="language-sql">mysqladmin <span class="token operator">-</span>uroot <span class="token operator">-</span>p flush<span class="token operator">-</span>logs
Enter password:
mysqladmin: refresh failed<span class="token punctuation">;</span> error: <span class="token string">'Could not open file '</span><span class="token operator">/</span>var<span class="token operator">/</span>log<span class="token operator">/</span>mysqld<span class="token punctuation">.</span>log<span class="token string">' for
error logging.'</span>
install <span class="token operator">-</span>omysql <span class="token operator">-</span>gmysql <span class="token operator">-</span>m0644 <span class="token operator">/</span>dev<span class="token operator">/</span><span class="token boolean">null</span> <span class="token operator">/</span>var<span class="token operator">/</span>log<span class="token operator">/</span>mysqld<span class="token punctuation">.</span>log
</code></pre>
<h4 id="二进制日志（bin-log）"><a href="#二进制日志（bin-log）" class="headerlink" title="二进制日志（bin log）"></a>二进制日志（bin log）</h4><p>binlog可以说是mysql中比较重要的日志了，在日常开发及运维过程中，经常会遇到。</p>
<p>binlog即binary log，二进制日志文件，也叫作变更日志(update log)。它记录了数据库所有执行的 DDL 和 DML 等数据库更新事件的语句，但是不包含没有修改任何数据的语句(如数据查询语句select、show等)。</p>
<p>它以事件形式记录并保存在二机制文件中。通过这些信息，我们可以再现数据更新操作的全过程。</p>
<p> binlog主要应用场景:</p>
<ul>
<li><p>一是用于数据恢复</p>
</li>
<li><p>二是用于数据复制</p>
</li>
</ul>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220812232738221.png" alt="image-20220812232738221"></p>
<p>查看binlog日志的命令：</p>
<pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%log_bin%'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">---------------------------------+------------------------------------+</span>
<span class="token operator">|</span> Variable_name                   <span class="token operator">|</span> <span class="token keyword">Value</span>                              <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">---------------------------------+------------------------------------+</span>
<span class="token operator">|</span> log_bin                         <span class="token operator">|</span> <span class="token keyword">ON</span>                                 <span class="token operator">|</span>
<span class="token operator">|</span> log_bin_basename                <span class="token operator">|</span> <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token keyword">local</span><span class="token operator">/</span>mysql<span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>binlog       <span class="token operator">|</span>
<span class="token operator">|</span> log_bin_index                   <span class="token operator">|</span> <span class="token operator">/</span>usr<span class="token operator">/</span><span class="token keyword">local</span><span class="token operator">/</span>mysql<span class="token operator">/</span><span class="token keyword">data</span><span class="token operator">/</span>binlog<span class="token punctuation">.</span><span class="token keyword">index</span> <span class="token operator">|</span>
<span class="token operator">|</span> log_bin_trust_function_creators <span class="token operator">|</span> <span class="token keyword">OFF</span>                                <span class="token operator">|</span>
<span class="token operator">|</span> log_bin_use_v1_row_events       <span class="token operator">|</span> <span class="token keyword">OFF</span>                                <span class="token operator">|</span>
<span class="token operator">|</span> sql_log_bin                     <span class="token operator">|</span> <span class="token keyword">ON</span>                                 <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">---------------------------------+------------------------------------+</span>
<span class="token number">6</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre>
<p>日志参数设置:</p>
<p>永久性方式:</p>
<p>修改MySQL的 my.cnf 或 my.ini 文件可以设置二进制日志的相关参数:</p>
<pre class=" language-sql"><code class="language-sql"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>
<span class="token comment" spellcheck="true">#启用二进制日志</span>
log<span class="token operator">-</span>bin<span class="token operator">=</span>atguigu<span class="token operator">-</span>bin 
binlog_expire_logs_seconds<span class="token operator">=</span><span class="token number">600</span> 
max_binlog_size<span class="token operator">=</span>100M
</code></pre>
<p>重新启动MySQL服务，查询二进制日志的信息，执行结果:</p>
<pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%log_bin%'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">---------------------------------+----------------------------------+</span>
<span class="token operator">|</span> Variable_name                   <span class="token operator">|</span> <span class="token keyword">Value</span>                            <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">---------------------------------+----------------------------------+</span>
<span class="token operator">|</span> log_bin
<span class="token operator">|</span> log_bin_basename
<span class="token operator">|</span> log_bin_index
<span class="token operator">|</span> log_bin_trust_function_creators <span class="token operator">|</span> <span class="token keyword">OFF</span>                              <span class="token operator">|</span>
<span class="token operator">|</span> log_bin_use_v1_row_events       <span class="token operator">|</span> <span class="token keyword">OFF</span>                              <span class="token operator">|</span>
<span class="token operator">|</span> sql_log_bin                     <span class="token operator">|</span> <span class="token keyword">ON</span>                               <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">---------------------------------+----------------------------------+</span>
<span class="token number">6</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre>
<p><strong>设置带文件夹的</strong>bin-log<strong>日志存放目录</strong> </p>
<p>如果想改变日志文件的目录和名称，可以对my.cnf或my.ini中的log_bin参数修改如下:</p>
<pre class=" language-sql"><code class="language-sql"> <span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>
log<span class="token operator">-</span>bin<span class="token operator">=</span><span class="token string">"/var/lib/mysql/binlog/atguigu-bin"</span>
</code></pre>
<p><strong>查看日志</strong></p>
<p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一个以“filename”为名称、以“.000001”为后缀的文件。</p>
<p>MySQL服务 重新启动一次 ，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的 个数与MySQL服务启动的次数相同;如果日志长度超过了 max_binlog_size 的上限(默认是1GB)，就 会创建一个新的日志文件。</p>
<p>查看当前的二进制日志文件列表及大小。指令如下:</p>
<pre class=" language-sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">binary</span> logs<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+-----------+-----------+</span>
<span class="token operator">|</span> Log_name         <span class="token operator">|</span> File_size <span class="token operator">|</span> Encrypted <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+-----------+-----------+</span>
<span class="token operator">|</span> mysql<span class="token operator">-</span>bin<span class="token number">.000027</span> <span class="token operator">|</span>    <span class="token number">412487</span> <span class="token operator">|</span> <span class="token keyword">No</span>        <span class="token operator">|</span>
<span class="token operator">|</span> mysql<span class="token operator">-</span>bin<span class="token number">.000028</span> <span class="token operator">|</span>     <span class="token number">29476</span> <span class="token operator">|</span> <span class="token keyword">No</span>        <span class="token operator">|</span>
<span class="token operator">|</span> mysql<span class="token operator">-</span>bin<span class="token number">.000029</span> <span class="token operator">|</span>       <span class="token number">179</span> <span class="token operator">|</span> <span class="token keyword">No</span>        <span class="token operator">|</span>
<span class="token operator">|</span> mysql<span class="token operator">-</span>bin<span class="token number">.000030</span> <span class="token operator">|</span>    <span class="token number">149756</span> <span class="token operator">|</span> <span class="token keyword">No</span>        <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment" spellcheck="true">------------------+-----------+-----------+</span>
<span class="token number">4</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre>
<p>所有对数据库的修改都会记录在binlog中。但binlog是二进制文件，无法直接查看，想要更直观的观测它就要借助mysqlbinlog命令工具。</p>
<h4 id="使用binlog恢复数据"><a href="#使用binlog恢复数据" class="headerlink" title="使用binlog恢复数据"></a>使用binlog恢复数据</h4><p>mysqlbinlog恢复数据的语法如下:</p>
<pre class=" language-sql"><code class="language-sql">mysqlbinlog <span class="token punctuation">[</span><span class="token keyword">option</span><span class="token punctuation">]</span> filename<span class="token operator">|</span>mysql <span class="token operator">-</span>uuser <span class="token operator">-</span>p
</code></pre>
<p>这个命令可以这样理解:使用mysqlbinlog命令来读取filename中的内容，然后使用mysql命令将这些内容恢复到数据库中，记得使用flush logs进行刷新操作。</p>
<p>filename :binlog的名称</p>
<p>option :可选项，比较重要的两对option参数是–start-date、–stop-date 和 –start-position、– stop-position。</p>
<ul>
<li>–start-date 和 –stop-date：可以指定恢复数据库的起始时间点和结束时间点。</li>
<li>–start-position、– stop-position：可以指定恢复数据的开始位置和结束位置。</li>
</ul>
<blockquote>
<p>注意:使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如atguigu-bin.000001必 须在atguigu-bin.000002之前恢复。</p>
</blockquote>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>mysql的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。</p>
<p>1、purge master logs：删除指定日志文件</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">purge</span> master logs <span class="token keyword">to</span> <span class="token string">'指定日志文件名'</span>
</code></pre>
<h4 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h4><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到 binlog cache ，事务提交的时候，再 把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p>
<p>我们可以通过binlog_cache_size参数控制单个线程binlog cache大小，如果存储内容超过了这个参数，就要暂存到磁盘。binlog日志刷盘流程如下:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220813152021433.png" alt="image-20220813152021433"></p>
<blockquote>
<p>上图的weite,是指把日志写入到文件系统的page cache，并没有把数据持久化导磁盘，所以速度比较快</p>
<p>图中的fsync，才是讲数据持久化到磁盘的操作</p>
</blockquote>
<p>write和fsync的时机，可以由参数 sync_binlog 控制，默认是 0 。为0的时候，表示每次提交事务都只 write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的 binglog 会丢失。如下图:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220813153126641.png" alt="image-20220813153126641"></p>
<p>为了安全起见，可以设置为 1 ，表示每次提交事务都会执行fsync，就如同redo log <strong>刷盘流程</strong>一样。 最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220813153150076.png" alt="image-20220813153150076"></p>
<p>在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕 机，会丢失最近N个事务的binlog日志。</p>
<p> binlog<strong>与</strong>redolog对比</p>
<ul>
<li>redo log 它是 物理日志 ，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</li>
<li>而 binlog 是 逻辑日志 ，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层。</li>
</ul>
<h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a><strong>两阶段提交</strong></h4><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的 写入时机不一样。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220813154340081.png" alt="image-20220813154340081"></p>
<p>redo log<strong>与</strong>binlog<strong>两份日志之间的逻辑不一致，会出现什么问题?</strong></p>
<p>以update语句为列，假设id&#x3D;2点记录，字段c值是0，把字段c值更新成1，sql语句为update T set c&#x3D;1 where id&#x3D;2；</p>
<p>假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢?</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220813155132971.png" alt="image-20220813155132971"></p>
<p>由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。因此，之后用binlog日志恢复数据时,就会少这一次更新，恢复出来的这一行c值是0，而原库因为redo log日志恢复，这一行c值是1，最终数据不一致。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220813160020503.png" alt="image-20220813160020503"></p>
<p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用 <strong>两阶段提交</strong>方案。原理很简单，将redo log的写入拆成两个步骤prepare和commit，这就是两阶段提交。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220813160400080.png" alt="image-20220813160400080"></p>
<p>使用 <strong>两阶段提交</strong> 后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。</p>
<p>另一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢?</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220813220627103.png" alt="image-20220813220627103"></p>
<p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p>
<h3 id="中继日志"><a href="#中继日志" class="headerlink" title="中继日志"></a>中继日志</h3><p><strong>介绍</strong></p>
<blockquote>
<p><strong>中继日志只在主从服务器架构的从服务器上存在</strong> 。从服务器为了与主服务器保持一致，要从主服务器读 取二进制日志的内容，并且把读取到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫中继日志。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步 。</p>
</blockquote>
<p>搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220813225945527.png" alt="image-20220813225945527"></p>
<p>文件名的格式是: 从服务器-relay-bin.序号 。中继日志还有一个索引文件:从服务器-relay-bin.index ，用来定位当前正在使用的中继日志。</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><h4 id="1、主从复制概述"><a href="#1、主从复制概述" class="headerlink" title="1、主从复制概述"></a>1、主从复制概述</h4><p><strong>如何提升数据库并发能力</strong></p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220813231150863.png" alt="image-20220813231150863"></p>
<p>此外，一般应用对数据库而言都是“读多写少 ”，也就说对数据库读取数据的压力比较大，有一个思路就是采用数据库集群的方案，做 主从架构、进行读写分离 ，这样同样可以提升数据库的并发处理能力。但并不是所有的应用都需要对数据库进行主从架构的设置，毕竟设置架构本身是有成本的。如果我们的目的在于提升数据库高并发访问的效率，那么首先考虑的是如何优化SQL和索引 ，这种方式简单有效;其次才是采用缓存策略，比如使用 Redis将热点数据保存在内存数据库中，提升读取的效 率;最后才是对数据库采用主从架构进行读写分离。</p>
<h4 id="1-2-主从复制的作用"><a href="#1-2-主从复制的作用" class="headerlink" title="1.2 主从复制的作用"></a>1.2 <strong>主从复制的作用</strong></h4><p>主从同步设计不仅可以提高数据库的吞吐量，还有以下 3 个方面的作用。</p>
<p><strong>第</strong>1<strong>个作用:读写分离。</strong></p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220813231803276.png" alt="image-20220813231803276"></p>
<p><strong>第</strong>2**个作用就是数据备份。 **</p>
<p><strong>第</strong>3<strong>个作用是具有高可用性。</strong></p>
<h4 id="2-主从复制的原理"><a href="#2-主从复制的原理" class="headerlink" title="2 .主从复制的原理"></a><strong>2 .主从复制的原理</strong></h4><p>Slave 会从 Master 读取 binlog 来进行数据同步。</p>
<p><strong>原理剖析</strong></p>
<p><strong>三个线程</strong></p>
<p>实际上主从同步的原理就是基于 binlog 进行数据同步的。在主从复制过程中，会基于 3 个线程 来操 作，一个主库线程，两个从库线程。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220813235116407.png" alt="image-20220813235116407"></p>
<p>二进制日志转储线程 (Binlog dump thread)是一个主库线程。当从库线程连接的时候， 主库可以将二进 制日志发送给从库，当主库读取事件(Event)的时候，会在 Binlog 上 加锁 ，读取完成之后，再将锁释放掉。</p>
<p>从库 I&#x2F;O 线程会连接到主库，向主库发送请求更新Binlog。这时从库的I&#x2F;O线程就可以读取到主库的 二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 (Relay log)。</p>
<p>从库 SQL 线程会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</p>
<p>注意:</p>
<p>不是所有版本的mysql都默认开启了服务器的二机制日志。在进行主从同步的时候，我们需要先检查服务器是否已经开启了二进制日志。</p>
<h2 id="20、分库分表"><a href="#20、分库分表" class="headerlink" title="20、分库分表:"></a>20、分库分表:</h2><p>​    分表:比如说单表的数据都几千万数据了，你确认你能扛住吗？绝对不行，单表数量太大，会极大影响你的SQL执行的性能，到了后面你的sql可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会差一些，你就要进行分表了。</p>
<p>​    分表就一个将一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户的id来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在200万以内。</p>
<p>​    分库就是你讲一个库一般我们经验而言，最多支撑到并发2000，一定要扩容了，而且一个健康的单库并发值最好保持在每秒1000左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p>
<p>​    这就是分库分表。</p>
<h3 id="20-1-如何对数据库进行垂直拆分货水平拆分的"><a href="#20-1-如何对数据库进行垂直拆分货水平拆分的" class="headerlink" title="20.1 如何对数据库进行垂直拆分货水平拆分的?"></a>20.1 如何对数据库进行垂直拆分货水平拆分的?</h3><p>​    水平拆分的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结果都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义就是将数据均匀放更多的库的，然后用多个库来抗更高的并发，还有就是多个库的存储容量来进行扩容。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/63f82aedb555882530e2a1d4_hd.jpeg" alt="img"></p>
<p>​    垂直拆分的意思,就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放在一个表里去，然后将较多的访问频率很低的字段放在另一个表里去。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/63f82ba0b555882530e2af2a_hd.jpeg" alt="img"></p>
<p>​    两种分库分表的方式：</p>
<p>​        一种是按照range来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这 种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。</p>
<p>​        ·或者是按照某个字段hash一下均匀分散，这个较为常用。</p>
<p>​    range来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了， 到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数 据。实际生产用range，要看场景。</p>
<p>​    hash分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会 有一个数据迁移的过程，之前的数据需要重新计算hash值重新分配到不同的库或表</p>
<h3 id="20-2-大表数据查询，怎么优化"><a href="#20-2-大表数据查询，怎么优化" class="headerlink" title="20.2 大表数据查询，怎么优化:"></a>20.2 大表数据查询，怎么优化:</h3><p>​    优化shema、sql语句+索引；</p>
<p>​    第二加缓存，memcached，redis； </p>
<p>​    主从复制，读写分离；</p>
<p>​    垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统； </p>
<p>​    水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key，为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</p>
<h3 id="20-3-超大分页怎么处理"><a href="#20-3-超大分页怎么处理" class="headerlink" title="20.3 超大分页怎么处理?"></a>20.3 超大分页怎么处理?</h3><p>数据库层面，这也是我们主要集中关注的（虽然收效没那么大），类似于select * from table where age &gt;201 imit 1000000，这种查询其实也是有可以优化的余地的。这条语句需要load 1000000数据然 后基本上全部丢弃，只取10条当然比较慢。当时我们可以修改为se1ect * from tab1 e where id  in (select id from tab1 e where age&gt; 201 imit 1000000，10)。这样虽然也load了一百万的数据，但是由于索引覆盖，要查询的所有字段都在索引中，所以速度会很快。</p>
<p>说明：mySQL并不是跳过offset行，而是取offset-+N行，然后返回放弃前offset行，返回N行，那 当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数</p>
<p>进行SQL改写。</p>
<p>正例：先快速定位需要获取的d段，然后再关联：</p>
<p>SELECT a。* FRoM表1a，(select id from表1 where条件LIMIT100000，20)b where a。id&#x3D;b。id</p>
<h2 id="21、统计过慢查询吗？对慢查询都进行哪些优化？"><a href="#21、统计过慢查询吗？对慢查询都进行哪些优化？" class="headerlink" title="21、统计过慢查询吗？对慢查询都进行哪些优化？"></a>21、统计过慢查询吗？对慢查询都进行哪些优化？</h2><p>1、可以去开启我们数据库的中慢查询日志slow_query_log。将所有的一些慢sql都会记录下来。</p>
<p>2、然后我们对这些SQL进行分析 使用工具mysqldumpslow。</p>
<p>3、查询条件没有命中索引?</p>
<p>4、还是load了不需要的数据？</p>
<p>5、还是数据量太大？</p>
<p>具体的措施:</p>
<p>1、使用explain分析一下这条SQL有没有走索引，然后去对这条SQL进行修改。</p>
<p>2、查询多余的列，我们可以将多余的列进行丢弃。进行重写</p>
<p>3、如果数据量太大。如果太大的话，我们尝试去进行一些垂直拆分、或者是水平的拆分。将一些表里面的数据进行拆分。</p>
<h2 id="22、如何优化查询过程中的数据访问？"><a href="#22、如何优化查询过程中的数据访问？" class="headerlink" title="22、如何优化查询过程中的数据访问？"></a>22、如何优化查询过程中的数据访问？</h2><p>​    1、访问数据太多导致查询性能下降</p>
<p>​    2、确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</p>
<p>​    3、确认MySQL服务器是否在分析大量不必要的数据行</p>
<p>​    4、查询不需要的数据。解决办法，使用limit</p>
<p>​    5、多表关联返回全部列。解决办法:指定列明</p>
<p>​    6、总是返回全部列。解决办法:避免使用select *</p>
<p>​    7、重负查询相同的数据，先缓存下来，下次直接读取缓存</p>
<h2 id="23、MySQL数据库CPU飙升到500-的话怎么处理？"><a href="#23、MySQL数据库CPU飙升到500-的话怎么处理？" class="headerlink" title="23、MySQL数据库CPU飙升到500%的话怎么处理？"></a>23、MySQL数据库CPU飙升到500%的话怎么处理？</h2><p>当cpu飙升到500%时，先使用操作系统命令top去看一下是不是MySQL的占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p>
<p>如果是MySQL的造成，show processlist，看看里面跑的session情况，是不是有消耗资源的SQL在运行。找出消耗高的SQL，看看执行计划是否准确，index是否缺失，或者实在是数据量太大造成。</p>
<p>一般来说，肯定要kill掉这些线程，等进行相应的调整之后，在重新跑这些SQL。</p>
<p>也有可能是每个SQL消耗资源并不多，但是突然之间，有大量的session连进来导致cpu飙升，这种情况就需要跟应用一起分析为何连接数会激增，在做出相应的调整，比如说限制连接数等。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">kevintam</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2023/05/02/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/">http://example.com/2023/05/02/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint policy. If reproduced, please indicate source
                    <a href="/about" target="_blank">kevintam</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;Current
            </div>
            <div class="card">
                <a href="/2023/05/02/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-05-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            kevintam
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/05/02/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-05-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            kevintam
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + 'From: kevintam<br />'
            + 'Author: kevintam<br />'
            + 'Link: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">kevintam</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;Total visits:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;Total visitors:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/txh-rookie" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=843808107" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 843808107" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
