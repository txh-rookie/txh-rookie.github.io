<!DOCTYPE HTML>
<html lang="zh">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="kevintam">
    <meta name="description" content="Servlet篇1、Servlet的生命周期
servlet实例在web容器中从配置。会去调用我们的servlet的init方法进行初始化。
然后会调用我们的service方法进行使用。
使用完成之后，调用的destory销毁结束。

2、">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>kevintam</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">kevintam</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">kevintam</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/txh-rookie" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>txh-rookie
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/txh-rookie" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="txh-rookie" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2023-05-02
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Servlet篇"><a href="#Servlet篇" class="headerlink" title="Servlet篇"></a>Servlet篇</h1><h2 id="1、Servlet的生命周期"><a href="#1、Servlet的生命周期" class="headerlink" title="1、Servlet的生命周期"></a>1、Servlet的生命周期</h2><ol>
<li>servlet实例在web容器中从配置。会去调用我们的servlet的init方法进行初始化。</li>
<li>然后会调用我们的service方法进行使用。</li>
<li>使用完成之后，调用的destory销毁结束。</li>
</ol>
<h2 id="2、forwoard和redirect的区别"><a href="#2、forwoard和redirect的区别" class="headerlink" title="2、forwoard和redirect的区别"></a>2、forwoard和redirect的区别</h2><ul>
<li><p>地址栏显示不同，forward地址栏显示的是原来的地址，因为其是由服务器请求资源，直接访问目标地址的URL，并读取响应内容，然后将内容发送至浏览器，浏览器并不知道目标地址。redirect显示的是新的URL，因为其是个是服务器根据逻辑发送状态码至浏览器，让浏览器重新请求目标地址，所以浏览器是知道目标地址的。</p>
</li>
<li><p>数据共享方式不同，forward转发页面和目标页面均可共享request的数据。redirect则是不可以共享数据。</p>
</li>
<li><p>通常应用的场景不同，forward一般用于用户登陆的时候,根据角色转发到相应的模块。redirect一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p>
</li>
<li><p>效率不同，通常认为forward的效率要更高</p>
</li>
</ul>
<h2 id="3、session和cookie有什么区别？"><a href="#3、session和cookie有什么区别？" class="headerlink" title="3、session和cookie有什么区别？"></a>3、session和cookie有什么区别？</h2><ol>
<li>cookie可以被客户端禁用，但是客户端无法禁用服务端的session。</li>
<li>存储的对象不同，session能够存储任意的Java对象，cookie只能存储String类型的对象。</li>
<li>数据存储的地址不同，cookie数据保存在客户端，session数据保存在服务器端</li>
</ol>
<h2 id="5、对Servlet线程安全的理解"><a href="#5、对Servlet线程安全的理解" class="headerlink" title="5、对Servlet线程安全的理解"></a>5、对Servlet线程安全的理解</h2><ol>
<li>客户端第一次请求Servlet的时,tomcat会根据web.xml配置文件实例化servlet，当又有一个客户端访问该servlet的时候，不会再实例化该servlet，这就是JSP&#x2F;Servlet容器默认采用的单实例多线程(这是造成线程安全的主因)处理多个请求的方式。</li>
<li>Servlet本身是无状态的，一个无状态的Servlet是绝对线程安全的，所以servlet是否线程安全是由它的实现来决定的，如果它内部的属性或方法会被多个线程改变，它就是线程不安全的，反之，就是线程安全的。</li>
<li>避免使用实例变量 ，避免使用非线程安全的集合，在多个Servlet中对某个外部对象(例如文件)的修改是务必加锁，互斥访问，都能够提高线程安全性。</li>
</ol>
<h2 id="6、get和post有何区别？"><a href="#6、get和post有何区别？" class="headerlink" title="6、get和post有何区别？"></a>6、get和post有何区别？</h2><ol>
<li>get参数传递通过url，post放在resquest body中</li>
<li>get请求参数有长度限制，post没有</li>
<li>get不安全，因为参数暴露在url中。post安全，参数是隐藏的</li>
<li>get请求只能进行url编码。post支持多种编码</li>
<li>get请求参数会被完整保留在浏览历史记录，而post不会被保留。</li>
<li>get产生一个tcp数据包；post产生两个tcp数据包。</li>
<li>get和post本质就是tcp链接，并无差别。但是由于HTTP的规定和浏览器&#x2F;服务器的限制，导致他们在应用过程中体现出一些不同。</li>
</ol>
<h1 id="MyBatis篇"><a href="#MyBatis篇" class="headerlink" title="MyBatis篇"></a>MyBatis篇</h1><h2 id="1、什么是MyBatis"><a href="#1、什么是MyBatis" class="headerlink" title="1、什么是MyBatis"></a>1、什么是MyBatis</h2><ol>
<li>mybatis是持久层的框架，主要用于解决我们和数据库之间的交互问题。</li>
<li>对我们的jdbc进行封装，可以让程序员更加关注我们的sql语句的编写。而不是很多多余的代码</li>
<li>MyBatis是一个ORM(对象映射)框架。使用xml或注解来来配置我们的映射原生信息，将POJO映射成数据库中的记录，避免了几乎所有的JDBC代码和手动设置参数以及获取结果。</li>
<li>通过xml文件或注解的方式将要执行的各种statment配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象返回。</li>
</ol>
<h2 id="2、Mybatis的编程步骤是什么样的？"><a href="#2、Mybatis的编程步骤是什么样的？" class="headerlink" title="2、Mybatis的编程步骤是什么样的？"></a>2、Mybatis的编程步骤是什么样的？</h2><p>1、创建SQLSessionFactory</p>
<p>2、通过SQLSessionFactory创建SqlSession</p>
<p>3、通过SqlSession执行数据库操作</p>
<p>4、调用session.commit()提交事务</p>
<p>5、调用session.close();关闭会话</p>
<blockquote>
<p>注意事项:Mybatis默认的是自动提交关闭。需要手动提交才可以。</p>
<ul>
<li>自动提交:就是我们执行完一个DML SQL语句之后，就会自动进行提交数据。数据库就会去更新操作来保存数据。</li>
<li>手动提交:当你的DML SQL语句执行完毕时，事务不会自动提交,需要你手动的去提交事务。数据库才会更新操作保存数据。支持事务的回滚。</li>
</ul>
</blockquote>
<h2 id="3、什么是MVC的三层架构"><a href="#3、什么是MVC的三层架构" class="headerlink" title="3、什么是MVC的三层架构"></a>3、什么是MVC的三层架构</h2><p>1、Model:指我们的所需要的数据。</p>
<p>2、view:是视图对象，就是我们常说的jsp、html等都是视图对象，向前端用户更加美观的展示数据。</p>
<p>3、controller:接收请求,调用service对象,显示请求的处理结果</p>
<p>作用:</p>
<p>​         1）实现解耦合</p>
<p>​        2）让mvc各负其职。</p>
<p>​        3）使系统扩展更好。更容易维护。</p>
<p>​        4）结构清晰、耦合度低。各层次分工明确。</p>
<p>三层架构请求的处理流程:</p>
<p>用户发送请求—-&gt;界面层—-&gt;业务层—-&gt;持久层—–&gt;数据库（mysql）</p>
<h2 id="4、-和-的区别"><a href="#4、-和-的区别" class="headerlink" title="4、#{}和${}的区别"></a>4、#{}和${}的区别</h2><p>1、#{}和${}在mybatis中都是表示占位符，可以用于接收java程序传输的数据。都是反射调用我们的get对应的方法去获取我们的属性。</p>
<p>2、#{}和${}在底层调用jdbc的对象是不同的，一个PreparedStatement、一个Statement对象。它们对我们传输过来的java数据的处理是不一样的。一个会将我们传入的数据进行预编译，一个不会对我们传入的数据进行预编译。而是以拼接的形式将其放入到我们的sql后面。所以会出现一个SQL注入到问题。</p>
<blockquote>
<p>去验证账号密码的时候，我们的sql语句，select  from 表明 where username&#x3D;#{username} and password&#x3D;#{password}。SQL注入就是指，在这个后面会并且上 or 1&#x3D;1，我们or后面永远都是true。or语句就是指一旦有一个为true，那么我们的语句就都为true。<em>所以就会存在个问题，就是无论我们输入的账号密码是否正确，都会返回true</em></p>
</blockquote>
<h2 id="5、Mybatis这么起别名"><a href="#5、Mybatis这么起别名" class="headerlink" title="5、Mybatis这么起别名"></a>5、Mybatis这么起别名</h2><p>1、第一种就是使用typeAliases，中可以自定义别名</p>
<p>2、第二种方式就是使用name:包名 mybatis会把这个包下的所有的类的类名做为别名。</p>
<h2 id="6、MyBatis中的重要的对象"><a href="#6、MyBatis中的重要的对象" class="headerlink" title="6、MyBatis中的重要的对象"></a>6、MyBatis中的重要的对象</h2><h3 id="6-1-、Resource"><a href="#6-1-、Resource" class="headerlink" title="6.1 、Resource:"></a>6.1 、Resource:</h3><p>这个类主要的作用就是读取主配置文件里面的信息。</p>
<pre class=" language-java"><code class="language-java"> InputStream inputStream <span class="token operator">=</span> Resources<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"path"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="6-2、SqlSessionFactoryBuilder"><a href="#6-2、SqlSessionFactoryBuilder" class="headerlink" title="6.2、SqlSessionFactoryBuilder"></a>6.2、SqlSessionFactoryBuilder</h3><p>负责创建SqlSessionFactory对象</p>
<pre class=" language-sql"><code class="language-sql">SqlSessionFactory build <span class="token operator">=</span> new SqlSessionFactoryBuilder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>build<span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h3 id="6-3-、SqlSessionFactory是一个重要的对象"><a href="#6-3-、SqlSessionFactory是一个重要的对象" class="headerlink" title="6.3 、SqlSessionFactory是一个重要的对象"></a>6.3 、SqlSessionFactory是一个重要的对象</h3><p>SqlSessionFactory是重量级对象，创建此对象需要使用更多的资源的时间。</p>
<p>SqlSessionFactory接口：作用是SqlSession的工厂，就是创建SqlSession对象。</p>
<p>DefaultSqlSessionFactory实现类:</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSqlSessionFactory</span> <span class="token keyword">implements</span> <span class="token class-name">SqlSessionFactory</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre>
<p>SqlSessionFactory接口中的方法</p>
<p>openSession():获取一个默认的SqlSession对象,默认是需要手动提交事务的。</p>
<p>openSession(boolean):boolean参数表示是否自动提交事务。</p>
<p>​                         true:创建一个自动提交事务的SqlSession对象</p>
<p>​                        false:等同于没有参数的openSeesion</p>
<p>SqlSession作用提供了大量执行sql的方法。</p>
<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">selectOne</span><span class="token punctuation">(</span>String statement<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//执行sql语句，返回结果为一条记录，多余一条的会报错。</span>
<span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">selectList</span><span class="token punctuation">(</span>String statement<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行sql语句，返回的一条或多条的记录.不确定具体的条数的可以用这个方法 </span>
<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">selectMap</span><span class="token punctuation">(</span>String statement<span class="token punctuation">,</span> String mapKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行sql语句，返回的结构封装成一个mapint </span>
<span class="token function">insert</span><span class="token punctuation">(</span>String statement<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行insert语句，添加操作。</span>
<span class="token keyword">int</span> <span class="token function">update</span><span class="token punctuation">(</span>String statement<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行uodate语句，修改操作。</span>
<span class="token keyword">int</span> <span class="token function">delete</span><span class="token punctuation">(</span>String statement<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行delete语句，删除操作。</span>
<span class="token keyword">void</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//提交事务</span>
<span class="token keyword">void</span> <span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//事务回滚</span>
</code></pre>
<blockquote>
<p>⚠️注意:Note that this class is not Thread-Safe.译为:请注意，此类不是线程安全的。</p>
<p>通过源码里面的注释得到SqlSession不是线程安全的,使用它需要一定的步骤:</p>
<ul>
<li>在方法内部，执行sql之前，获取SqlSession对象。</li>
<li>调用SqlSession对象，执行对应的方法。</li>
<li>关闭Session对象。session.close();方法</li>
</ul>
<p>因为在同一个方法中使用，其他线程无法共享该对象。</p>
</blockquote>
<h2 id="7、MyBatis的执行流程-🌟🌟🌟🌟🌟"><a href="#7、MyBatis的执行流程-🌟🌟🌟🌟🌟" class="headerlink" title="7、MyBatis的执行流程:🌟🌟🌟🌟🌟"></a>7、MyBatis的执行流程:🌟🌟🌟🌟🌟</h2><p>1、通过我们的Resource调用我们配置好的MyBatis.xml配置文件。Resource是ibatis.io包下面的类，也就是一个IO类，用于读写文件，通过getResourceAsStream把xml文件加载进来，把配置文件解析为一个流。</p>
<p>2、然后通过我们的SqlSessionFactoryBuilder，来构建SqlSessionFactory。调用build()方法。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>3、我们发现里面有一个XMLconfigBuilder对象，他是做什么的呢？他是用来解析XML文件的一个构建者，通过他的parse()方法解析mybatis配置文件</p>
<p><img src="https://img-blog.csdnimg.cn/20190623190931763.png" alt="img"></p>
<p>4、解析configuration节点下的子节点:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70-20230427233443620.png" alt="img"></p>
<p>5、然后我们发现parse()解析完成后，他返回了一个configuration对象，它是用来存放mybatis核心配置文件解析完成后的结果。这个configuration又返回给谁了呢？继续看源码：</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70-20230427233536999.png" alt="img"></p>
<p>6、又返回了一个build方法，把刚才的返回值configuration作为参数传入这个方法中，并返回了一个DefaultSqlSessionFactory对象，这是SqlSessionFactory的实现类，用来生产defaultSqlSession对象。这样上面的第三步才算真正的结束了。。。</p>
<p>7、我们继续往下走，我们最终的目的是获取一个SqlSession对象，现在我们有了一个SqlSessionFactory了，就愉快的生成SqlSession吧。从第三句看，调用了openSession()方法，这又是个啥？看源码：</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70-20230427233641077.png" alt="img"></p>
<p>先看到返回值是sqlSession，再看看里面有些什么：</p>
<p> 　　Transaction,这很明显是一个事务，我们都知道sql执行时都要涉及到事务操作的，提交或回滚什么的。而这个transaction产生需要什么参数呢，看源码知道里面有个environment（xml中配置的），而且是从configuration中获得的（之前做的总算没有白费），通过这些参数transactionFactory就帮我们产生了transaction。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70-20230427233746496.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190623191750455.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190623191903575.png" alt="img"></p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70-20230427233815449.png" alt="img"></p>
<p>8、这里通过JDK动态代理，帮mapper接口生成代理实现类</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70-20230427233838293.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20190623191831472.png" alt="img"></p>
<p>9、通过第四步返回的代理对象的getUser方法调用getMapper方法最终执行的方法</p>
<p>代理对象的getUser方法执行其实走的是MapperProxy的invoke方法</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70-20230427233926393.png" alt="img"></p>
<p>最后会调用execute，这个execute会去判断sql的执行类型。</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70-20230427235729479.png" alt="img"></p>
<p>查询方法</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70-20230427235747139.png" alt="img"></p>
<p>走executor的query方法 </p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70-20230427235802101.png" alt="img"></p>
<p>走CachingExecutor的query方法，先从二级缓存中获取:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70-20230427235815911.png" alt="img"></p>
<p>如二级缓存中没有数据，走delegate(BaseExecutor)的query方法 ，也就是一级缓存localCache，如果一级缓存没有数据，则走queryFromDatabase方法查数据库</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70-20230427235832722.png" alt="img"></p>
<p>从数据库查到数据，放入到一级缓存中 </p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MjcwMTA2,size_16,color_FFFFFF,t_70-20230427235854224.png" alt="img"></p>
<p>一级缓存底层是个PerpetualCache类型的HashMap， </p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">protected</span> PerpetualCache localCache<span class="token punctuation">;</span>
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20190623193811655.png" alt="img"></p>
<p>mybatis的执行流程总结:</p>
<ul>
<li>去通过我们的Resources.getResourceAsStream去加载我们的配置文件。返回值是我们的InputStream。拿到Stream流后。将这个流对象发送给我们的SqlSessionFactoryBuilder.利用构建者模式用于创建我们的SqlSessionFactory。创建SqlSessionFactory是一个很复杂的对象，这里面需要解析我们的xml配置文件。所以利用我们的构建者模式来进行构建。</li>
<li>build会创建一个XMLConfigruation对象去解析我们的流对象。然后将我们的解析对象传给我们的DefacultSqlSessionFactory对象。</li>
<li>然后通过的SqlSessionFactory调用OpenSession()方法。OpenSession底层待用了我们的OpenSessionFormDataScourse方法,在里面生成一些我们的TrasactionFactory事务工厂，用于生产事务。然后将我们的这些信息封装(Transaction、Executor、是否自动提交)给我们的DefaultSqlSession对象。</li>
<li>我们的DefaultSqlSession对象调用我们的getMapping(),实际上调用的是我们的configruation.getMapping();</li>
<li>调用了一个mappRegistry.这个类里面维护一个HashMap&lt;Class对象,MapperProxyFactory&lt;?&gt;&gt;。key表示是我们的mapper接口，value就是我们的MapperProxyFactory</li>
<li>底层是调用的我们的proxy类来帮我们的动态生产了一个mapper接口的实现类。</li>
<li>我们调用的方法其实是执行的是我们的mapperProxy中的invoke方法。去判断一下我们的执行的SQL语句是什么类型的。如果是select就会调用我们的SqlSession中的select方法去进行查询，select方法调用的是SimpExecutor里面的。调用里面的doQuery方法。会使用的PreparedStatement去处理我们的sql语句。</li>
<li>动态代理类为我们生成的实现类，然后通过这个实现类，去调用我们的接口的方法。先去二级缓存取找，如果找不到在去一级缓存中去查。</li>
</ul>
<h2 id="8、MyBatis的参数"><a href="#8、MyBatis的参数" class="headerlink" title="8、MyBatis的参数"></a>8、MyBatis的参数</h2><h3 id="1、parameterType"><a href="#1、parameterType" class="headerlink" title="1、parameterType"></a>1、parameterType</h3><p>将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectPerson<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>int<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hashmap<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  SELECT * FROM PERSON WHERE ID = #{id}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>
</code></pre>
<p>这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p>
<p>这就告诉 MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 近似的 JDBC 代码，非 MyBatis 代码...</span>
String selectPerson <span class="token operator">=</span> <span class="token string">"SELECT * FROM PERSON WHERE ID=?"</span><span class="token punctuation">;</span>
PreparedStatement ps <span class="token operator">=</span> conn<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>selectPerson<span class="token punctuation">)</span><span class="token punctuation">;</span>
ps<span class="token punctuation">.</span><span class="token function">setInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>parameterType：mybatis可以通过反射拿到dao接口的类型,所以可以不写.程序依旧可以运行。</p>
<p>parameterType的两种用法:</p>
<ol>
<li>java类型的全限定名称。如:java.lang.Integer</li>
<li>mybatis定义的类型的别名.如:parameterType&#x3D;”int”</li>
</ol>
<h3 id="如何处理多个参数的传递"><a href="#如何处理多个参数的传递" class="headerlink" title="如何处理多个参数的传递"></a>如何处理多个参数的传递</h3><p>1、dao接口的方法参数是一个简单类型的参数:</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//    dao接口的方法是一个简单类型的参数</span>
<span class="token comment" spellcheck="true">//    简单类型：java的基本数据类型和String</span>
Student <span class="token function">selectById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--    mapper文件获取这个参数类型使用#{任意字符}--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectById<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.Integer<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.rookie.entity.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       
  select id,name,email,age from t_student where id=#{id}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>
</code></pre>
<p> 2、dao接口多个简单类型的参数</p>
<p>要使用@Param的</p>
<p>不使用会报错:Parameter ‘name’ not found. Available parameters are [arg1, arg0, param1, param2]</p>
<p>@Param：命名参数，注解是mybatis自带的</p>
<p>位置：在形参定义的前面</p>
<p>属性: value自定义的参数名称</p>
<p>一旦使用了@Param设置了参数名称,那么xml文件中也要使用相同的参数</p>
<p>3、dao接口方法使用一个对象作为参数</p>
<p>方法的形参是一个java对象，这个java对象表示多个参数，使用对象的属性值作为参数使用。</p>
<p>dao接口中的方法定义:</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//    dao方法形参是java对象    </span>
List<span class="token operator">&lt;</span>Student<span class="token operator">></span> <span class="token function">selectByStudent</span><span class="token punctuation">(</span>Student student<span class="token punctuation">)</span><span class="token punctuation">;</span>   
List<span class="token operator">&lt;</span>Student<span class="token operator">></span> <span class="token function">selectByQuery</span><span class="token punctuation">(</span>Query query<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>mapper.xml文件</p>
<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--以java对象作为方法参数,使用对象的属性作为参数值使用  简单的语法:#{属性名} mybatis会从对象的属性中拿到其get方法来获取值--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectByStudent<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.rookie.entity.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> 
  select id,name,email,age from t_student where name=#{name} or age=#{age}    
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>    
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectByQuery<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.rookie.entity.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        
  select id,name,email,age from t_student where name=#{name} or age =#{age}    
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>
<span class="token comment" spellcheck="true">&lt;!--严格的语法格式为: 
select id,name,email,age from t_student where name=#{name,javaType=java.lang.String,jdbcType=VARCHAR} or age=#{age}--></span>
</code></pre>
<p>4、使用位置来获取参数(了解即可)</p>
<p>参数位置:dao的接口中方法的形参，从左往右，参数位置依次是0,1,2,3</p>
<p>语法格式:#{arg0} ,#{arg1}</p>
<p>5、使用map作为参数dao方法的参数(了解)</p>
<p>参数位置:放在dao接口中的形参上</p>
<p>dao</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//    使用map作为参数    </span>
List<span class="token operator">&lt;</span>Student<span class="token operator">></span> <span class="token function">selectByMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Object<span class="token operator">></span> maps<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>xml：参数为map 的key，就可以拿到对应的value</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectByMap<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.rookie.entity.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  
  
  select id,name,email,age from t_student where name=#{myname} or age=#{myage}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>
</code></pre>
<p>缺点:可读性较差。</p>
<p>优点：可以插入大量的参数。</p>
<p>6、 list</p>
<p>参数位置</p>
<p>dao:</p>
<pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Student<span class="token operator">></span> <span class="token function">selectList</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>在底层会自动将自解析成map，key为我们的方法名 list,value为就是我们的list集合。数组的话key就是array.</p>
<h2 id="9、封装mybatis的输出结果"><a href="#9、封装mybatis的输出结果" class="headerlink" title="9、封装mybatis的输出结果"></a>9、封装mybatis的输出结果</h2><h3 id="1、resultType"><a href="#1、resultType" class="headerlink" title="1、resultType"></a>1、resultType</h3><p>resultTyep属性：在执行select时使用，作为<select>标签的属性出现的。</p>
<p>resultType：表示结果类型，mysql执行sql语句，得到java对象的类型。它的值有两种</p>
<p>1） java类型的全限定的类名  2）使用别名</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectById<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>java.lang.Integer<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.rookie.entity.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       
select id,name,email,age from t_student where id=#{id}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>
</code></pre>
<p>resultType:现在使用java类型的全限定名称。表示的意思mybatis执行sql,把ResultSet中的数据转为Student类型的对象.</p>
<p>mybatis会做一下操作：<br>1.调用com.rookie.emtity.Student的无参构造方法,创建对象。(使用反射机制创建对象)<br>2.同名的列赋值给同名的属性。<br>3.得到java对象,如果dao接口返回值是List集合,mybatis把student对象放入到List集合。</p>
<blockquote>
<p>注意⚠️:resultType:表示一个map类型</p>
<p>执行sql得到一个map结构数据，mybatis执行sql，将其转为map。</p>
<p>sql执行的结果，列名作为map的key值,列值作为value值</p>
<p>sql执行的结果集只能为一条，多余一条会报错</p>
</blockquote>
<h3 id="2、ResultMap结果映射"><a href="#2、ResultMap结果映射" class="headerlink" title="2、ResultMap结果映射"></a>2、ResultMap结果映射</h3><p>自定义列名与java对象属性的关系。常用在列名与属性名不一样的情况下使用的。</p>
<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--    使用resultMap定义列名与属性的关系 
    id值是给resultMap起个名称，唯一值       
    type:java对象的全限定名称       column:指定那一列       property:指定对应的javaBean属性--></span>    
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resultMap</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>QueryMap<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.rookie.entity.Query<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&lt;
  !--        主键使用id来命名-->       
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>id<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cid<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cname<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>        
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>result</span> <span class="token attr-name">column</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span> <span class="token attr-name">property</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>result</span><span class="token punctuation">></span></span>    
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resultMap</span><span class="token punctuation">></span></span>
</code></pre>
<p>可以用来实现一对一，或者一对多。</p>
<p>一对一使用级联属性association，来进行一对一关联。</p>
<p>一对多使用collection，来进行一对多的关联。</p>
<h3 id="3、like"><a href="#3、like" class="headerlink" title="3、like"></a>3、like</h3><p>第一种方式在java程序中，把like 的占位符组织好，传入到sql中</p>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectLike<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       
   select id,name,email,age from t_student where name like #{name}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>
</code></pre>
<p>第二种方式在sql语句中进行组织。</p>
<pre class=" language-sql"><code class="language-sql"><span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">"%"</span> <span class="token comment" spellcheck="true">#{name} "%" </span>
</code></pre>
<h2 id="10、动态SQL"><a href="#10、动态SQL" class="headerlink" title="10、动态SQL"></a>10、动态SQL</h2><p>动态SQL,通过mybatis提供的各种标签对条件作出判断以实现动态拼接SQL语句。这里的条件判断使用的表达式为OGNL表达式。常用的动态SQL标签有&lt;if&gt;、&lt;where&gt;、&lt;chose&#x2F;&gt;、&lt;foreach&gt;等</p>
<h3 id="1、动态的if标签"><a href="#1、动态的if标签" class="headerlink" title="1、动态的if标签"></a>1、动态的if标签</h3><pre class=" language-sql"><code class="language-sql"><span class="token operator">&lt;</span><span class="token keyword">if</span> test<span class="token operator">=</span><span class="token string">"boolean的判断结果"</span><span class="token operator">></span>sql语句<span class="token operator">&lt;</span><span class="token operator">/</span><span class="token keyword">if</span><span class="token operator">></span>
test里面要使用对象的属性值没有<span class="token keyword">else</span>可以多个<span class="token keyword">if</span>
</code></pre>
<p>例子:</p>
<pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectByIf<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.serookie.entity.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>         
   select id,name,email,age from t_student        
   where     
   <span class="token comment" spellcheck="true">&lt;!--test里面只能用对象的属性值--></span>         
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name !<span class="token punctuation">=</span>null and name !<span class="token punctuation">=</span><span class="token punctuation">'</span><span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>             
     name=#{name}         
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>         
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>age<span class="token punctuation">></span>0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>             
     or age =#{age}         
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>     
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>
</code></pre>
<h3 id="2、where标签"><a href="#2、where标签" class="headerlink" title="2、where标签"></a>2、where标签</h3><p>where标签</p>
<p>使用if标签时,容易引起sql语句语法错误。使用where标签解决if产生的语法问题。</p>
<p>使用where,里面是一个或多个if标签,当有一个if标签判断条件为true，where标签会转为where关键字附加到sql语句的后面。如果if没有一个条件为true,忽略where和里面的if。</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>where</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>boolean<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>where</span><span class="token punctuation">></span></span>  
</code></pre>
<h3 id="3、forEach循环"><a href="#3、forEach循环" class="headerlink" title="3、forEach循环"></a>3、forEach循环</h3><p>foreach循环可以用来循环数组，list集合。一般用在in里居多。</p>
<p>语法：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>集合类型<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>开始的字符<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>结束的字符<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>集合中的成员<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>集合成员之间的分隔符<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  #{item的值}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span><span class="token punctuation">></span></span>
</code></pre>
<p>标签属性:<br>  collection:表示循环的对象是数组，还是list集合。如果dao接口方法的形参是数组，collection&#x3D;”array”,<br>  如果接口的形参是list,collection&#x3D;”list”<br>  open:循环开始时的字符<br>  close:循环结束的字符<br>  separator：集合成员之间的分隔符。<br>  #{item的值}:获取集合成员的值。</p>
<p>例子:</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectIn<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.serookie.entity.Student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  
    select id,name,email,age from t_student where id in         
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ids<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>            #{ids}        
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">></span></span>     
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">></span></span>
</code></pre>
<h3 id="4、SQL标签"><a href="#4、SQL标签" class="headerlink" title="4、SQL标签"></a>4、SQL标签</h3><p>sql标签标示一段sql代码,可以是表名,几个字段,where条件都可以,可以在其他地方复用sql标签的内容。</p>
<p>使用方式:</p>
<p>1）在mapper文件定义sql代码片段&lt;sql id&#x3D;”唯一字符串”&gt;部分sql语句&lt;sql&gt;</p>
<p>2）在其他的位置，使用include标签引用某个代码片段。</p>
<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--    定义代码片段--></span>    
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectStudent<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>
  select * from t_student    
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>sql</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>studentList<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>       
  id,name,email,age   
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>sql</span><span class="token punctuation">></span></span>

<span class="token comment" spellcheck="true">&lt;!--引用sql片段--></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>selectStudent<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>include</span><span class="token punctuation">></span></span>
</code></pre>
<h2 id="10、MyBatis的缓存"><a href="#10、MyBatis的缓存" class="headerlink" title="10、MyBatis的缓存"></a>10、MyBatis的缓存</h2><p>MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 为了使它更加强大而且易于配置，我们对 MyBatis 3 中的缓存实现进行了许多改进。</p>
<p>MyBatis系统中默认定义了两级缓存:一级缓存和二级缓存。</p>
<ul>
<li>默认情况下，只有一级缓存(SqlSession级别的缓存,也称为本地缓存)开启。</li>
<li>二级缓存需要手动开启和配置，他是基于namespace级别的缓存。</li>
<li>为了提高扩展性。MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。</li>
</ul>
<blockquote>
<p>一级缓存:</p>
<p>本地缓存：sqlsession级别的缓存。一级缓存是一直开启的，与数据库同一次会话期间查询到的数据会放在本地缓存中。以后如果需要获取相同的数据，直接从缓存中拿,没必要再去查询数据库。</p>
</blockquote>
<p>一级缓存的失效情况:</p>
<ol>
<li>sqlsession不同</li>
<li>sqlsession相同,查询条件不同</li>
<li>sqlsession相同,两次查询之间执行了增删改操作。</li>
<li>sqlsession相同,手动清除了一级缓存（缓存清空）</li>
<li>clearCache方法可以清空缓存。</li>
</ol>
<p>eviction的缓存的回收策略:</p>
<p>1、LRU:最近最少使用的，移除最长时间不被使用的对象。</p>
<p>2、FIFO:先进先出，按对象进入缓存的顺序来移除它们</p>
<p>3、Soft:软引用，当我们的内存空间不足的时候，会移除我们的软引用对象。</p>
<p>4、weak:弱引用:当我们的垃圾回收的时候，会进行移除。</p>
<h2 id="11、MyBatis的实现分页的几种方式"><a href="#11、MyBatis的实现分页的几种方式" class="headerlink" title="11、MyBatis的实现分页的几种方式"></a>11、MyBatis的实现分页的几种方式</h2><p>1、直接在select语句上增加数据库的提供的分页关键字，然后再引用程序里面传递当前页，以及每页展示条数即可。</p>
<p>2、使用Mybatis提供的RowBounds对象，实现内存级别的分页，当这个对象它会一次性记载全部的数据到java内存中。不是很适合我们的数据量比较大的场景</p>
<p>3、使用我们的mybatis的拦截器去进行拦截，在每次在执行我们的select语句，给它拦截下来动态拼接上limit语句即可。</p>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="1、什么是Spring"><a href="#1、什么是Spring" class="headerlink" title="1、什么是Spring"></a>1、什么是Spring</h2><ul>
<li>Spring是轻量级的开源框架。</li>
<li>Spring可以解决企业应用开发的复杂性</li>
<li>Spring的两个核心为ICO和AOP<ul>
<li>IOC:控制反转，将创建对象的权利交给IOC容器来帮我们进行创建和管理</li>
<li>AOP:面向切面编程,在不修改原有代码的基础上对功能进行增强</li>
</ul>
</li>
</ul>
<h2 id="2、什么是IOC"><a href="#2、什么是IOC" class="headerlink" title="2、什么是IOC"></a>2、什么是IOC</h2><p>Spring的IOC意思为控制反转，它不是什么技术，而是一种设计思想。它是将你设计好的对象交给Spring容器来控制，而不是交给我们的来管理对象的生命周期等。</p>
<blockquote>
<p>扩展:问题一 谁控制了谁？控制了什么</p>
<p>传统的面向对象思想对于构造对象最简单的方法无非就是在对象内部通过new对对象进行创建，是程序主动去创建依赖对象。<br>但IOC不同，IOC是专门有一个容器来创建、初始化这些对象，这些对象被称为Bean。</p>
<p>谁控制谁？ 是IOC容器控制住了对象，控制了什么？ 控制了bean的生命周期。</p>
<p>问题二:为何是反转，那方面反转了</p>
<p>有反转就有正转，面向对象思想就是有我们在自己的对象中主动控制去直接获取依赖对象，这就是正转。而反转就是由Spring容器来创建及注入依赖对象。<strong>为何是反转？</strong> <code>因为有容器来自动的帮我们查找及注入依赖对象，对象只是被动的接受依赖对象</code>，所以是反转。</p>
<p><strong>哪方面反转了？</strong> <code>依赖对象的获取被反转了。</code></p>
</blockquote>
<h2 id="3、DI依赖注入"><a href="#3、DI依赖注入" class="headerlink" title="3、DI依赖注入"></a>3、DI依赖注入</h2><p>IOC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI来实现的。</p>
<p>在生产bean的过程中，需要解决bean之间的依赖问题，才引入了依赖注入(DI)这种技术。也就是说依赖注入是beanFactory生产bean时为了解决bean之间的依赖的一种技术而已。</p>
<p>通常,依赖注入可以通过三种方式完成，即:</p>
<ul>
<li>构造函数注入</li>
<li>setter注入</li>
<li>接口注入</li>
</ul>
<p>在Spring Framework中，仅使用构造函数和setter注入。</p>
<h2 id="4、Spring中Bean是如何生成的"><a href="#4、Spring中Bean是如何生成的" class="headerlink" title="4、Spring中Bean是如何生成的"></a>4、Spring中Bean是如何生成的</h2><p>Spring的本质就是一个Bean工作或者说bean容器，他按照我们的需求创作出各种各样的bean。</p>
<p><strong>beanFactory</strong>会在bean的生命周期的各个阶段中对bean进行各种管理，并且spring将这些阶段通过各种接口暴露给我们，让我们可以对<code>bean</code>进行各种处理，我们只要让bean<strong>实现对应的接口</strong>，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。</p>
<p>BeanFactory和ApplicationContext:</p>
<p>在 spring 容器中，BeanFactory 接口是 IOC 容器要实现的最基础的接口，定义 了管理 bean 的最基本的方法。主要是面向spring框架本身,不支持AOP和web功能. 在获取bean时才会创建bean 。</p>
<p>ApplicationContext 继承BeanFactory接口,对功能进行扩展. 支持aop,web等插件,面向开发层面, 可以在框架启动时,就可以创建bean。如果说BeanFactory是心脏，那么ApplicationContext就是躯体。</p>
<p>区别:</p>
<ul>
<li>BeanFactory是懒式加载，就是你不使用它，它是不会去进行记载的。当你需要使用它的时候，才会进行记载。</li>
<li>ApplicationContext:是饿汉式加载，就是在程序创建之初，就会将我们的所需的类，全部加载，并且初始化。</li>
<li>BeanFactory内部容器，如歌使用它的话，其实是没有很多功能的，比如说:不会主动去加载和调用BeanFactory后置处理器，不会主动添加Bean后置处理器，不支持aop、web等功能，都是不支持的。</li>
</ul>
<p>优缺点:</p>
<ul>
<li>BeanFactory是懒式加载的，所以在启动程序的时候，加载的速度会比较快。</li>
<li>ApplicationContext:所有的Bean在启动的时候都进行记载，系统运行的速度快。</li>
</ul>
<p>缺点:</p>
<ul>
<li>ApplicationContext：把费时的操作放到系统启动中完成，所有的对象都是预加载的，缺点就是内存占用较大。</li>
<li>BeanFactory：运行速冻相对来说慢一些。</li>
</ul>
<h2 id="5、Bean的生命周期"><a href="#5、Bean的生命周期" class="headerlink" title="5、Bean的生命周期"></a>5、Bean的生命周期</h2><p><img src="https://img-blog.csdnimg.cn/f69223ba207b47099cc543e9ea3b3146.png" alt="在这里插入图片描述"></p>
<p>1、创建bean实例，通过我们的FactoryMethod方式，去创建我们的bean的实例。</p>
<p>2、会调用BeanPostProcess，去对我们的bean做一些功能的增强。</p>
<p>3、加载AutowiredAnnotationBeanPostProcessor，来进行构造。</p>
<p>4、会采用我们的默认的无参构造，即使是这个参数被private进行修饰，它会暴力破解。</p>
<p>5、依赖注入:</p>
<ul>
<li>AutowiredAnnotationBeanPostProcessor:识别@Autowired及@Value标注的成员变量，封装为InjectionMetadata进行依赖注入</li>
<li>CommonAnnotitionBeanPostProcessor注解:识别@Resource标注的成员，封装为InjectionMetadata进行依赖注入</li>
<li>AUTOWIRED_BY_NAME：根据名称匹配</li>
<li>AUTOWIRED_BY_TYPE：根据类型进行匹配</li>
</ul>
<p>6、初始化:</p>
<ul>
<li>处理我们的Aware接口,包括我们的BeanNameAware，BeanFactoryAware等</li>
<li>@PostConstruct:由CommonAnnotationBeanPostProcessor解析。解析完成之后可以执行对应的方法。</li>
<li>InitializingBean:通过接口回调执行初始化,实现afterPropertiesSet方法</li>
<li>Init-method：根据我们的Beanfintion得到的初始化方法执行初始化</li>
<li>创建Aop代理：AnnotationAwareAspectJAutoProxyCreate创建，执行时机再postProcessorAfterInialization</li>
<li>顺序就是先执行我们的@Aware、@PostConstruct、InitializingBean、最后回去执行我们的init-method</li>
</ul>
<p>7、判断并登记可销毁的Bean</p>
<ul>
<li>实现的DispostableBean或AutoClosealbe接口，则为可销毁的bean</li>
<li>自定义destoryMethod,则为可销毁bean</li>
<li>采用@Bean没有指定destroyMethod，则采用自动推断方式获取销毁方法名</li>
<li>@PreDestory标注的方法。</li>
</ul>
<h2 id="6、Bean的作用域"><a href="#6、Bean的作用域" class="headerlink" title="6、Bean的作用域"></a>6、Bean的作用域</h2><p>Bean的作用域主要分为:</p>
<table>
<thead>
<tr>
<th align="center">取值范围</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">singleton</td>
<td align="center">单例(默认)</td>
</tr>
<tr>
<td align="center">prototype</td>
<td align="center">多例的</td>
</tr>
<tr>
<td align="center">request</td>
<td align="center">web项目中，Spring创建一个Bean的对象，将对象存入到request域中</td>
</tr>
<tr>
<td align="center">session</td>
<td align="center">web项目中，Spring创建一个Bean的对象，将对象存入到session域中</td>
</tr>
<tr>
<td align="center">global-session</td>
<td align="center">web项目中，应用在Portlet环境，如果没有Portlet环境那么globalSession相当于session</td>
</tr>
</tbody></table>
<p>可以使用Scope属性，来指定Bean对象的作用范围。</p>
<h2 id="7、Spring提供了哪些配置方式"><a href="#7、Spring提供了哪些配置方式" class="headerlink" title="7、Spring提供了哪些配置方式"></a>7、Spring提供了哪些配置方式</h2><p>1、基于xml配置</p>
<p>bean所需的依赖项和服务在xml格式的配置文件中指定，这些配置文件通常包含许多bean定义和特定于应用程序的配置选项。它们通常以bean标签开头。例如:</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>student<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.kevintam.student<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>name<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>张三<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">></span></span>  
</code></pre>
<p>2、基于注解配置</p>
<p>你可以通过在相关的类，方法或字段声明上使用注解，将bean配置为组件类本身，而不是使用xml来描述bean装配。默认情况下，spring容器中未打开注解装配。因此，你需要在使用它之前在Spring配置文件中启用它。例如：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">context:</span>annotation-config</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">context:</span>annotation-config</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">></span></span>
</code></pre>
<p>3、基于Java API配置</p>
<p>Spring的java配置是通过使用@Bean和@Configuration来实现。</p>
<ol>
<li>@Bean注解与&lt;Bean&gt;元素相同的角色。</li>
<li>@COnfiguation类允许通过简单地调用同一个类中的其他@Bean方法来定义bean间的依赖关系。</li>
</ol>
<h2 id="8、将一个类声明为Spring的bean的注解有哪些？"><a href="#8、将一个类声明为Spring的bean的注解有哪些？" class="headerlink" title="8、将一个类声明为Spring的bean的注解有哪些？"></a>8、将一个类声明为Spring的bean的注解有哪些？</h2><p>我们一般使用@Autowired注解自动装配bean，要想把类标识成可用于@Autowired注解自动装配的 bean的类，采用以下注解可实现：</p>
<ul>
<li>@Component：通用的注解，可标注任意类为Spring组件。如果一个Bean不知道属于哪个层， 可以使用@Component注解标注。</li>
<li>@Repository：对应持久层即Dao层，主要用于数据库相关操作。</li>
<li>@Service：对应服务层，主要涉及一些复杂的逻辑，需要用到Dao层。</li>
<li>@Controller：对应Spring MVC控制层，主要用户接受用户请求并调用Service层返回数据给前端 页面。</li>
</ul>
<h2 id="9、什么是Spring装配？"><a href="#9、什么是Spring装配？" class="headerlink" title="9、什么是Spring装配？"></a>9、什么是Spring装配？</h2><p>当bean在Spring容器中组合在一起时，它被称为装配或bean装配。Spring容器需要知道需要什么 bean以及容器应该如何使用依赖注入来将bean绑定在一起，同时装配bean。</p>
<p>Spring容器能够自动装配bean。也就是说，可以通过检查BeanFactory的内容让Spring自动解析 bean的协作者。<br>自动装配的不同模式：</p>
<ul>
<li>no-这是默认设置，表示没有自动装配。应使用显式bean引用进行装配。</li>
<li>byName-它根据bean的名称注入对象依赖项。它匹配并装配其属性与XML文件中由相同名称定义的bean。</li>
<li>byType- 它根据类型注入对象依赖项。如果属性的类型与XML文件中的一个bean名称匹配，则匹配并装配属性。</li>
<li>构造函数·它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>
<li>autodetect-首先容器尝试通过构造函数使用autowire装配，如果不能，则尝试通过byType自 动装配。</li>
</ul>
<h2 id="10、自动装配有什么局限"><a href="#10、自动装配有什么局限" class="headerlink" title="10、自动装配有什么局限"></a>10、自动装配有什么局限</h2><ul>
<li>只能使用引用数据类型，基本元数据类型-简单属性无法自动装配的。</li>
<li>覆盖的可能性-您始终可以使用&lt;constructor-arg&gt;和&lt;property&gt;设置指定依赖项，这就讲覆盖自动装配。</li>
</ul>
<h2 id="11、Spring这么解决循环依赖问题？"><a href="#11、Spring这么解决循环依赖问题？" class="headerlink" title="11、Spring这么解决循环依赖问题？"></a>11、Spring这么解决循环依赖问题？</h2><p>什么是循环依赖:</p>
<p>A的某个field或者setter依赖了Bean的实例对象，同时B的某个field或者setter依赖了A的实例对象这样就产生了循环依赖。</p>
<p>Spring对依赖的处理有三种情况:</p>
<p>①构造器的循环依赖：这种依赖spring是处理不了的，直接抛出Bean CurrentlylnCreationException异 常。</p>
<p>②单例模式下的setter循环依赖：通过“三级缓存“处理循环依赖。</p>
<p>③非单例循环依赖：无法处理。</p>
<p>下面分析单列模式下的setter循环依赖如何解决</p>
<p>Spring的单列对象的初始化主要分为三步:</p>
<p><img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230430233553715.png" alt="image-20230430233553715"></p>
<ul>
<li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象。</li>
<li>populateBean:填充属性，这一步主要是多bean的依赖属性进行填充。</li>
<li>InitializeBean:调用Spring.xml中的init方法</li>
</ul>
<p>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。</p>
<table>
<thead>
<tr>
<th align="center">缓存</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">singletonObject</td>
<td>用于存放完成初始化好的bean，从该缓存中取出的bean可以直接使用</td>
</tr>
<tr>
<td align="center">early SingletonObjects</td>
<td>存放原始的bean对象(尚未填充属性)，用于解决循环依赖</td>
</tr>
<tr>
<td align="center">singletonFactories</td>
<td>存放bean工厂对象，用于解决循环依赖</td>
</tr>
<tr>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<p>举例：A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象“这<br>种循环依赖的情况。A首先完成了</p>
<p>初始化的第一步(createBeanlNstance实例化)，并且将自己提前曝光到singletonFactories中。</p>
<p>此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走 create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存 singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects(也没 有)，尝试三级缓存singletonFactories，。由于A通过ObjectFactory将自己提前曝光了，所以B能够通过</p>
<p>ObjectFactory.getObject：拿到A对象（虽然A还没有初始化完全，但是总比没有好呀），B拿到A对象后顺利 完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。<br>此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了<br>级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对 象完成了初始化。</p>
<h2 id="12、Spring中的单例bean的线程安全问题？"><a href="#12、Spring中的单例bean的线程安全问题？" class="headerlink" title="12、Spring中的单例bean的线程安全问题？"></a>12、Spring中的单例bean的线程安全问题？</h2><p>当多个用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求对应的业务逻辑,此时就要注意了，如果该处理逻辑中有对单例状态的修改,则必须考虑线程同步问题。</p>
<p>线程安全问题都是由全局变量及静态变量引起的。</p>
<p>若每个线程中对全局变量、静态变量只有只读操作，而无写操作，一般来说，这个全局变量是线程安全的,若有多个线程同时执行写操作，一般是需要考虑线程同步，否者就可能影响线程安全。</p>
<p>无状态bean和有状态bean</p>
<ul>
<li>有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数 据，是非线程安全的。在不同方法调用间不保留任何状态。</li>
<li>无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象。不能保存数据，是不变类，是线程安全的。</li>
</ul>
<p>在spring中无状态的Bean适合用不变模式，就是单例模式，这样可以共享实例提高性能。有状态的Bean在多线程环境下不安全，适合用Prototype。原型模式。<br>Spring使用ThreadLocal解决线程安全问题。如果你的Bean有多种状态的话（比如View Model对 象)，就需要自行保证线程安全。</p>
<h2 id="13、Spring中-Autowired和-Resource有什么区别？"><a href="#13、Spring中-Autowired和-Resource有什么区别？" class="headerlink" title="13、Spring中@Autowired和@Resource有什么区别？"></a>13、Spring中@Autowired和@Resource有什么区别？</h2><p>1、@Autowired和@Resource都是可以使用我们的自动装配。</p>
<p>2、@Autowired是Spring自带的，而@Resource是java自带的类。</p>
<p>3、@Autowired自动装配默认选择的是byType基于我们的类型注入，而我们的@Resource默认选择的是byName基于我们的名称来进行注入的。但是@Resource可以选择使用byType。</p>
<ul>
<li><strong>@Autowired 先根据类型（byType）查找，如果存在多个（Bean）再根据名称（byName）进行查找；</strong></li>
<li><strong>@Resource 先根据名称（byName）查找，如果（根据名称）查找不到，再根据类型（byType）进行查找。</strong></li>
</ul>
<h2 id="14、什么是AOP"><a href="#14、什么是AOP" class="headerlink" title="14、什么是AOP"></a>14、什么是AOP</h2><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p>在OOP中，我们以类(class)作为我们的基本单元，而AOP中的基本单元是Aspect(切面)</p>
<h2 id="15、AOP的实现方式"><a href="#15、AOP的实现方式" class="headerlink" title="15、AOP的实现方式"></a>15、AOP的实现方式</h2><p>实现Aop的技术，主要分为两大类:</p>
<ul>
<li>静态代理-指使用aop框架提供的命令进行编译，从而在编译阶段就可生成aop代理类，因此也称为编译时增强。<ul>
<li>编译时编织</li>
<li>类加载时编织</li>
</ul>
</li>
<li>动态代理-在运行时在内存中”临时”生成AOP动态代理类，因此也被称为运行时增强。<ul>
<li>JDK的proxy类，Proxy.newProxyInstance(classloader,class[],InvocationHandler()) 只能使用接口,并且必须实现该接口</li>
<li>基于cglib动态代理Enhance 继承我们的MethodInterceptor。</li>
</ul>
</li>
</ul>
<blockquote>
<p>扩展 aop的专业术语：</p>
<ol>
<li>切面(Aspect)</li>
</ol>
<p>切面泛指交叉业务逻辑。上例中的事务处理、日志处理就可以理解为切面。常用的切面是通知（Advice）。实际就是对主业务逻辑的一种增强。</p>
<ol start="2">
<li><p>连接点（JoinPoint）</p>
<p>连接点指可以被切面织入的具体方法。通常业务接口中的方法均为连接点。</p>
</li>
<li><p>切入点（Pointcut）</p>
<p>切入点指声明的一个或多个连接点的集合。通过切入点表达式指定一组方法。被标记为 final 的方法是不能作为连接点与切入点的。因为最终的是不能被修改的，不能被增强的。</p>
</li>
<li><p>目标对象（Target）</p>
<p>目标对象指将要被增强的对象。即包含主业务逻辑的类的对象。上例中的StudentServiceImpl 的对象若被增强，则该类称为目标类，该类对象称为目标对象。当然，不被增强，也就无所谓目标不目标了。</p>
</li>
<li><p>通知（Advice）</p>
<p>通知表示切面的执行时间，Advice 也叫增强。上例中的MyInvocationHandler 就可以理解为是一种通知。换个角度来说，通知定义了增强代码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。</p>
</li>
</ol>
<p>切入点定义切入的位置，通知定义切入的时间。</p>
</blockquote>
<h2 id="16、AspectJ的通知类型"><a href="#16、AspectJ的通知类型" class="headerlink" title="16、AspectJ的通知类型"></a>16、AspectJ的通知类型</h2><p>AspectJ 中常用的通知有五种类型：</p>
<ol>
<li>前置通知(Before-advice):在目标方法被调用之前做增强处理,@Before只需要指定切入点表达式即可</li>
<li>后置通知(after-advice):在目标方法完成之后做增强，无论目标方法是否成功完成。@After可以指定一个切入点表达式</li>
<li>异常通知(AfterThrowing):主要用来处理程序中未处理的异常,@AfterThrowing除了指定切入点表达式后，还可以指定一个throwing的返回值形参名,可以通过该形参名来访问目标方法中所抛出的异常对象</li>
<li>环绕通知(Around):环绕通知,在目标方法完成前后做增强处理,环绕通知是最重要的通知类型,像事务,日志等都是环绕通知.</li>
<li>返回通知(也叫作最终通知AfterReturning):在目标方法正常完成后做增强,@AfterReturning除了指定切入点表达式后，还可以指定一个返回值形参名returning,代表目标方法的返回值</li>
</ol>
<h2 id="17、Spring的中用到了哪些设计模式？"><a href="#17、Spring的中用到了哪些设计模式？" class="headerlink" title="17、Spring的中用到了哪些设计模式？"></a>17、Spring的中用到了哪些设计模式？</h2><p>工厂设计模式:spring就是通过BeanFactory来创建bean对象的。</p>
<p>代理设计模式:AOP功能的使用。</p>
<p>单列模式:Spring中的bean默认都是单例的，也就是在ioc容器中，只会存在一个。</p>
<p>模版方法模式:Spring中JDBCTemplate等以Template结尾的都是使用了模版模式。</p>
<p>观察者模式:Spring事件驱动模型就是观察者模式</p>
<p>适配器模式:SpringAop的增强或通知使用了适配器模式，SpringMVC中使用到了适配器模式适配我们的controller。</p>
<h2 id="18、Spring事务实现的方式有哪些"><a href="#18、Spring事务实现的方式有哪些" class="headerlink" title="18、Spring事务实现的方式有哪些?"></a>18、Spring事务实现的方式有哪些?</h2><p>在Spring中通常可以通过以下两种方式来实现对事务的管理:</p>
<ul>
<li>声明式事务管理:这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。</li>
<li>编程式事务管理:这意味你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</li>
</ul>
<p>使用编程式的方式去实现实现事务,底层就是使用PlatformTransactionManager、使用TransactionTemplate</p>
<p>需要去调用beginTransaction去开启事务。</p>
<blockquote>
<p>扩展:</p>
<p>Spring 的事务管理，主要用到两个事务相关的接口。</p>
<p>1）事务管理器接口(重点)</p>
<p>事务管理器是 PlatformTransactionManager 接口对象。其主要用于完成事务的提交、回滚，及获取事务的状态信息。</p>
<p>常用的两个实现类：</p>
<p>PlatformTransactionManager 接口有两个常用的实现类：</p>
<ul>
<li>DataSourceTransactionManager：使用 JDBC 或 MyBatis 进行数据库<br>操作时使用。</li>
<li>HibernateTransact ionManager：使用 Hibernate 进行持久化数据时使<br>用。</li>
</ul>
<p>2）事务管理器的工作方式 AOP的环绕通知，在方法执行之前去开启事务begin start Transcaction</p>
<p>在方法结束之后，去执行我们的commit和rollback操作进行回滚.</p>
<p>Spring 的回滚方式(理解)</p>
<p>什么是提交事务,什么时候回滚事务?</p>
<p>当你的业务方法正常执行时,没有异常,事务是提交的。如果你的业务方法抛出了运行时异常,事务是回滚的。</p>
<p>异常分类:</p>
<p>Error:严重错误。回滚事务。</p>
<p>Exception:异常类,可以出来的异常情况。</p>
<p>1)运行时异常:RuntimeException和它的子类都是运行时异常,在程序执行过程中抛出的异常。</p>
<p>2)编译时异常:编写java代码的时候,必须出来的异常。例如IOException等。</p>
<p>4、spring事务的机制使用的aop的环绕通知</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"execution(* com.serookie.entity.Student.add(..))"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Around</span><span class="token punctuation">(</span>ProceedingJoinPoint point<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>
        <span class="token keyword">try</span><span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"环绕通知开启......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        PlatformTransactionManager<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行spring事务开启</span>
        point<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行目标对象的方法</span>
        <span class="token comment" spellcheck="true">//在这里使用事务开启</span>
        PlatformTransactionManager<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//提交事务</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"环绕通知结束......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span><span class="token punctuation">{</span>
            PlatformTransactionManager<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//出现异常 立马回滚</span>
        <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre>
<p>事务的编程式实现方式:</p>
<ul>
<li>TransactionDefinition+PlatfromTransactionManager实现我们的编程式事务</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        DefaultTransactionDefinition definition <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultTransactionDefinition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//设置事务的状态信息，比如事务的隔离级别、事务的是否只读、事务的传播行为、事务的超时</span>
<span class="token comment" spellcheck="true">//        definition.setTimeout();</span>
        <span class="token comment" spellcheck="true">//事务的隔离级别 mysql的默认隔离级别 读一提交</span>
        definition<span class="token punctuation">.</span><span class="token function">setIsolationLevel</span><span class="token punctuation">(</span>TransactionDefinition<span class="token punctuation">.</span>ISOLATION_READ_COMMITTED<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//事务是否只读</span>
<span class="token comment" spellcheck="true">//        definition.setReadOnly();</span>
        definition<span class="token punctuation">.</span><span class="token function">setPropagationBehavior</span><span class="token punctuation">(</span>TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_REQUIRED<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">//事务状态信息管理</span>
        TransactionStatus transaction <span class="token operator">=</span> platformTransactionManager<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span>definition<span class="token punctuation">)</span><span class="token punctuation">;</span>
        JdbcTemplate jdbcTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JdbcTemplate</span><span class="token punctuation">(</span>dataSource<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            jdbcTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token string">"select * from emp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            platformTransactionManager<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>transaction<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            platformTransactionManager<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span>transaction<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre>
<ul>
<li>使用我们的TransactionTemplate实现我们的编程式事务,因为该类继承了DeaultTransactionDefinition，所以可以使用Transactiontemplate。</li>
</ul>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionConfig</span> <span class="token keyword">implements</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> TransactionTemplate transactionTemplate<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        transactionTemplate<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TransactionCallback</span><span class="token operator">&lt;</span>Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> Object <span class="token function">doInTransaction</span><span class="token punctuation">(</span>TransactionStatus transactionStatus<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">//写我们的代码逻辑</span>
                <span class="token comment" spellcheck="true">//xxxxx sql执行语句</span>
                <span class="token comment" spellcheck="true">//表示标识为回滚</span>
                transactionStatus<span class="token punctuation">.</span><span class="token function">setRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> null<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</blockquote>
<h2 id="19、事务定义接口TransactionDefinition"><a href="#19、事务定义接口TransactionDefinition" class="headerlink" title="19、事务定义接口TransactionDefinition"></a>19、事务定义接口TransactionDefinition</h2><p>事务定义接口 TransactionDefinition 中定义了事务描述相关的三类常量：事务隔离级别、事务传播行为、事务默认超时时限，及对它们的操作。</p>
<p>1）隔离级别:控制事务之间影响的程度</p>
<p>定义了五个事务隔离级别常量(掌握),当是只有四个隔离级别的。</p>
<p>这些常量均是以 ISOLATION(爱sou类型)_开头。即形如 ISOLATION_XXX。</p>
<ol>
<li>DEFAULT ： 采 用 DB 默 认 的 事 务 隔 离 级 别 。 MySql 的 默 认 为<br>REPEATABLE_READ； Oracle 默认为 READ_COMMITTED。</li>
<li>READ_UNCOMMITTED：读未提交。未解决任何并发问题。</li>
<li>READ_COMMITTED：读已提交。解决脏读，存在不可重复读与幻读。</li>
<li>REPEATABLE_READ：可重复读。解决脏读、不可重复读，存在幻读</li>
<li>SERIALIZABLE：序列化。不存在并发问题。</li>
</ol>
<p>2）超时时间</p>
<p>超时时间,以秒为单位。整数值。默认是-1</p>
<p>超时时间：表示一个业务方法最长的执行时间，没有到达时间没有执行完毕，spring回滚事务。 </p>
<p>3）传播行为</p>
<p>所谓事务传播行为是指，处于不同事务中的方法在相互调用时，执行期间事务的维护情况。如，A 事务中的方法doSome()调用 B 事务中的方法doOther()，在调用执行期间事务的维护情况，就称为事务传播行为。事务传播行为是加在方法的。</p>
<p>事务传播行为常量都是以 PROPAGATION_ 开头，形如PROPAGATION_XXX。</p>
<p>1）REQUIRED:spring默认传播行为,方法在调用的时候,如果存在事务就是使用当前的事务，如果没有事务，则新建事务，方法在新事物中执行。</p>
<p>2）SUPPORTS：支持,方法有事务可以注册执行，没有事务也可以正常执行。</p>
<p>3）REQUIRES_NEW:方法需要一个事务。如果调用方法时,存在一个事务，则原来的事务暂停。直到新事务执行完毕。如果方法调用时，没有事务，则新建一个事务,在新事务执行代码。</p>
<h2 id="20、Spring事务的失效的场景"><a href="#20、Spring事务的失效的场景" class="headerlink" title="20、Spring事务的失效的场景"></a>20、Spring事务的失效的场景</h2><ol>
<li><p>使用我们的检查异常的时候，会导致我们的事务失效。如果是runtimeException也就是非检查异常才会去回滚事务。怎么解决:在Transactional里加入rollbackFor&#x3D;Exception.class</p>
</li>
<li><p>业务方法内自己try-catch异常导致食物不能正确回滚</p>
<p>原因:事务通知只有捉到了目标抛出的异常，才能进行后续的回滚处理，如果目标自己处理掉异常，事务通知不法知晓。</p>
<p>解决方法:你try-catch之后，在将异常抛出去。</p>
<p>手动设置TransactionStatus.setRollbackOnly()，进行手动的抛出。</p>
</li>
<li><p>AOP切面顺序导致顺序导致事务不能正确回滚。</p>
<p>原因:事务切面优先级最低，但如果自定义的切面优先级和他一样，则还是自定义切面的在哪层，这时若自定义切面没有正确抛出异常….</p>
<p>解决方案:和第二种一样</p>
<p>但是也可以调整我们的切面的执行顺序,使用@order进行调整。</p>
</li>
<li><p>spring规定的事务必须使用public进行修饰。</p>
</li>
<li><p>调用本类方法导致传播行为失效</p>
<p>原因:本类方法调用不经过代理，因此无法增强。</p>
<p>解决方案:</p>
<p>1、依赖注入，将我们类进行注入</p>
<p>2、通过AopCOntent。currentProxt.获取当前的代理类，去调用改方法。</p>
</li>
<li><p>@Transactional没有保证原子行为</p>
<p>原因:事务的原子性仅涵盖insert、update、delete、select 。。。for update，select方法并不阻塞。</p>
<p>@Transactional方法导致的synchronized失效。</p>
<p>原因:synchronzied保证的仅是目标的原子性，环绕目标方法还有commit等操作，它们并未处于sync块内</p>
<p>解法1:synchronzied范围应扩大至代理方法调用</p>
<p>解法2:使用seelct。。。for update替换select。</p>
</li>
<li><p>事务的传播行为,导致事务失效</p>
<p>REQUIRED(0), 1、支持当前事务。如果当前没有事务，就新建一个事务这是最常见的<br>SUPPORTS(1), 2、支持当前事务。如果当前没有事务，就以非事务方式运行。<br>MANDATORY(2), 3、支持当前事务。如果当前没有事务，则会抛出异常<br>REQUIRES_NEW(3),4、新建事务，如果当前存在事务，则把当前事务进行挂起<br>NOT_SUPPORTED(4),5、非事务的方式，如果当前存在事务，就把当前事务进行挂起<br>NEVER(5), 6、非事务的方式，如果当前存在事务，则抛出异常<br>NESTED(6);7、如果当前存在事务，则在嵌套事务内执行</p>
</li>
</ol>
<h1 id="SpringMVC篇"><a href="#SpringMVC篇" class="headerlink" title="SpringMVC篇"></a>SpringMVC篇</h1><h2 id="1、什么是SpringMVC"><a href="#1、什么是SpringMVC" class="headerlink" title="1、什么是SpringMVC"></a>1、什么是SpringMVC</h2><p>SpringMVC是基于Spring的，是spring中的一个模块,做web开发使用的。SpringMvc叫做SpringWebMvc说明他是spring的核心技术,做web开发，springmvc内部是使用mvc架构模式。</p>
<p>SpringMvc是一个容器,管理对象，使用IOC核心技术。</p>
<p>SpringMvc底层也是Servlet。以Servlet为核心，接收请求,处理请求。显示处理结果给用户。</p>
<blockquote>
<p>MVC：</p>
<p>Model:数据模型(完成业务逻辑,javaBean构成,service+dao+entity)</p>
<p>view:视图(做界面的展示:jsp、html)</p>
<p>Controller：控制器(接收请求-&gt;调用模型-&gt;返回视图)</p>
</blockquote>
<h2 id="2、SpringMVC的核心Servlet—-gt-dispatcherServlet"><a href="#2、SpringMVC的核心Servlet—-gt-dispatcherServlet" class="headerlink" title="2、SpringMVC的核心Servlet—&gt;dispatcherServlet"></a>2、SpringMVC的核心Servlet—&gt;dispatcherServlet</h2><p>DispatcherServlet是框架一个Servlet对象。负责接收请求，响应处理结果。</p>
<p>DispatcherServlet它的父类是HttpServlet</p>
<p>DispatcherServlet叫做前端控制器</p>
<p>SpringMvc主要使用注解的方式,创建控制器对象，处理请求。</p>
<h2 id="3、SpringMVC的流程"><a href="#3、SpringMVC的流程" class="headerlink" title="3、SpringMVC的流程"></a>3、SpringMVC的流程</h2><p>初始化阶段:</p>
<ol>
<li><p>在web容器第一次用到DispatcharServlet的时候，会创建其对象并执行init方法</p>
</li>
<li><p>init方法会创建SpringMVC容器，并调用容器refresh方法。</p>
</li>
<li><p>refresh过程中创建并初始化SpringMVC中的重要组件，例如MultpartResolver,HandlerMapping，HandlerAdapter，HandlerExceptionResolver、viewResolver等。</p>
</li>
<li><p>容器初始化，会将上一步初始化好的重要组件，赋值给DIspatcherServlet的成员变量，留待后用。</p>
<img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20230225160943986.png" alt="image-20230225160943986" style="zoom:50%;" /></li>
</ol>
<p>匹配阶段:</p>
<p>1、用户发送的请求统一到达前端控制器DispatcharServlet。</p>
<p>2、DispatcharServlet遍历所有HandlerMapping，找到与路径匹配的处理器。</p>
<ul>
<li>Handlermapping有多个，每个HandlerMapping会返回不同的处理器对象，谁先匹配，返回谁的处理器。其中能识别@RequestMapping的优先级最高。</li>
<li>对应@RequestMapping的处理器是HandlerMethod，它包含了控制器对象和控制器方法信息。</li>
<li>其中路径与处理器的映射关系在HandlerMapping初始化就会创建好。</li>
</ul>
<p>3、将Handlermathod连同匹配到的拦截器，生成调用链对像HandlerExecuitionCHain 返回。</p>
<p>4、遍历HandlerAdapter处理器适配器，找到能处理HandlerMethod的适配器对象，开始调用。</p>
<p>执行阶段:</p>
<p>1、执行拦截器preHandle</p>
<p>2、由HandlerAdapter调用HandlerMethod</p>
<ul>
<li>调用前处理不同类型的参数</li>
<li>调用后处理不同类型的返回值</li>
</ul>
<p>3、第二步没有异常</p>
<ul>
<li>返回ModelAndView</li>
<li>执行拦截器postHandle方法</li>
<li>解析视图，得到view对象，进行视图渲染</li>
</ul>
<p>4、第二步有异常，进入HandlerExceptionResolver异常处理流程</p>
<p>5、最后都会执行拦截器的afterComletion方法</p>
<p>6、如果控制器方法标注了@ResponseBody注解，则在第2步，就会生成json结果，并标记ModelAndView已处理，这样就不会执行第3步的视图渲染。</p>
<h2 id="4、简单介绍Spring-MVC的核心组件"><a href="#4、简单介绍Spring-MVC的核心组件" class="headerlink" title="4、简单介绍Spring MVC的核心组件"></a>4、简单介绍Spring MVC的核心组件</h2><ul>
<li>DispatcherServlet：SpringMVC的核心组件，是请求的入口，负责协调各个组件工作</li>
<li>MultipartResolver:内容类型context-type为multipart&#x2F;*的请求的解析器.例如解析处理文件上传的请求，便于获取参数信息以及上传的文件。</li>
<li>HandlerMapping：请求的处理器匹配，负责为请求找到合适的HandlerExecutionChain处理器执行链，包含处理器和拦截器们。</li>
<li>HandlerAdapter:处理器的适配器,因为处理器handler的类型是Object类型,需要有一个调用者来实现handler是怎么被执行。</li>
<li>viewResolver:主题解析器，根据视图名和国际化，获取最终的视图view对象。</li>
</ul>
<h2 id="5、SpringMVC一些重要注解"><a href="#5、SpringMVC一些重要注解" class="headerlink" title="5、SpringMVC一些重要注解"></a>5、SpringMVC一些重要注解</h2><h3 id="5-1-RequestMapping定义请求规则"><a href="#5-1-RequestMapping定义请求规则" class="headerlink" title="5.1 @RequestMapping定义请求规则"></a>5.1 @RequestMapping定义请求规则</h3><p>通过@RequestMapping 注解可以定义处理器对于请求的映射规则。该注解可以注解在方法上，也可以注解在类上，但意义是不同的。value 属性值常以“&#x2F;”开始。</p>
<p>@RequestMapping 的 value 属性用于定义所匹配请求的 URI。但对于注解在方法上与类上，其 value 属性所指定的 URI，意义是不同的。</p>
<p>一个@Controller 所注解的类中，可以定义多个处理器方法。当然，不同的处理器方法所匹配的 URI 是不同的。这些不同的 URI 被指定在注解于方法之上的@RequestMapping 的 value 属性中。但若这些请求具有相同的 URI 部分，则这些相同的 URI，可以被抽取到注解在类之上的@RequestMapping 的value 属性中。此时的这个 URI 表示模块的名称。URI 的请求是相对于 Web 的根目录。</p>
<p>@RequestMapping其中有一个属性为method，用于对被注解方法所处理请求的提交方式进行限制。</p>
<p>method属性的取值为RequestMethod枚举常量。常用的为RequestMethod.GET与RequestMethod.POST，分别表示提交方式的匹配规则为 GET 与 POST 提交。</p>
<p>@RequestMapping里面的produces属性指定字符集。</p>
<p>例子:</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"xxxx"</span><span class="token punctuation">,</span>produces<span class="token operator">=</span><span class="token string">"application/json"</span><span class="token punctuation">)</span>
</code></pre>
<h3 id="5-2-处理器方法的参数"><a href="#5-2-处理器方法的参数" class="headerlink" title="5.2 处理器方法的参数"></a>5.2 处理器方法的参数</h3><p>SpringMVC处理器方法有四个参数，这些参数会在系统调用时由系统自动赋值，即程序员可在方法内直接使用。</p>
<ul>
<li>HttpServletRequest</li>
<li>HttpServletResponse</li>
<li>HttpSession</li>
<li>请求中所携带的请求参数</li>
</ul>
<blockquote>
<p>如果前端使用的from表单进行提交，我们的处理器方法的参数名称必须与我们的input里面的name属性保持一致。</p>
</blockquote>
<h3 id="5-3-请求参数中文乱码问题"><a href="#5-3-请求参数中文乱码问题" class="headerlink" title="5.3  请求参数中文乱码问题"></a>5.3  请求参数中文乱码问题</h3><p>对于前面所接收的请求参数，若含有中文，则会出现中文乱码问题。Spring 对于请求参数中的中文乱码问题，给出了专门的字符集过滤器：spring-web-5.2.5.RELEASE.jar 的 org.springframework.web.filter 包下的CharacterEncodingFilter 类。</p>
<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--定义编码格式问题--></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-class</span><span class="token punctuation">></span></span>org.springframework.web.filter.CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-class</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>encoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>utf-8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>forceRequestEncoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>init-param</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-name</span><span class="token punctuation">></span></span>forceResponseEncoding<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-name</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>param-value</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>param-value</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>init-param</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-mapping</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>filter-name</span><span class="token punctuation">></span></span>CharacterEncodingFilter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-name</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/*<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>filter-mapping</span><span class="token punctuation">></span></span>
</code></pre>
<p>底层使用就是setCharacterEncoding这个方法。</p>
<h3 id="5-4-校正请求参数名-RequestParam"><a href="#5-4-校正请求参数名-RequestParam" class="headerlink" title="5.4 校正请求参数名@RequestParam"></a>5.4 校正请求参数名@RequestParam</h3><p>所谓校正请求参数名，是指若请求 URL 所携带的参数名称与处理方法中指定的参数名不相同时，则需在处理方法参数前，添加一个注解@RequestParam(“请求参数名”)，指定请求 URL 所携带参数的名称。该注解是对处理器方法参数进行修饰的。value 属性指定请求参数的名称。</p>
<p>@RequestParam属性:1）value，请求中参数名。2）required，boolean类型,默认是true true:表示请求中必须有参数 false:可以没有此参数。</p>
<h3 id="5-5-处理器方法的返回值"><a href="#5-5-处理器方法的返回值" class="headerlink" title="5.5 处理器方法的返回值"></a>5.5 处理器方法的返回值</h3><p>使用@Controller 注解的处理器的处理器方法，其返回值常用的有四种类型：</p>
<ul>
<li>ModelAndView</li>
<li>String</li>
<li>void</li>
<li>返回自定义类型对象</li>
</ul>
<blockquote>
<p>返回对象Object:</p>
<p>处理器方法也可以返回 Object 对象。这个 Object 可以是 Integer，String，自定义对象，Map，List 等。但返回的对象不是作为逻辑视图出现的，而是作为直接在页面显示的数据出现的。返回对象，需要使用@ResponseBody 注解，将转换后的 JSON 数据放入到响应体中。</p>
<p>如果使用了@ResponseBody底层会使用HttpMessageConverter消息转换器接口:</p>
<ul>
<li>实现请求的数据转为java对象</li>
<li>把控制器方法返回的对象转为json、xml、test、二进制等不同格式的数据。</li>
</ul>
<p>HttpMessageConverter接口的实现类:</p>
<ul>
<li>StringHttpMessageConverter：把字符串类型的数据，进行格式装换和编码</li>
<li>MappingJackson2HttpMessageConverter:用jackson工具库的objectMapper把java对象转为json数据格式</li>
</ul>
<p>@ResponseBody的作用，就是把控制器的返回数据转换成json通过HttpServletResponse对象输出给浏览器。</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//输出json，响应ajax</span>
response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"application/json"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Printwriter pw<span class="token operator">=</span>response<span class="token punctuation">.</span><span class="token function">getWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pw<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>
pw<span class="token punctuation">.</span><span class="token function">fiush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pw<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>底层框架处理模式:</p>
<ol>
<li><p>框架会根据控制器方法的返回值类型，找到对应HttpMessageConveter接口的实现类。最后找到的是MappingJackson2HttpMessageConveter。</p>
</li>
<li><p>使用实现类MappingJackson2HttpMessageConveter.。执行他的write()方法，把student对象转为了json格式的数据</p>
</li>
<li><p>框架使用@ResponseBoby注解,把2中的json输出给浏览器。</p>
<p>根据我们的控制器的返回值类型，找到对应的HttpMessageConveter接口的实现类，找到的是MappingJackjson2HttpMessageConveter</p>
<p>如果是字符串可能是StringHttpMessageConverter来进行解析。</p>
</li>
</ol>
</blockquote>
<h3 id="5-6-静态资源的处理"><a href="#5-6-静态资源的处理" class="headerlink" title="5.6 静态资源的处理"></a>5.6 静态资源的处理</h3><ul>
<li><h4 id="第一种处理静态资源的方式"><a href="#第一种处理静态资源的方式" class="headerlink" title="第一种处理静态资源的方式"></a>第一种处理静态资源的方式</h4><p>在springmvc的配置文件加入mvc:default-servlet-handler标签，springmvc框架会在项目运行时,加入DefaultServletHttpRequestHandler对象，让这个对像处理静态资源的访问。</p>
<p>springmvc 框架会在容器中创建 DefaultServletHttpRequestHandler 处理器对象。它会像一个检查员，对进入 DispatcherServlet 的 URL 进行筛查，如果发现是静态资源的请求，就将该请求转由 Web 应用服务器默认的 Servlet 处理。一般的服务器都有默认的Servlet。</p>
<p>在 Tomcat 中，有一个专门用于处理静态资源访问的 Servlet 名叫DefaultServlet。其<servlet-name/>为 default。可以处理各种静态资源访问请求。该 Servlet 注册在 Tomcat 服务器的 web.xml 中。在 Tomcat 安装目录&#x2F;conf&#x2F;web.xml。</p>
</li>
<li><h4 id="第二种处理静态资源的方式"><a href="#第二种处理静态资源的方式" class="headerlink" title="第二种处理静态资源的方式"></a>第二种处理静态资源的方式</h4><p>在springmvc配置文件中加入一个mvc:resources标签,框架会创建ResourceHttpRequestHandler控制器。使用这个对象处理器静态资源的访问。不依赖tomact服务器。</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>resources</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/image/<span class="token punctuation">"</span></span> <span class="token attr-name">mapping</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/image/**<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>resources</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>resources</span> <span class="token attr-name">mapping</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/js/<span class="token punctuation">"</span></span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/js/**<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span><span class="token namespace">mvc:</span>resources</span><span class="token punctuation">></span></span>
</code></pre>
</li>
</ul>
<h2 id="6、-ResController和-Controller有什么区别？"><a href="#6、-ResController和-Controller有什么区别？" class="headerlink" title="6、@ResController和@Controller有什么区别？"></a>6、@ResController和@Controller有什么区别？</h2><p>@RestContro1ler注解，在@Contro1ler基础上，增加了@ResponseBody注解，更加适合目前前 后端分离的架构下，提供Restful API，返回例如JSON数据格式。当然，返回什么样的数据格式，根据客户端的ACCEPT请求头来决定。</p>
<h2 id="7、-RequestMapping和-GetMapping注解的不同之处在哪里？"><a href="#7、-RequestMapping和-GetMapping注解的不同之处在哪里？" class="headerlink" title="7、@RequestMapping和@GetMapping注解的不同之处在哪里？"></a>7、@RequestMapping和@GetMapping注解的不同之处在哪里？</h2><p>1.@RequestMapping:可注解在类和方法上;@GetMapping仅可注册在方法上</p>
<p>2.@RequestMapping:可进行GET、POST、PUT、DELETE等请求方法;@GetMapping是 @RequestMapping的GET请求方法的特例,目的是为了提高清晰度.</p>
<h2 id="8、-RequestParam和-PathVariable两个注解的区别？"><a href="#8、-RequestParam和-PathVariable两个注解的区别？" class="headerlink" title="8、@RequestParam和@PathVariable两个注解的区别？"></a>8、@RequestParam和@PathVariable两个注解的区别？</h2><p>两个注解都是用于方法的参数，获取参数值，@RequestParam注解获取的参数结果从请求携带的参数中获取，而@PathVariable注解从请求的uri中获取。</p>
<h2 id="9、重定向和跳转"><a href="#9、重定向和跳转" class="headerlink" title="9、重定向和跳转"></a>9、重定向和跳转</h2><ul>
<li><p>请求转发可以转发到我们的WEB-INF中的页面。而我们的重定向是不能到WEB-INF中。因为重定向相当于用户再次发出一次请求，而用户是不能直接访问WEB-INF中资源的。</p>
</li>
<li><p>前端uri变化不同，请求转发uri是不变的，而我们的重定向是变化成新的。</p>
</li>
<li><p>请求和重定向最大的不同在于一个是内部转发，一个前端向我们的重新发送一次请求。</p>
</li>
<li><p>实现的方式不同:</p>
<pre class=" language-java"><code class="language-java">forward<span class="token operator">:</span>表示转发，实现就是request<span class="token punctuation">.</span><span class="token function">getRequestDispatchar</span><span class="token punctuation">(</span><span class="token string">"xx.jsp"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forward</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
redirect<span class="token operator">:</span>表示重定向，实现response<span class="token punctuation">.</span><span class="token function">sendRedirect</span><span class="token punctuation">(</span><span class="token string">"xxx.jsp"</span><span class="token punctuation">)</span>
</code></pre>
</li>
</ul>
<h2 id="10、异常处理"><a href="#10、异常处理" class="headerlink" title="10、异常处理"></a>10、异常处理</h2><p>框架使用的是集中的异常处理。把各个Controller中抛出的异常集中在一个地方处理。处理异常的叫做异常处理器。</p>
<p>框架中使用两个注解完成异常的集中处理。这样每个controller不用单独某个类型的异常。当异常发生时，执行这个方法。</p>
<p>1）@ExceptionHandler：放在方法的上面，表示此方法可以处理某个类型的异常。当异常发生时，执行这个方法。</p>
<p>2）@ControllerAdvice：放在类的上面，表示这个类中有异常的处理方法。相当于aop中的@Aspectr</p>
<p>步骤：</p>
<p>1）创建一个异常类 MyException，做为异常的处理类以及子类。</p>
<p>2）在类的上面加入@ControllerAdvice</p>
<p>3）在类中定义方法，每个方法处理对应的异常。方法的上面加入@ExceptionHnadler注解</p>
<p>4）创建处理异常的视图页面</p>
<p>5）在spring中声明扫描器，找到@ControllerAdvice注解的包名</p>
<p>6）声明注解驱动。</p>
<h2 id="11、什么是SpringMVC拦截器以及如何使用它？"><a href="#11、什么是SpringMVC拦截器以及如何使用它？" class="headerlink" title="11、什么是SpringMVC拦截器以及如何使用它？"></a>11、什么是SpringMVC拦截器以及如何使用它？</h2><p>拦截器是SpringMVC框架中的一种对象，需要使用接口HandlerInterceptor，拦截用户的请求。拦截到controller到请求。</p>
<p>作用:拦截用户的请求，可以预先对请求做处理。根据处理结果，决定是否执行controller。也可以把多个controller中共用的功能定义到拦截器。</p>
<p>特点：</p>
<ol>
<li><p>拦截器可以分为系统拦截器和自定义拦截器。</p>
</li>
<li><p>一个项目可以多个拦截器。0，或多个自定义拦截器。</p>
</li>
<li><p>拦截器侧重拦截用户的请求。</p>
</li>
<li><p>拦截器是在请求处理之前先执行的。</p>
</li>
</ol>
<p>拦截器的定义：</p>
<p>1）创建类实现拦截器接口HandlerInterceptor，实现接口中的方法（3个）</p>
<p>2）在springmvc配置文件中，声明拦截器对象，并指定拦截的uri地址</p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
     *  preHandle: 预先处理请求的方法。
     *  参数：
     *     Object handler ： 被拦截的控制器对象（MyController）
     *  返回值： boolean
     *   true: 请求是正确的，可以被controller处理的。
     *     =====MyInterceptor拦截器的preHandle====
     *     执行了MyController的doSome方法
     *     =====MyInterceptor拦截器的postHandle====
     *     =====MyInterceptor拦截器的afterCompletion====
     *   false: 请求不能被处理， 控制器方法不会执行。 请求到此截止。
     *     =====MyInterceptor拦截器的preHandle====
     * 特点：
     *  1. 预处理方法他的执行时间： 在控制器方法之前先执行的。
     *  2. 可以对请求做处理， 可以做登录的检查， 权限的判断， 统计数据等等。
     *  3. 决定请求是否执行。
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>
                             HttpServletResponse response<span class="token punctuation">,</span>
                             Object handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=====MyInterceptor拦截器的preHandle===="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * postHandle: 后处理方法
     * 参数：
     *  Object handler ： 被拦截的控制器对象（MyController）
     *  ModelAndView mv： 控制器方法的返回值（请求的执行结果）
     *
     * 特点：
     *  1. 在控制器方法之后执行的。
     *  2. 能获取到控制器方法的执行结果。 可以修改原来的执行结果。
     *     可以修改数据， 也可以修改视图
     *  3. 可以做对请求的二次处理。
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>
                           HttpServletResponse response<span class="token punctuation">,</span>
                           Object handler<span class="token punctuation">,</span>
                           ModelAndView mv<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=====MyInterceptor拦截器的postHandle===="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * afterCompletion: 最后执行的方法
     * 参数：
     *   Object handler ： 被拦截的控制器对象（MyController）
     *   Exception ex： 异常对象
     *
     * 特点：
     *  1. 在请求处理完成后执行的，
     *     请求处理完成的标志是 视图处理完成，对视图执行forward操作后。
     *
     *  2. 可以做程序最后要做的工作， 释放内存， 清理临时变量。
     *
     *  3. 方法的执行条件：
     *     1）当前的拦截器他的preHandle()方法必须执行。
     *     2）preHandle()必须返回true。
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span>HttpServletRequest request<span class="token punctuation">,</span>
                                HttpServletResponse response<span class="token punctuation">,</span>
                                Object handler<span class="token punctuation">,</span>
                                Exception ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"=====MyInterceptor拦截器的afterCompletion===="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h2 id="12、拦截器和过滤器的对比"><a href="#12、拦截器和过滤器的对比" class="headerlink" title="12、拦截器和过滤器的对比"></a>12、拦截器和过滤器的对比</h2><ol>
<li>拦截器是SpringMVC的对象，而过滤器是servlet中的对象</li>
<li>拦截器对象框架来帮助创建的，过滤器对象是tomact创建的对象。</li>
<li>拦截器是侧重对请求做判断的，处理的， 可以截断请求。 过滤器是侧重对request，response对象的属性，参数设置值的。 例如request.setCharacterEncoding(“utf-8”)</li>
<li>拦截器的他执行时间有三个， 控制器方法之前， 之后， 请求完成后。 过滤器是在请求之前。</li>
<li>拦截器是拦截对controller，动态资源请求的 。 过滤器可以过滤所有请求动态的和静态的。</li>
<li>拦截器和过滤器一起执行的， 先执行的过滤器，后面是 中央调度器 ， 后面才是拦截器， 再后面是控制器方法</li>
</ol>
<h2 id="13、REST代表着什么"><a href="#13、REST代表着什么" class="headerlink" title="13、REST代表着什么"></a>13、REST代表着什么</h2><p>REST代表着抽象状态转移，它是根据HTTP协议从客户端发送数据到服务端，例如：服务端的一本书可<br>以XML或JSON格式传递到客户端</p>
<h2 id="14、什么是安全的REST操作"><a href="#14、什么是安全的REST操作" class="headerlink" title="14、什么是安全的REST操作"></a>14、什么是安全的REST操作</h2><p>REST接口是通过HTTP方法完成操作</p>
<ul>
<li>一些HTTP操作是安全的，如GET和HEAD，它不能再服务器修改资源。</li>
<li>换句话来说，put、post、delete是不安全的，因为它们能修改服务端端资源。</li>
</ul>
<p>所以，是否安全的界限，在于是否修改服务端的资源。</p>
<h1 id="SpringBoot篇"><a href="#SpringBoot篇" class="headerlink" title="SpringBoot篇"></a>SpringBoot篇</h1><h2 id="1、为什么使用SpringBoot"><a href="#1、为什么使用SpringBoot" class="headerlink" title="1、为什么使用SpringBoot"></a>1、为什么使用SpringBoot</h2><blockquote>
<p>能快速创建生产级别的Spring应用</p>
</blockquote>
<p>优点:</p>
<ul>
<li>内嵌web服务器</li>
<li>自动starter依赖，简化构建配置。也就是说做我们的版本依赖。</li>
<li>自配配置Spring以及第三方功能</li>
</ul>
<p>SpringBoot是整合Spring技术栈的一站式框架。</p>
<p>SpringBoot是简化Spring技术栈的快速开发脚手架</p>
<p>1、依赖管理</p>
<ul>
<li>父项目依赖管理</li>
<li>无需关注版本号，自动版本仲裁</li>
<li>可以修改默认版本号</li>
<li>开发导入starter场景启动器</li>
</ul>
<p>2、自动装配</p>
<h2 id="2、SpringBoot的中一些常用注解"><a href="#2、SpringBoot的中一些常用注解" class="headerlink" title="2、SpringBoot的中一些常用注解"></a>2、SpringBoot的中一些常用注解</h2><ol>
<li><p>@Configuration:声明一个配置类</p>
<p>proxyBeanMethods：代理bean的方法</p>
<p>Full(proxyBeanMethods &#x3D; true)、【保证每个@Bean方法被调用多少次返回的组件都是单实例的】</p>
<p>Lite(proxyBeanMethods &#x3D; false)【每个@Bean方法被调用多少次返回的组件都是新创建的】</p>
<ul>
<li><pre><code>   组件依赖必须使用Full模式默认。其他默认是否Lite模式
</code></pre>
</li>
</ul>
</li>
<li><p>@Bean:给容器中添加组件。通常和@Configuration搭配使用。</p>
</li>
<li><p>@ComponentScan:扫描包结构下的类</p>
</li>
<li><p>@Import:给容器中自动创建出某几个类型的组件、默认组件的名称就是全类名</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{</span>User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> DBHelper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
</li>
<li><p>@Conditional：条件装配，满足Conditional指定的条件，则进行组件注入。</p>
<p>@ConditionalOnMissingBean(name &#x3D; “tom”) &#x2F;&#x2F;可以放到方法上和类上，容器中如果有tom组件，该方法会执行否者不会执行</p>
<p>@ConditionalOnBean&#x2F;&#x2F;当容器中有某个bean就执行</p>
</li>
<li><p>@ImportResource(“classpath:beans.xml”):可以导入我们的resource资源。</p>
</li>
<li><p>配置绑定:@EnableConfigurationProperties + @ConfigurationProperties</p>
</li>
</ol>
<h2 id="3、SpringBoot的配置原理"><a href="#3、SpringBoot的配置原理" class="headerlink" title="3、SpringBoot的配置原理"></a>3、SpringBoot的配置原理</h2><p>1、从入口的注解看，我们知道@SpringBootApplication相当于三个注解:</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootConfiguration</span>
<span class="token annotation punctuation">@EnableAutoConfiguration</span>
<span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> TypeExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> FilterType<span class="token punctuation">.</span>CUSTOM<span class="token punctuation">,</span> classes <span class="token operator">=</span> AutoConfigurationExcludeFilter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">{</span>
</code></pre>
<p>2、@SpringBootConfiguration 表示声明是一个配置类</p>
<p>点进去发现是一个@Configuration注解。表示这是一个配置类</p>
<p>3、@ComponenetScan:扫描注解，规定扫描那些东西。</p>
<p>4、重点的注解@EnableAutoConfiguration</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@AutoConfigurationPackage</span>
<span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>AutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAutoConfiguration</span> 
</code></pre>
<ul>
<li><p>@AutoConfigurationPackage:自动配置包</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>AutoConfigurationPackages<span class="token punctuation">.</span>Registrar<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//给容器中导入一个组件。</span>
<span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">AutoConfigurationPackage</span>
  
<span class="token comment" spellcheck="true">//利用register导入一系列组件</span>
<span class="token comment" spellcheck="true">//点进去发现</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerBeanDefinitions</span><span class="token punctuation">(</span>AnnotationMetadata metadata<span class="token punctuation">,</span> BeanDefinitionRegistry registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">register</span><span class="token punctuation">(</span>registry<span class="token punctuation">,</span> 
         <span class="token keyword">new</span> <span class="token class-name">PackageImports</span><span class="token punctuation">(</span>metadata<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPackageNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//通过idea的计算得到包名是：com.serookie</span>
<span class="token comment" spellcheck="true">//将指定的一个包下的所有组件导入进来.MainApplication 所在包下。  </span>
</code></pre>
</li>
<li><p>@Import(AutoConfigurationImportSelector.class)</p>
<pre class=" language-java"><code class="language-java"><span class="token number">1</span>、利用<span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span>给容器中批量导入一些组件
<span class="token number">2</span>、调用List<span class="token operator">&lt;</span>String<span class="token operator">></span> configurations <span class="token operator">=</span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span>获取到所有需要导入到容器中的配置类
<span class="token number">3</span>、利用SpringFactoriesLoader<span class="token punctuation">.</span>loadFactoryNames工厂加载
<span class="token keyword">private</span> <span class="token keyword">static</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">loadSpringFactories</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> ClassLoader classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>方法得到所有的组件<span class="token punctuation">.</span>
<span class="token number">4</span>、从META<span class="token operator">-</span>INF<span class="token operator">/</span>spring<span class="token punctuation">.</span>factories位置来加载一个文件。
<span class="token number">5</span>、 默认扫描我们当前系统里面所有META<span class="token operator">-</span>INF<span class="token operator">/</span>spring<span class="token punctuation">.</span>factories位置的文件
    spring<span class="token operator">-</span>boot<span class="token operator">-</span>autoconfigure<span class="token operator">-</span><span class="token number">2.3</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token punctuation">.</span>RELEASE<span class="token punctuation">.</span>jar包里面也有META<span class="token operator">-</span>INF<span class="token operator">/</span>spring<span class="token punctuation">.</span>factories  
</code></pre>
</li>
</ul>
<p>总结:</p>
<p>1、因为的我们的入口注解为@SpringBootConfiguration，表示我们的启动类是一个配置类</p>
<p>2、@EnableAutoConfiguration下面有两个注解分别是:@AutoConfigurationPackage自动配置包里面有一个Register，里面有一个PackageImport会将我们的指定的包下面的类进行导入。还有一个注解@Import(AutoConfigurationImportSelector.class)，将我们的指定的组件加入到我们的容器中。</p>
<p>3、利用我们的getAutoConfigurationEntry(annotationMetadata);给容器中批量导入一些组件</p>
<p>4、调用List<String> configurations &#x3D; getCandidateConfigurations(annotationMetadata, attributes)获取到所有需要导入到容器中的配置类</p>
<p>5、利用SpringFactoriesLoader.loadFactoryNames工厂加载，会从META-INF&#x2F;spring.factories位置来加载一个文件。默认扫描我们当前系统里面所有META-INF&#x2F;spring.factories位置的文件加载到我们的容器中。<br>    spring-boot-autoconfigure-2.3.4.RELEASE.jar包里面也有META-INF&#x2F;spring.factories</p>
<p>6、按需开启自动配置项，因为虽然会将我们的spring.factores里面的所有组件全部加载到容器中，但是这些配置类会有@Condition注解，来进行按需加载。</p>
<h2 id="4、保护SpringBoot到应用有哪些方法？"><a href="#4、保护SpringBoot到应用有哪些方法？" class="headerlink" title="4、保护SpringBoot到应用有哪些方法？"></a>4、保护SpringBoot到应用有哪些方法？</h2><p>1、在生产中使用https</p>
<p>2、使用snyk检查你的依赖关系:Snky就是用来检查你的依赖包安全漏洞的工具，确保你放心引用各种开源依赖包到你的工程中。</p>
<p>3、升级到最新版本</p>
<p>4、启用CSRF保护:<em>SRF</em>一般指跨站请求伪造。 </p>
<p>5、使用内容安全策略防止XSS攻击 XSS:跨站脚本攻击（也称为XSS）指利用网站漏洞从用户那里恶意盗取信息。</p>
<h2 id="5、文件上传"><a href="#5、文件上传" class="headerlink" title="5、文件上传"></a>5、文件上传</h2><p>1、页面表单</p>
<pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/upload<span class="token punctuation">"</span></span> <span class="token attr-name">enctype</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>multipart/form-data<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>file<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>提交<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>
</code></pre>
<p>2、java代码</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">"/upload"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> String <span class="token function">upload</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">)</span>MultipartFile file<span class="token punctuation">)</span><span class="token punctuation">{</span>
   log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"file:"</span><span class="token punctuation">,</span>file<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   String filename<span class="token operator">=</span>file<span class="token punctuation">.</span><span class="token function">getOriginalFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拿到文件名</span>
   file<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"位置"</span><span class="token operator">+</span>filename<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token string">"上传成功!"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>3、自动配置原理</p>
<p>**文件上传自动配置类-MultipartAutoConfiguration-**MultipartProperties</p>
<ul>
<li>自动配置好了 <strong>StandardServletMultipartResolver   【文件上传解析器】</strong></li>
<li>原理步骤<ul>
<li><strong>1、请求进来使用文件上传解析器判断（</strong>isMultipart<strong>）并封装（</strong>resolveMultipart，<strong>返回</strong>MultipartHttpServletRequest<strong>）文件上传请求</strong></li>
<li>2、参数解析器来解析请求中的文件内容封装成MultipartFile</li>
<li>3、将request中文件信息封装为一个Map；MultiValueMap&lt;String, MultipartFile&gt;</li>
</ul>
</li>
<li><strong>FileCopyUtils</strong>。实现文件流的拷贝</li>
</ul>
<h2 id="6、异常处理"><a href="#6、异常处理" class="headerlink" title="6、异常处理"></a>6、异常处理</h2><p>1、默认情况下，SpringBoot提供&#x2F;error处理所有错误的映射</p>
<p>2、对于机器客户端，它将生成JSON响应，其中包含错误，HTTP状态和异常消息的详细信息。对于浏览器客户端，响应一个“ whitelabel”错误视图，以HTML格式呈现相同的数据</p>
<ul>
<li><p>要对其进行自定义，添加View解析为error</p>
</li>
<li><p>要完全替换默认行为，可以实现 <code>ErrorController </code>并注册该类型的Bean定义，或添加<code>ErrorAttributes类型的组件</code>以使用现有机制但替换其内容。</p>
</li>
<li><p>error&#x2F;下的4xx，5xx页面会被自动解析；</p>
</li>
</ul>
<h2 id="7、配置文件的启用"><a href="#7、配置文件的启用" class="headerlink" title="7、配置文件的启用"></a>7、配置文件的启用</h2><p>为了方便多环境适配，springboot简化了profile功能。</p>
<p>1、配置文件激活有两种方式</p>
<ul>
<li>第一种在单体应用下:可以使用java命令来进行启动 java -jar xxx.jar –spring.profiles.active&#x3D;prod</li>
<li>第二种可以采用热部署dev的方式，在不重启springboot程序下，也可以修改我们的文件。</li>
<li>第三种在分布式应用下:nacos,集成了配置中心，所以可以直接修改配置中心。</li>
</ul>
<h2 id="8、自定义starter"><a href="#8、自定义starter" class="headerlink" title="8、自定义starter"></a>8、自定义starter</h2><p>我们在springboot中需要使用那个场景就可以导入那个场景的启动器starter即可，但是当我们去查看发现这个starter里面没有导入任何代码,真正导入代码的是autoconfigure。</p>
<img src="https://blog-1300811828.cos.ap-shanghai.myqcloud.com/uPic/image-20220821000802720.png" alt="image-20220821000802720" style="zoom:50%;" />

<ul>
<li>autoconfigure包中配置使用 <strong>META-INF&#x2F;spring.factories</strong> 中 <strong>EnableAutoConfiguration 的值，使得项目启动加载指定的自动配置类</strong></li>
<li><strong>编写自动配置类 xxxAutoConfiguration -&gt; xxxxProperties</strong></li>
<li><strong>@Configuration</strong></li>
<li><strong>@Conditional</strong></li>
<li><strong>@EnableConfigurationProperties</strong></li>
</ul>
<p><strong>引入starter</strong> <strong>— xxxAutoConfiguration — 容器中放入组件 —- 绑定xxxProperties —-</strong> <strong>配置项</strong></p>
<p>自定义starter:</p>
<p>Kevintam-hello-spring-boot-starter（启动器）</p>
<p>kevintam-hello-spring-boot-starter-autoconfigure（自动配置包）</p>
<p>自动配置的原理总结:</p>
<ul>
<li>SpringBoot在启动时会去AutoConfiguration中MATE—INF中的Springfactorys的文件,去读取的里面的自动配置类的权限定类名路径。</li>
<li>然后按需进行加载，因为自动配置类上会有注解@Conditional相关注解，去实现按需加载到IOC容器中。完成初始化操作。</li>
</ul>
<p>总结:</p>
<p>1、创建一个启动器starter，在启动器中导入一个autoconfiguration.</p>
<p>2、创建一个AutoConfiguration,在autoconfiguration中编写代码.</p>
<p>3、编写一个xxxxAutoConfiguration，自动配置类,使用Conditional条件装配的注解。来进行按需加载。</p>
<p>4、使用maven命令，将两个项目打包成jar，放到maven仓库中即可。</p>
<p>5、使用时,只需要导入这个启动器,即可运行。</p>
<p>很像我们的java的spi机制。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">kevintam</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2023/05/02/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/">http://example.com/2023/05/02/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint policy. If reproduced, please indicate source
                    <a href="/about" target="_blank">kevintam</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">No tag</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2023/05/02/MySQL%E9%9D%A2%E8%AF%95%E9%A2%98/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-05-02
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            kevintam
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/04/06/%E9%9D%A2%E8%AF%95%E9%A2%98/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/5.jpg" class="responsive-img" alt="面试题">
                        
                        <span class="card-title">面试题</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-04-06
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%8A%80%E6%9C%AF/" class="post-category">
                                    技术
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/java/">
                        <span class="chip bg-color">java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + 'From: kevintam<br />'
            + 'Author: kevintam<br />'
            + 'Link: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">kevintam</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;Total visits:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;Total visitors:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/txh-rookie" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=843808107" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 843808107" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
